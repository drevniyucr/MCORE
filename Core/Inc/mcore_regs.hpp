#pragma once
#include "mcore_utils.hpp"


/*------------------------------------------------------------------------------
------------------------ Coretex-M7 Register Descripton ------------------------
------------------------------------------------------------------------------*/

// Generated from xml file: ./xml-svd/system_registers_m7.xml

// --------------------------------------------
// Control: System Control registers
// --------------------------------------------
namespace SCB {

    // ACTLR: Disables certain aspects of functionality within the processor
    struct _ACTLR : Register <0xE000E008, ReadWrite, _ACTLR> {
        using DISOOFP = Field <_ACTLR, 9, 1>; // Bits [9] : Disables floating point instructions completing out of order with respect to integer instructions
        using DISFPCA = Field <_ACTLR, 8, 1>; // Bits [8] : Disable automatic update of CONTROL.FPCA
        using DISFOLD = Field <_ACTLR, 2, 1>; // Bits [2] : Disables folding of IT instructions
        using DISDEFWBUF = Field <_ACTLR, 1, 1>; // Bits [1] : Disables write buffer use during default memory map accesses
        using DISMCYCINT = Field <_ACTLR, 0, 1>; // Bits [0] : Disables interruption of multi-cycle instructions
    };

    // ICSR: Provides software control of the NMI, PendSV, and SysTick exceptions, and provides interrupt status information
    struct _ICSR : Register <0xE000ED04, ReadWrite, _ICSR> {
        using NMIPENDSET = Field <_ICSR, 31, 1>; // Bits [31] : Activates an NMI exception or reads back the current state
        using PENDSVSET = Field <_ICSR, 28, 1>; // Bits [28] : Sets a pending PendSV interrupt or reads back the current state
        using PENDSVCLR = Field <_ICSR, 27, 1>; // Bits [27] : Clears a pending PendSV interrupt
        using PENDSTSET = Field <_ICSR, 26, 1>; // Bits [26] : Sets a pending SysTick or reads back the current state
        using PENDSTCLR = Field <_ICSR, 25, 1>; // Bits [25] : Clears a pending SysTick, whether set here or by the timer hardware
        using ISRPREEMPT = Field <_ICSR, 23, 1>; // Bits [23] : Indicates whether a pending exception will be serviced on exit from debug halt state
        using ISRPENDING = Field <_ICSR, 22, 1>; // Bits [22] : Indicates if an external configurable, NVIC generated, interrupt is pending
        using VECTPENDING = Field <_ICSR, 12, 9>; // Bits [20:12] : The exception number for the highest priority pending exception. 0 indicates no pending exceptions
        using RETTOBASE = Field <_ICSR, 11, 1>; // Bits [11] : In Handler mode, indicates whether there is an active exception other than the exception indicated by the current value of the IPSR
        using VECTACTIVE = Field <_ICSR, 0, 9>; // Bits [8:0] : The exception number for the current executing exception
    };

    // VTOR: Holds the vector table address
    struct _VTOR : Register <0xE000ED08, ReadWrite, _VTOR> {
        using TBLOFF = Field <_VTOR, 7, 25>; // Bits [31:7] : Bits [31:7] of the vector table address
        using TBLBASE = Field <_VTOR, 29, 1>; // Bits [29] : Determines whether the vector table is in the code or SRAM memory region
    };

    // DEMCR: Manages vector catch behaviour and DebugMonitor handling when debugging
    struct _DEMCR : Register <0xE000EDFC, ReadOnly, _DEMCR> {
        using MON_EN = Field <_DEMCR, 16, 1>; // Bits [16] : Enable the DebugMonitor exception
        using MON_PEND = Field <_DEMCR, 17, 1>; // Bits [17] : Sets or clears the pending state of the DebugMonitor exception
    };

    // AIRCR: Sets or returns interrupt control data
    struct _AIRCR : Register <0xE000ED0C, ReadWrite, _AIRCR> {
        using VECTKEY = Field <_AIRCR, 16, 16>; // Bits [31:16] : Vector Key
        using VECTKEYSTAT = Field <_AIRCR, 16, 16>; // Bits [31:16] : UNKNOWN
        using ENDIANNESS = Field <_AIRCR, 15, 1>; // Bits [15] : Indicates the memory system data endianness
        using PRIGROUP = Field <_AIRCR, 8, 3>; // Bits [10:8] : Priority grouping, indicates the binary point position.
        using SYSRESETREQ = Field <_AIRCR, 2, 1>; // Bits [2] : System Reset Request
        using VECTCLRACTIVE = Field <_AIRCR, 1, 1>; // Bits [1] : Clears all active state information for fixed and configurable exceptions
    };

    // SCR: Sets or returns system control data
    struct _SCR : Register <0xE000ED10, ReadWrite, _SCR> {
        using SEVONPEND = Field <_SCR, 4, 1>; // Bits [4] : Determines whether an interrupt transition from inactive state to pending state is a wakeup event
        using SLEEPDEEP = Field <_SCR, 2, 1>; // Bits [2] : Hint indicating that waking from sleep might take longer
        using SLEEPONEXIT = Field <_SCR, 1, 1>; // Bits [1] : whether, on an exit from an ISR that returns to the base level of execution priority, the processor enters a sleep state
    };

    // CCR: Configuration and Control
    struct _CCR : Register <0xE000ED14, ReadWrite, _CCR> {
        using BP = Field <_CCR, 18, 1>; // Bits [18] : Setting this bit to 1 enables branch prediction, also called program flow prediction
        using IC = Field <_CCR, 17, 1>; // Bits [17] : This is a global enable bit for instruction caches
        using DC = Field <_CCR, 16, 1>; // Bits [16] : This is a global enable bit for data and unified caches
        using STKALIGN = Field <_CCR, 9, 1>; // Bits [9] : Determines whether the exception entry sequence guarantees 8-byte stack frame alignment, adjusting the SP if necessary before saving state
        using BFHFNMIGN = Field <_CCR, 8, 1>; // Bits [8] : Determines the effect of precise data access faults on handlers running at priority -1 or priority -2
        using DIV_0_TRP = Field <_CCR, 4, 1>; // Bits [4] : Controls the trap on divide by 0
        using UNALIGN_TRP = Field <_CCR, 3, 1>; // Bits [3] : Controls the trapping of unaligned word or halfword accesses
        using USERSETMPEND = Field <_CCR, 1, 1>; // Bits [1] : Controls whether unprivileged software can access the STIR
        using NONBASETHRDENA = Field <_CCR, 0, 1>; // Bits [0] : Controls whether the processor can enter Thread mode at an execution priority level other than base level
    };

    // SHPR1: Sets or returns priority for system handlers 4-7
    struct _SHPR1 : Register <0xE000ED18, ReadWrite, _SHPR1> {
        using PRI_7 = Field <_SHPR1, 24, 8>; // Bits [31:24] : Priority of system handler 7
        using PRI_6 = Field <_SHPR1, 16, 8>; // Bits [23:16] : Priority of system handler 6, UsageFault
        using PRI_5 = Field <_SHPR1, 8, 8>; // Bits [15:8] : Priority of system handler 5, BusFault
        using PRI_4 = Field <_SHPR1, 0, 8>; // Bits [7:0] : Priority of system handler 4, MemManage
    };

    // SHPR2: Sets or returns priority for system handlers 8-11
    struct _SHPR2 : Register <0xE000ED1C, ReadWrite, _SHPR2> {
        using PRI_11 = Field <_SHPR2, 24, 8>; // Bits [31:24] : Priority of system handler 11, SVCall
        using PRI_10 = Field <_SHPR2, 16, 8>; // Bits [23:16] : Priority of system handler 10
        using PRI_9 = Field <_SHPR2, 8, 8>; // Bits [15:8] : Priority of system handler 9
        using PRI_8 = Field <_SHPR2, 0, 8>; // Bits [7:0] : Priority of system handler 8
    };

    // SHPR3: Sets or returns priority for system handlers 12-15
    struct _SHPR3 : Register <0xE000ED20, ReadWrite, _SHPR3> {
        using PRI_15 = Field <_SHPR3, 24, 8>; // Bits [31:24] : Priority of system handler 15, SysTick
        using PRI_14 = Field <_SHPR3, 16, 8>; // Bits [23:16] : Priority of system handler 14, PendSV
        using PRI_13 = Field <_SHPR3, 8, 8>; // Bits [15:8] : Priority of system handler 13
        using PRI_12 = Field <_SHPR3, 0, 8>; // Bits [7:0] : Priority of system handler 4, DebugMonitor
    };

    // SHCSR: Controls and provides the active and pending status of system exceptions
    struct _SHCSR : Register <0xE000ED24, ReadWrite, _SHCSR> {
        using USGFAULTENA = Field <_SHCSR, 18, 1>; // Bits [18] : Enable UsageFault
        using BUSFAULTENA = Field <_SHCSR, 17, 1>; // Bits [17] : Enable BusFault
        using MEMFAULTENA = Field <_SHCSR, 16, 1>; // Bits [16] : Enable MemManage fault
        using SVCALLPENDED = Field <_SHCSR, 15, 1>; // Bits [15] : SVCall pending
        using BUSFAULTPENDED = Field <_SHCSR, 14, 1>; // Bits [14] : BusFault pending
        using MEMFAULTPENDED = Field <_SHCSR, 13, 1>; // Bits [13] : MemManage pending
        using USGFAULTPENDED = Field <_SHCSR, 12, 1>; // Bits [12] : UsageFault pending
        using SYSTICKACT = Field <_SHCSR, 11, 1>; // Bits [11] : SysTick active
        using PENDSVACT = Field <_SHCSR, 10, 1>; // Bits [10] : PendSV active
        using MONITORACT = Field <_SHCSR, 8, 1>; // Bits [8] : Monitor active
        using SVCALLACT = Field <_SHCSR, 7, 1>; // Bits [7] : SVCall active
        using USGFAULTACT = Field <_SHCSR, 3, 1>; // Bits [3] : UsageFault active
        using BUSFAULTACT = Field <_SHCSR, 1, 1>; // Bits [1] : BusFault active
        using MEMFAULTACT = Field <_SHCSR, 0, 1>; // Bits [0] : MemManage active
    };

    // CFSR: Contains the three Configurable Fault Status Registers MMFSR, BFSR, UFSR
    struct _CFSR : Register <0xE000ED28, ReadWrite, _CFSR> {
        using DIVBYZERO = Field <_CFSR, 25, 1>; // Bits [25] : Divide by zero error
        using UNALIGNED = Field <_CFSR, 24, 1>; // Bits [24] : Unaligned access error
        using NOCP = Field <_CFSR, 19, 1>; // Bits [19] : Coprocessor access error
        using INVPC = Field <_CFSR, 18, 1>; // Bits [18] : Integrity check error on EXC_RETURN
        using INVSTATE = Field <_CFSR, 17, 1>; // Bits [17] : Instruction executed with invalid EPSR.T or EPSR.IT field
        using UNDEFINSTR = Field <_CFSR, 16, 1>; // Bits [16] : Processor has attempted to execute an undefined instruction.
        using BFARVALID = Field <_CFSR, 15, 1>; // Bits [15] : BFAR has valid contents
        using LSPERR = Field <_CFSR, 13, 1>; // Bits [13] : Bus fault during FP lazy state preservation
        using STKERR = Field <_CFSR, 12, 1>; // Bits [12] : Derived bus fault on exception entry
        using UNSTKERR = Field <_CFSR, 11, 1>; // Bits [11] : Derived bus fault on exception return
        using IMPRECISERR = Field <_CFSR, 10, 1>; // Bits [10] : Imprecise data access error
        using PRECISERR = Field <_CFSR, 9, 1>; // Bits [9] : Precise data access error
        using IBUSERR = Field <_CFSR, 8, 1>; // Bits [8] : Bus fault on an instruction prefetch
        using MMARVALID = Field <_CFSR, 7, 1>; // Bits [7] : MMAR has valid contents
        using MLSPERR = Field <_CFSR, 5, 1>; // Bits [5] : MemManage fault during FP lazy state preservation
        using MSTKERR = Field <_CFSR, 4, 1>; // Bits [4] : Derived MemManage fault on exception entry
        using MUNSTKERR = Field <_CFSR, 3, 1>; // Bits [3] : Derived MemManage fault on exception return
        using DACCVIOL = Field <_CFSR, 1, 1>; // Bits [1] : Data access violation. The MMAR shows the data address that the load or store tried to access
        using IACCVIOL = Field <_CFSR, 0, 1>; // Bits [0] : MPU or Execute Never (XN) default memory map access violation on an instruction fetch
    };

    // HFSR: Shows the cause of any hard faults
    struct _HFSR : Register <0xE000ED2C, ReadWrite, _HFSR> {
        using DEBUGEVT = Field <_HFSR, 31, 1>; // Bits [31] : Indicates a Debug event has occurred
        using FORCED = Field <_HFSR, 30, 1>; // Bits [30] : Indicates a fault with configurable priority has been escalated to a HardFault
        using VECTTBL = Field <_HFSR, 1, 1>; // Bits [1] : Indicates a fault has occurred because of a vector table read error on exception processing
    };

    // DFSR: Shows, at the top level, why a debug event occurred
    struct _DFSR : Register <0xE000ED30, ReadWrite, _DFSR> {
        using EXTERNAL = Field <_DFSR, 4, 1>; // Bits [4] : Indicates a debug event generated because of the assertion of EDBGRQ
        using VCATCH = Field <_DFSR, 3, 1>; // Bits [3] : Indicates triggering of a Vector catch
        using DWTTRAP = Field <_DFSR, 2, 1>; // Bits [2] : Indicates a debug event generated by the DWT
        using BKPT = Field <_DFSR, 1, 1>; // Bits [1] : Indicates a debug event generated by BKPT instruction execution or a breakpoint match in FPB
        using HALTED = Field <_DFSR, 0, 1>; // Bits [0] : Indicates a debug event generated by C_HALT or C_STEP request or setting DEMCR.MON_STEP
    };

    // MMFAR: Shows the address of the memory location that caused an MMU fault
    struct _MMFAR : Register <0xE000ED34, ReadWrite, _MMFAR> {
    };

    // BFAR: Shows the address associated with a precise data access fault
    struct _BFAR : Register <0xE000ED38, ReadWrite, _BFAR> {
    };

    // AFSR: Latched version of the AUXFAULT inputs
    struct _AFSR : Register <0xE000ED3C, ReadWrite, _AFSR> {
    };

    // CPACR: Specifies the access privileges for coprocessors
    struct _CPACR : Register <0xE000ED88, ReadWrite, _CPACR> {
        using CP11 = Field <_CPACR, 22, 2>; // Bits [23:22] : Defines access permissions for the CP11 coprocessor.
        using CP10 = Field <_CPACR, 20, 2>; // Bits [21:20] : Defines access permissions for the CP10 coprocessor.
        using CP7 = Field <_CPACR, 14, 2>; // Bits [15:14] : Defines access permissions for the CP7 coprocessor.
        using CP6 = Field <_CPACR, 12, 2>; // Bits [13:12] : Defines access permissions for the CP6 coprocessor.
        using CP5 = Field <_CPACR, 10, 2>; // Bits [11:10] : Defines access permissions for the CP5 coprocessor.
        using CP4 = Field <_CPACR, 8, 2>; // Bits [9:8] : Defines access permissions for the CP4 coprocessor.
        using CP3 = Field <_CPACR, 6, 2>; // Bits [7:6] : Defines access permissions for the CP3 coprocessor.
        using CP2 = Field <_CPACR, 4, 2>; // Bits [5:4] : Defines access permissions for the CP2 coprocessor.
        using CP1 = Field <_CPACR, 2, 2>; // Bits [3:2] : Defines access permissions for the CP1 coprocessor.
        using CP0 = Field <_CPACR, 0, 2>; // Bits [1:0] : Defines access permissions for the CP0 coprocessor.
    };

    // STIR: Provides a mechanism for software to generate an interrupt
    struct _STIR : Register <0xE000EF00, WriteOnly, _STIR> {
        using INTID = Field <_STIR, 0, 9>; // Bits [8:0] : Indicates the interrupt to be triggered. The value written is (ExceptionNumber - 16)
    };

} // namespace Control

// --------------------------------------------
// ID: ID registers
// --------------------------------------------
namespace ID {

    // CPUID: Identification information for the processor
    struct _CPUID : Register <0xE000ED00, ReadOnly, _CPUID> {
        using Implementer = Field <_CPUID, 24, 8>; // Bits [31:24] : Implementer code
        using Variant = Field <_CPUID, 20, 4>; // Bits [23:20] : Implementation defined
        using Constant = Field <_CPUID, 16, 4>; // Bits [19:16] : Indicates the architecture
        using Partno = Field <_CPUID, 4, 12>; // Bits [15:4] : Indicates part number
        using Revision = Field <_CPUID, 0, 4>; // Bits [3:0] : Indicates revision
    };

    struct _ID_PFR0 : Register <0xE000ED40, ReadOnly, _ID_PFR0> {
        using State1 = Field <_ID_PFR0, 4, 4>; // Bits [7:4] : Thumb instruction set support
    };

    struct _ID_PFR1 : Register <0xE000ED44, ReadOnly, _ID_PFR1> {
        using M_Profile = Field <_ID_PFR1, 8, 4>; // Bits [11:8] : M profile programmers' model
    };

    struct _ID_DFR0 : Register <0xE000ED48, ReadOnly, _ID_DFR0> {
        using M_Profile = Field <_ID_DFR0, 20, 4>; // Bits [23:20] : Debug model, M profile
    };

    // ID_AFR0: Implementation defined features
    struct _ID_AFR0 : Register <0xE000ED4C, ReadOnly, _ID_AFR0> {
    };

    // ID_MMFR0: Memory Model Features
    struct _ID_MMFR0 : Register <0xE000ED50, ReadOnly, _ID_MMFR0> {
        using Auxiliary_registers = Field <_ID_MMFR0, 20, 4>; // Bits [23:20] : Indicates support for Auxiliary registers
        using TCM_support = Field <_ID_MMFR0, 16, 4>; // Bits [19:16] : Indicates support for TCM
        using Shareability_levels = Field <_ID_MMFR0, 12, 4>; // Bits [15:12] : Indicates the number of shareability levels implemented
        using Outermost_shareability = Field <_ID_MMFR0, 8, 4>; // Bits [11:8] : Indicates the outermost shareability domain implemented
        using PMSA = Field <_ID_MMFR0, 4, 4>; // Bits [7:4] : Indicates support for a PMSA
    };

    // ID_MMFR1: Memory Model Features
    struct _ID_MMFR1 : Register <0xE000ED54, ReadOnly, _ID_MMFR1> {
    };

    // ID_MMFR2: Memory Model Features
    struct _ID_MMFR2 : Register <0xE000ED58, ReadOnly, _ID_MMFR2> {
        using WFI = Field <_ID_MMFR2, 24, 4>; // Bits [27:24] : Indicates support for wait-for-interrupt stalling.
    };

    // ID_MMFR3: Memory Model Features
    struct _ID_MMFR3 : Register <0xE000ED5C, ReadOnly, _ID_MMFR3> {
    };

    // ID_ISAR0: Instruction Set Attributes
    struct _ID_ISAR0 : Register <0xE000ED60, ReadOnly, _ID_ISAR0> {
        using Divide_instrs = Field <_ID_ISAR0, 24, 4>; // Bits [27:24] : Indicates the supported divide instructions
        using Debug_instrs = Field <_ID_ISAR0, 20, 4>; // Bits [23:20] : Indicates the supported debug instructions
        using Coproc_instrs = Field <_ID_ISAR0, 16, 4>; // Bits [19:16] : Indicates the supported coprocessor instructions
        using CmpBranch_instrs = Field <_ID_ISAR0, 12, 4>; // Bits [15:12] : Indicates support for combined compare and branch instructions.
        using Bitfield_instrs = Field <_ID_ISAR0, 8, 4>; // Bits [11:8] : Indicates support for bitfield instructions.
        using BitCount_instrs = Field <_ID_ISAR0, 4, 4>; // Bits [7:4] : Indicates support for bit counting instructions.
    };

    // ID_ISAR1: Instruction Set Attributes
    struct _ID_ISAR1 : Register <0xE000ED64, ReadOnly, _ID_ISAR1> {
        using Interwork_instrs = Field <_ID_ISAR1, 24, 4>; // Bits [27:24] : Indicates support for instructions that branch between ARM and Thumb code.
        using Immediate_instrs = Field <_ID_ISAR1, 20, 4>; // Bits [23:20] : Indicates support for immediate instructions.
        using IfThen_instrs = Field <_ID_ISAR1, 16, 4>; // Bits [19:16] : Indicates support for IfThen instructions.
        using Extend_instrs = Field <_ID_ISAR1, 12, 4>; // Bits [15:12] : Indicates support for sign or zero extend instructions.
    };

    // ID_ISAR2: Instruction Set Attributes
    struct _ID_ISAR2 : Register <0xE000ED68, ReadOnly, _ID_ISAR2> {
        using Reversal_instrs = Field <_ID_ISAR2, 28, 4>; // Bits [31:28] : Indicates the supported reversal instructions.
        using MultU_instrs = Field <_ID_ISAR2, 20, 4>; // Bits [23:20] : Indicates the supported advanced unsigned multiply instructions.
        using MultS_instrs = Field <_ID_ISAR2, 16, 4>; // Bits [19:16] : Indicates the supported advanced signed multiply instructions.
        using Mult_instrs = Field <_ID_ISAR2, 12, 4>; // Bits [15:12] : Indicates the supported additional multiply instructions.
        //using MultiAccessInt_instrs = Field <_ID_ISAR2, 8, 4>; // Bits [11:8] : Indicates the supported multi-access interruptible instructions.
        using MultiAccessInt_instrs = Field <_ID_ISAR2, 4, 8>; // Bits [7:4] : Indicates the supported memory hint instructions.
        using LoadStore_instrs = Field <_ID_ISAR2, 0, 4>; // Bits [3:0] : Indicates the supported additional load and store instructions.
    };

    // ID_ISAR3: Instruction Set Attributes
    struct _ID_ISAR3 : Register <0xE000ED6C, ReadOnly, _ID_ISAR3> {
        using TrueNOP_instrs = Field <_ID_ISAR3, 24, 4>; // Bits [27:24] : Indicates support for true NOP instructions.
        using ThumbCopy_instrs = Field <_ID_ISAR3, 20, 4>; // Bits [23:20] : Indicates support for Thumb copy instructions.
        using TabBranch_instrs = Field <_ID_ISAR3, 16, 4>; // Bits [19:16] : Indicates support for table branch instructions.
        using SynchPrim_instrs = Field <_ID_ISAR3, 12, 4>; // Bits [15:12] : Indicates support for synchronization primitive instructions.
        using SVC_instrs = Field <_ID_ISAR3, 8, 4>; // Bits [11:8] : Indicates support for SVC instructions.
        using SIMD_instrs = Field <_ID_ISAR3, 4, 4>; // Bits [7:4] : Indicates support for Single Instruction Multiple Data (SIMD) instructions.
        using Saturate_instrs = Field <_ID_ISAR3, 0, 4>; // Bits [3:0] : Indicates support for saturate instructions.
    };

    // ID_ISAR4: Instruction Set Attributes
    struct _ID_ISAR4 : Register <0xE000ED70, ReadOnly, _ID_ISAR4> {
        using PSR_M_instrs = Field <_ID_ISAR4, 24, 4>; // Bits [27:24] : Indicates support for saturate instructions.
        using SynchPrim_instrs_frac = Field <_ID_ISAR4, 20, 4>; // Bits [23:20] : Indicates support for Synchronization Primitives
        using Barrier_instrs = Field <_ID_ISAR4, 16, 4>; // Bits [19:16] : Indicates the supported barrier instructions.
        using Writeback_instrs = Field <_ID_ISAR4, 8, 4>; // Bits [11:8] : Indicates support for Writeback addressing modes
        using WithShifts_instrs = Field <_ID_ISAR4, 4, 4>; // Bits [7:4] : Indicates the support for instructions with shifts:
        using Unpriv_instrs = Field <_ID_ISAR4, 0, 4>; // Bits [3:0] : Indicates the supported unprivileged instructions
    };

} // namespace ID

// --------------------------------------------
// FPE: FP System Control registers
// --------------------------------------------
namespace FPU {

    // FPCCR: Holds control data for the floating-point unit
    struct _FPCCR : Register <0xE000EF34, ReadWrite, _FPCCR> {
        using ASPEN = Field <_FPCCR, 31, 1>; // Bits [31] : When this bit is set to 1, execution of a floating-point instruction sets the CONTROL.FPCA bit to 1
        using LSPEN = Field <_FPCCR, 30, 1>; // Bits [30] : Enables lazy context save of FP state
        using MONRDY = Field <_FPCCR, 8, 1>; // Bits [8] : Indicates whether the software executing when the processor allocated the FP stack frame was able to set the DebugMonitor exception to pending
        using BFRDY = Field <_FPCCR, 6, 1>; // Bits [6] : Indicates whether the software executing when the processor allocated the FP stack frame was able to set the BusFault exception to pending
        using MMRDY = Field <_FPCCR, 5, 1>; // Bits [5] : Indicates whether the software executing when the processor allocated the FP stack frame was able to set the MemManage exception to pending
        using HFRDY = Field <_FPCCR, 4, 1>; // Bits [4] : Indicates whether the software executing when the processor allocated the FP stack frame was able to set the HardFault exception to pending
        using THREAD = Field <_FPCCR, 3, 1>; // Bits [3] : Indicates the processor mode when it allocated the FP stack frame
        using USER = Field <_FPCCR, 1, 1>; // Bits [1] : Indicates the privilege level of the software executing when the processor allocated the FP stack frame
        using LSPACT = Field <_FPCCR, 0, 1>; // Bits [0] : Indicates whether Lazy preservation of the FP state is active
    };

    // FPCAR: Holds the location of the unpopulated floating-point register space allocated on an exception stack frame
    struct _FPCAR : Register <0xE000EF38, ReadWrite, _FPCAR> {
    };

    // FPDSCR: Holds the default values for the floating-point status control data that the processor assigns to the FPSCR when it creates a new floating-point context
    struct _FPDSCR : Register <0xE000EF3C, ReadWrite, _FPDSCR> {
        using AHP = Field <_FPDSCR, 26, 1>; // Bits [26] : Default value for FPSCR.AHP
        using DN = Field <_FPDSCR, 25, 1>; // Bits [25] : Default value for FPSCR.DN
        using FZ = Field <_FPDSCR, 24, 1>; // Bits [24] : Default value for FPSCR.FZ
        using RMode = Field <_FPDSCR, 22, 2>; // Bits [23:22] : Default value for FPSCR.RMode
    };

    // MVFR0: Describes the features provided by the Floating-point extension
    struct _MVFR0 : Register <0xE000EF40, ReadOnly, _MVFR0> {
        using FP_Rounding_modes = Field <_MVFR0, 28, 4>; // Bits [31:28] : Indicates the rounding modes supported by the FP floating-point hardware
        using Short_vectors = Field <_MVFR0, 24, 4>; // Bits [27:24] : Indicates the hardware support for FP short vectors
        using Square_root = Field <_MVFR0, 20, 4>; // Bits [23:20] : Indicates the hardware support for FP square root operations
        using Divide = Field <_MVFR0, 16, 4>; // Bits [19:16] : Indicates the hardware support for FP divide operations
        using FP_exception_trapping = Field <_MVFR0, 12, 4>; // Bits [15:12] : Indicates whether the FP hardware implementation supports exception trapping
        using Double_precision = Field <_MVFR0, 8, 4>; // Bits [11:8] : Indicates the hardware support for FP double-precision operations
        using Single_precision = Field <_MVFR0, 4, 4>; // Bits [7:4] : Indicates the hardware support for FP single-precision operations
        using A_SIMD = Field <_MVFR0, 0, 4>; // Bits [3:0] : Indicates the size of the FP register bank
    };

    // MVFR1: Describes the features provided by the Floating-point extension
    struct _MVFR1 : Register <0xE000EF44, ReadOnly, _MVFR1> {
        using FP_fused_MAC = Field <_MVFR1, 28, 4>; // Bits [31:28] : Indicates whether the FP supports fused multiply accumulate operations
        using FP_HPFP = Field <_MVFR1, 24, 4>; // Bits [27:24] : Indicates whether the FP supports half-precision floating-point conversion operations
        using D_NaN = Field <_MVFR1, 4, 4>; // Bits [7:4] : Indicates whether the FP hardware implementation supports only the Default NaN mode
        using FtZ = Field <_MVFR1, 0, 4>; // Bits [3:0] : Indicates whether the FP hardware implementation supports only the Flush-to-Zero mode of operation
    };

    // MVFR2: Describes the features provided by the Floating-point extension
    struct _MVFR2 : Register <0xE000EF48, ReadOnly, _MVFR2> {
        using VFP_Misc = Field <_MVFR2, 4, 4>; // Bits [7:4] : Indicates whether the FP hardware implementation supports Floating-point selection, Floating-point Conversion to Integer with Direct Rounding Modes, Floating-point Round to Integral Floating-point and Floating-point MaxNum and MinNum
    };

} // namespace FPU

// --------------------------------------------
// SysTick: System Timer registers
// --------------------------------------------
namespace SysTick {

    // STCSR: Controls the system timer and provides status data
    struct _STCSR : Register <0xE000E010, ReadWrite, _STCSR> {
        using COUNTFLAG = Field <_STCSR, 16, 1>; // Bits [16] : Indicates whether the counter has counted to 0 since the last read of this register
        using CLKSOURCE = Field <_STCSR, 2, 1>; // Bits [2] : Indicates the SysTick clock source
        using TICKINT = Field <_STCSR, 1, 1>; // Bits [1] : Indicates whether counting to 0 causes the status of the SysTick exception to change to pending
        using ENABLE = Field <_STCSR, 0, 1>; // Bits [0] : Indicates the enabled status of the SysTick counter
    };

    // STRVR: Sets or reads the reload value of the SYST_CVR register
    struct _STRVR : Register <0xE000E014, ReadWrite, _STRVR> {
        using RELOAD = Field <_STRVR, 0, 24>; // Bits [23:0] : The value to load into the SYST_CVR register when the counter reaches 0
    };

    // STCVR: Reads or clears the current counter value
    struct _STCVR : Register <0xE000E018, ReadWrite, _STCVR> {
        using CURRENT = Field <_STCVR, 0, 24>; // Bits [23:0] : This is the value of the counter at the time it is sampled
    };

    // STCR: Reads the calibration value and parameters for SysTick
    struct _STCR : Register <0xE000E01C, ReadOnly, _STCR> {
        using NOREF = Field <_STCR, 31, 1>; // Bits [31] : Indicates whether the IMPLEMENTATION DEFINED reference clock is provided
        using SKEW = Field <_STCR, 30, 1>; // Bits [30] : Indicates whether the 10ms calibration value is exact
        using TENMS = Field <_STCR, 0, 24>; // Bits [23:0] : Optionally, holds a reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors
    };

} // namespace SysTick

// --------------------------------------------
// ImpDef: Implementation defined registers
// --------------------------------------------
namespace ImpDef {

    // ITCMCR: Controls whether an access is mapped to TCM or AXIM
    struct _ITCMCR : Register <0xE000EF90, ReadWrite, _ITCMCR> {
        using SZ = Field <_ITCMCR, 3, 4>; // Bits [6:3] : Indicates the size of the relevant TCM
        using RETEN = Field <_ITCMCR, 2, 1>; // Bits [2] : When enabled the processor will guarantee to honour the retry output on the corresponding TCM interface
        using RMW = Field <_ITCMCR, 1, 1>; // Bits [1] : Indicates that all sub-chunk writes to a given TCM use a RMW sequence
        using EN = Field <_ITCMCR, 0, 1>; // Bits [0] : Enable TCM. When a TCM is disabled all accesses are made to the AXIM
    };

    // DTCMCR: Controls whether an access is mapped to TCM or AXIM
    struct _DTCMCR : Register <0xE000EF94, ReadWrite, _DTCMCR> {
        using TCM_Size = Field <_DTCMCR, 3, 4>; // Bits [6:3] : Indicates the size of the relevant TCM
        using RETEN = Field <_DTCMCR, 2, 1>; // Bits [2] : When enabled the processor will guarantee to honour the retry output on the corresponding TCM interface
        using RMW = Field <_DTCMCR, 1, 1>; // Bits [1] : Indicates that all sub-chunk writes to a given TCM use a RMW sequence
        using EN = Field <_DTCMCR, 0, 1>; // Bits [0] : Enable TCM. When a TCM is disabled all accesses are made to the AXIM
    };

    // AHBSCR: Controls the priority of AHBS traffic
    struct _AHBSCR : Register <0xE000EFA0, ReadWrite, _AHBSCR> {
        using INITCOUNT = Field <_AHBSCR, 11, 5>; // Bits [15:11] : Use the to demote access priority of the requestor selected by the AHBSCR.CTL
        using TPRI = Field <_AHBSCR, 2, 9>; // Bits [10:2] : Threshold execution priority for AHBS traffic demotion.
        using CTL = Field <_AHBSCR, 0, 2>; // Bits [1:0] : AHBS prioritisation control
    };

    // CACR: Controls L1 ECC and the L1 cache coherency usage model
    struct _CACR : Register <0xE000EF9C, ReadWrite, _CACR> {
        using WT = Field <_CACR, 2, 1>; // Bits [2] : Enables Force WT in the instruction and data cache
        using ECC = Field <_CACR, 1, 1>; // Bits [1] : Enable TCM. Enables ECC in the instruction and data cache
        using SIWT = Field <_CACR, 0, 1>; // Bits [0] : Enables cache coherency usage, globally visible writes
    };

    // AHBPCR: Controls accesses to AHBP or AXIM
    struct _AHBPCR : Register <0xE000EF98, ReadWrite, _AHBPCR> {
        using SZ = Field <_AHBPCR, 1, 3>; // Bits [3:1] : Size of AHBP
        using EN = Field <_AHBPCR, 0, 1>; // Bits [0] : Enables AHBP. When disabled all accesses are made to the AXIM
    };

    // ABFSR: Specifies the source of the asynchronous bus faults
    struct _ABFSR : Register <0xE000EFA8, ReadWrite, _ABFSR> {
        using EPPB = Field <_ABFSR, 4, 1>; // Bits [4] : Asynchronous fault on EPPB interface
        using AXIM = Field <_ABFSR, 3, 1>; // Bits [3] : Asynchronous fault on AXIM interface
        using AHBP = Field <_ABFSR, 2, 1>; // Bits [2] : Asynchronous fault on AHBP interface
        using DTCM = Field <_ABFSR, 1, 1>; // Bits [1] : Asynchronous fault on DTCM interface
        using ITCM = Field <_ABFSR, 0, 1>; // Bits [0] : Asynchronous fault on ITCM interface
    };

} // namespace ImpDef

// Generated from xml file: ./xml-svd/nvic_registers_v7m.xml

// --------------------------------------------
// NVIC: Nested Vectored Interrupt Controller registers
// --------------------------------------------
namespace NVIC {

    // ICTR: Provides information about the interrupt controller
    struct _ICTR : Register <0xE000E004, ReadOnly, _ICTR> {
        using INTLINESNUM = Field <_ICTR, 0, 4>; // Bits [3:0] : The total number of interrupt lines supported n, defined in groups of 32. That is, the total number of interrupt lines is up to (32*(INTLINESNUM+1)). However, the absolute maximum number of interrupts is 496, corresponding to the INTLINESNUM value 0b1111.
    };

    // NVIC_ISER0: Enables, or reads the enable state of a group of interrupts
    struct _NVIC_ISER0 : Register <0xE000E100, ReadWrite, _NVIC_ISER0> {
    };

    // NVIC_ISER1: Enables, or reads the enable state of a group of interrupts
    struct _NVIC_ISER1 : Register <0xE000E104, ReadWrite, _NVIC_ISER1> {
    };

    // NVIC_ISER2: Enables, or reads the enable state of a group of interrupts
    struct _NVIC_ISER2 : Register <0xE000E108, ReadWrite, _NVIC_ISER2> {
    };

    // NVIC_ISER3: Enables, or reads the enable state of a group of interrupts
    struct _NVIC_ISER3 : Register <0xE000E10C, ReadWrite, _NVIC_ISER3> {
    };

    // NVIC_ISER4: Enables, or reads the enable state of a group of interrupts
    struct _NVIC_ISER4 : Register <0xE000E110, ReadWrite, _NVIC_ISER4> {
    };

    // NVIC_ISER5: Enables, or reads the enable state of a group of interrupts
    struct _NVIC_ISER5 : Register <0xE000E114, ReadWrite, _NVIC_ISER5> {
    };

    // NVIC_ISER6: Enables, or reads the enable state of a group of interrupts
    struct _NVIC_ISER6 : Register <0xE000E118, ReadWrite, _NVIC_ISER6> {
    };

    // NVIC_ISER7: Enables, or reads the enable state of a group of interrupts
    struct _NVIC_ISER7 : Register <0xE000E11C, ReadWrite, _NVIC_ISER7> {
    };

    // NVIC_ICER0: Disables, or reads the enable state of a group of interrupts
    struct _NVIC_ICER0 : Register <0xE000E180, ReadWrite, _NVIC_ICER0> {
    };

    // NVIC_ICER1: Disables, or reads the enable state of a group of interrupts
    struct _NVIC_ICER1 : Register <0xE000E184, ReadWrite, _NVIC_ICER1> {
    };

    // NVIC_ICER2: Disables, or reads the enable state of a group of interrupts
    struct _NVIC_ICER2 : Register <0xE000E188, ReadWrite, _NVIC_ICER2> {
    };

    // NVIC_ICER3: Disables, or reads the enable state of a group of interrupts
    struct _NVIC_ICER3 : Register <0xE000E18C, ReadWrite, _NVIC_ICER3> {
    };

    // NVIC_ICER4: Disables, or reads the enable state of a group of interrupts
    struct _NVIC_ICER4 : Register <0xE000E190, ReadWrite, _NVIC_ICER4> {
    };

    // NVIC_ICER5: Disables, or reads the enable state of a group of interrupts
    struct _NVIC_ICER5 : Register <0xE000E194, ReadWrite, _NVIC_ICER5> {
    };

    // NVIC_ICER6: Disables, or reads the enable state of a group of interrupts
    struct _NVIC_ICER6 : Register <0xE000E198, ReadWrite, _NVIC_ICER6> {
    };

    // NVIC_ICER7: Disables, or reads the enable state of a group of interrupts
    struct _NVIC_ICER7 : Register <0xE000E19C, ReadWrite, _NVIC_ICER7> {
    };

    // NVIC_ISPR0: For a group of interrupts, changes interrupt status to pending, or shows the current pending status
    struct _NVIC_ISPR0 : Register <0xE000E200, ReadWrite, _NVIC_ISPR0> {
    };

    // NVIC_ISPR1: For a group of interrupts, changes interrupt status to pending, or shows the current pending status
    struct _NVIC_ISPR1 : Register <0xE000E204, ReadWrite, _NVIC_ISPR1> {
    };

    // NVIC_ISPR2: For a group of interrupts, changes interrupt status to pending, or shows the current pending status
    struct _NVIC_ISPR2 : Register <0xE000E208, ReadWrite, _NVIC_ISPR2> {
    };

    // NVIC_ISPR3: For a group of interrupts, changes interrupt status to pending, or shows the current pending status
    struct _NVIC_ISPR3 : Register <0xE000E20C, ReadWrite, _NVIC_ISPR3> {
    };

    // NVIC_ISPR4: For a group of interrupts, changes interrupt status to pending, or shows the current pending status
    struct _NVIC_ISPR4 : Register <0xE000E210, ReadWrite, _NVIC_ISPR4> {
    };

    // NVIC_ISPR5: For a group of interrupts, changes interrupt status to pending, or shows the current pending status
    struct _NVIC_ISPR5 : Register <0xE000E214, ReadWrite, _NVIC_ISPR5> {
    };

    // NVIC_ISPR6: For a group of interrupts, changes interrupt status to pending, or shows the current pending status
    struct _NVIC_ISPR6 : Register <0xE000E218, ReadWrite, _NVIC_ISPR6> {
    };

    // NVIC_ISPR7: For a group of interrupts, changes interrupt status to pending, or shows the current pending status
    struct _NVIC_ISPR7 : Register <0xE000E21C, ReadWrite, _NVIC_ISPR7> {
    };

    // NVIC_ICPR0: For a group of interrupts, clears the interrupt pending status, or shows the current pending status
    struct _NVIC_ICPR0 : Register <0xE000E280, ReadWrite, _NVIC_ICPR0> {
    };

    // NVIC_ICPR1: For a group of interrupts, clears the interrupt pending status, or shows the current pending status
    struct _NVIC_ICPR1 : Register <0xE000E284, ReadWrite, _NVIC_ICPR1> {
    };

    // NVIC_ICPR2: For a group of interrupts, clears the interrupt pending status, or shows the current pending status
    struct _NVIC_ICPR2 : Register <0xE000E288, ReadWrite, _NVIC_ICPR2> {
    };

    // NVIC_ICPR3: For a group of interrupts, clears the interrupt pending status, or shows the current pending status
    struct _NVIC_ICPR3 : Register <0xE000E28C, ReadWrite, _NVIC_ICPR3> {
    };

    // NVIC_ICPR4: For a group of interrupts, clears the interrupt pending status, or shows the current pending status
    struct _NVIC_ICPR4 : Register <0xE000E290, ReadWrite, _NVIC_ICPR4> {
    };

    // NVIC_ICPR5: For a group of interrupts, clears the interrupt pending status, or shows the current pending status
    struct _NVIC_ICPR5 : Register <0xE000E294, ReadWrite, _NVIC_ICPR5> {
    };

    // NVIC_ICPR6: For a group of interrupts, clears the interrupt pending status, or shows the current pending status
    struct _NVIC_ICPR6 : Register <0xE000E298, ReadWrite, _NVIC_ICPR6> {
    };

    // NVIC_ICPR7: For a group of interrupts, clears the interrupt pending status, or shows the current pending status
    struct _NVIC_ICPR7 : Register <0xE000E29C, ReadWrite, _NVIC_ICPR7> {
    };

    // NVIC_IABR0: For a group of 32 interrupts, shows whether each interrupt is active
    struct _NVIC_IABR0 : Register <0xE000E300, ReadWrite, _NVIC_IABR0> {
    };

    // NVIC_IABR1: For a group of 32 interrupts, shows whether each interrupt is active
    struct _NVIC_IABR1 : Register <0xE000E304, ReadWrite, _NVIC_IABR1> {
    };

    // NVIC_IABR2: For a group of 32 interrupts, shows whether each interrupt is active
    struct _NVIC_IABR2 : Register <0xE000E308, ReadWrite, _NVIC_IABR2> {
    };

    // NVIC_IABR3: For a group of 32 interrupts, shows whether each interrupt is active
    struct _NVIC_IABR3 : Register <0xE000E30C, ReadWrite, _NVIC_IABR3> {
    };

    // NVIC_IABR4: For a group of 32 interrupts, shows whether each interrupt is active
    struct _NVIC_IABR4 : Register <0xE000E310, ReadWrite, _NVIC_IABR4> {
    };

    // NVIC_IABR5: For a group of 32 interrupts, shows whether each interrupt is active
    struct _NVIC_IABR5 : Register <0xE000E314, ReadWrite, _NVIC_IABR5> {
    };

    // NVIC_IABR6: For a group of 32 interrupts, shows whether each interrupt is active
    struct _NVIC_IABR6 : Register <0xE000E318, ReadWrite, _NVIC_IABR6> {
    };

    // NVIC_IABR7: For a group of 32 interrupts, shows whether each interrupt is active
    struct _NVIC_IABR7 : Register <0xE000E31C, ReadWrite, _NVIC_IABR7> {
    };

    // NVIC_IPR0: Sets or reads interrupt priorities
    struct _NVIC_IPR0 : Register <0xE000E400, ReadWrite, _NVIC_IPR0> {
        using PRI_N3 = Field <_NVIC_IPR0, 24, 8>; // Bits [31:24] : Priority of interrupt 3
        using PRI_N2 = Field <_NVIC_IPR0, 16, 8>; // Bits [23:16] : Priority of interrupt 2
        using PRI_N1 = Field <_NVIC_IPR0, 8, 8>; // Bits [15:8] : Priority of interrupt 1
        using PRI_N0 = Field <_NVIC_IPR0, 0, 8>; // Bits [7:0] : Priority of interrupt 0
    };

    // NVIC_IPR1: Sets or reads interrupt priorities
    struct _NVIC_IPR1 : Register <0xE000E404, ReadWrite, _NVIC_IPR1> {
        using PRI_N3 = Field <_NVIC_IPR1, 24, 8>; // Bits [31:24] : Priority of interrupt 7
        using PRI_N2 = Field <_NVIC_IPR1, 16, 8>; // Bits [23:16] : Priority of interrupt 6
        using PRI_N1 = Field <_NVIC_IPR1, 8, 8>; // Bits [15:8] : Priority of interrupt 5
        using PRI_N0 = Field <_NVIC_IPR1, 0, 8>; // Bits [7:0] : Priority of interrupt 4
    };

    // NVIC_IPR2: Sets or reads interrupt priorities
    struct _NVIC_IPR2 : Register <0xE000E408, ReadWrite, _NVIC_IPR2> {
        using PRI_N3 = Field <_NVIC_IPR2, 24, 8>; // Bits [31:24] : Priority of interrupt 11
        using PRI_N2 = Field <_NVIC_IPR2, 16, 8>; // Bits [23:16] : Priority of interrupt 10
        using PRI_N1 = Field <_NVIC_IPR2, 8, 8>; // Bits [15:8] : Priority of interrupt 9
        using PRI_N0 = Field <_NVIC_IPR2, 0, 8>; // Bits [7:0] : Priority of interrupt 8
    };

    // NVIC_IPR3: Sets or reads interrupt priorities
    struct _NVIC_IPR3 : Register <0xE000E40C, ReadWrite, _NVIC_IPR3> {
        using PRI_N3 = Field <_NVIC_IPR3, 24, 8>; // Bits [31:24] : Priority of interrupt 15
        using PRI_N2 = Field <_NVIC_IPR3, 16, 8>; // Bits [23:16] : Priority of interrupt 14
        using PRI_N1 = Field <_NVIC_IPR3, 8, 8>; // Bits [15:8] : Priority of interrupt 13
        using PRI_N0 = Field <_NVIC_IPR3, 0, 8>; // Bits [7:0] : Priority of interrupt 12
    };

    // NVIC_IPR4: Sets or reads interrupt priorities
    struct _NVIC_IPR4 : Register <0xE000E410, ReadWrite, _NVIC_IPR4> {
        using PRI_N3 = Field <_NVIC_IPR4, 24, 8>; // Bits [31:24] : Priority of interrupt 19
        using PRI_N2 = Field <_NVIC_IPR4, 16, 8>; // Bits [23:16] : Priority of interrupt 18
        using PRI_N1 = Field <_NVIC_IPR4, 8, 8>; // Bits [15:8] : Priority of interrupt 17
        using PRI_N0 = Field <_NVIC_IPR4, 0, 8>; // Bits [7:0] : Priority of interrupt 16
    };

    // NVIC_IPR5: Sets or reads interrupt priorities
    struct _NVIC_IPR5 : Register <0xE000E414, ReadWrite, _NVIC_IPR5> {
        using PRI_N3 = Field <_NVIC_IPR5, 24, 8>; // Bits [31:24] : Priority of interrupt 23
        using PRI_N2 = Field <_NVIC_IPR5, 16, 8>; // Bits [23:16] : Priority of interrupt 22
        using PRI_N1 = Field <_NVIC_IPR5, 8, 8>; // Bits [15:8] : Priority of interrupt 21
        using PRI_N0 = Field <_NVIC_IPR5, 0, 8>; // Bits [7:0] : Priority of interrupt 20
    };

    // NVIC_IPR6: Sets or reads interrupt priorities
    struct _NVIC_IPR6 : Register <0xE000E418, ReadWrite, _NVIC_IPR6> {
        using PRI_N3 = Field <_NVIC_IPR6, 24, 8>; // Bits [31:24] : Priority of interrupt 27
        using PRI_N2 = Field <_NVIC_IPR6, 16, 8>; // Bits [23:16] : Priority of interrupt 26
        using PRI_N1 = Field <_NVIC_IPR6, 8, 8>; // Bits [15:8] : Priority of interrupt 25
        using PRI_N0 = Field <_NVIC_IPR6, 0, 8>; // Bits [7:0] : Priority of interrupt 24
    };

    // NVIC_IPR7: Sets or reads interrupt priorities
    struct _NVIC_IPR7 : Register <0xE000E41C, ReadWrite, _NVIC_IPR7> {
        using PRI_N3 = Field <_NVIC_IPR7, 24, 8>; // Bits [31:24] : Priority of interrupt 31
        using PRI_N2 = Field <_NVIC_IPR7, 16, 8>; // Bits [23:16] : Priority of interrupt 30
        using PRI_N1 = Field <_NVIC_IPR7, 8, 8>; // Bits [15:8] : Priority of interrupt 29
        using PRI_N0 = Field <_NVIC_IPR7, 0, 8>; // Bits [7:0] : Priority of interrupt 28
    };

    // NVIC_IPR8: Sets or reads interrupt priorities
    struct _NVIC_IPR8 : Register <0xE000E420, ReadWrite, _NVIC_IPR8> {
        using PRI_N3 = Field <_NVIC_IPR8, 24, 8>; // Bits [31:24] : Priority of interrupt 35
        using PRI_N2 = Field <_NVIC_IPR8, 16, 8>; // Bits [23:16] : Priority of interrupt 34
        using PRI_N1 = Field <_NVIC_IPR8, 8, 8>; // Bits [15:8] : Priority of interrupt 33
        using PRI_N0 = Field <_NVIC_IPR8, 0, 8>; // Bits [7:0] : Priority of interrupt 32
    };

    // NVIC_IPR9: Sets or reads interrupt priorities
    struct _NVIC_IPR9 : Register <0xE000E424, ReadWrite, _NVIC_IPR9> {
        using PRI_N3 = Field <_NVIC_IPR9, 24, 8>; // Bits [31:24] : Priority of interrupt 39
        using PRI_N2 = Field <_NVIC_IPR9, 16, 8>; // Bits [23:16] : Priority of interrupt 38
        using PRI_N1 = Field <_NVIC_IPR9, 8, 8>; // Bits [15:8] : Priority of interrupt 37
        using PRI_N0 = Field <_NVIC_IPR9, 0, 8>; // Bits [7:0] : Priority of interrupt 36
    };

    // NVIC_IPR10: Sets or reads interrupt priorities
    struct _NVIC_IPR10 : Register <0xE000E428, ReadWrite, _NVIC_IPR10> {
        using PRI_N3 = Field <_NVIC_IPR10, 24, 8>; // Bits [31:24] : Priority of interrupt 43
        using PRI_N2 = Field <_NVIC_IPR10, 16, 8>; // Bits [23:16] : Priority of interrupt 42
        using PRI_N1 = Field <_NVIC_IPR10, 8, 8>; // Bits [15:8] : Priority of interrupt 41
        using PRI_N0 = Field <_NVIC_IPR10, 0, 8>; // Bits [7:0] : Priority of interrupt 40
    };

    // NVIC_IPR11: Sets or reads interrupt priorities
    struct _NVIC_IPR11 : Register <0xE000E42C, ReadWrite, _NVIC_IPR11> {
        using PRI_N3 = Field <_NVIC_IPR11, 24, 8>; // Bits [31:24] : Priority of interrupt 47
        using PRI_N2 = Field <_NVIC_IPR11, 16, 8>; // Bits [23:16] : Priority of interrupt 46
        using PRI_N1 = Field <_NVIC_IPR11, 8, 8>; // Bits [15:8] : Priority of interrupt 45
        using PRI_N0 = Field <_NVIC_IPR11, 0, 8>; // Bits [7:0] : Priority of interrupt 44
    };

    // NVIC_IPR12: Sets or reads interrupt priorities
    struct _NVIC_IPR12 : Register <0xE000E430, ReadWrite, _NVIC_IPR12> {
        using PRI_N3 = Field <_NVIC_IPR12, 24, 8>; // Bits [31:24] : Priority of interrupt 51
        using PRI_N2 = Field <_NVIC_IPR12, 16, 8>; // Bits [23:16] : Priority of interrupt 50
        using PRI_N1 = Field <_NVIC_IPR12, 8, 8>; // Bits [15:8] : Priority of interrupt 49
        using PRI_N0 = Field <_NVIC_IPR12, 0, 8>; // Bits [7:0] : Priority of interrupt 48
    };

    // NVIC_IPR13: Sets or reads interrupt priorities
    struct _NVIC_IPR13 : Register <0xE000E434, ReadWrite, _NVIC_IPR13> {
        using PRI_N3 = Field <_NVIC_IPR13, 24, 8>; // Bits [31:24] : Priority of interrupt 55
        using PRI_N2 = Field <_NVIC_IPR13, 16, 8>; // Bits [23:16] : Priority of interrupt 54
        using PRI_N1 = Field <_NVIC_IPR13, 8, 8>; // Bits [15:8] : Priority of interrupt 53
        using PRI_N0 = Field <_NVIC_IPR13, 0, 8>; // Bits [7:0] : Priority of interrupt 52
    };

    // NVIC_IPR14: Sets or reads interrupt priorities
    struct _NVIC_IPR14 : Register <0xE000E438, ReadWrite, _NVIC_IPR14> {
        using PRI_N3 = Field <_NVIC_IPR14, 24, 8>; // Bits [31:24] : Priority of interrupt 59
        using PRI_N2 = Field <_NVIC_IPR14, 16, 8>; // Bits [23:16] : Priority of interrupt 58
        using PRI_N1 = Field <_NVIC_IPR14, 8, 8>; // Bits [15:8] : Priority of interrupt 57
        using PRI_N0 = Field <_NVIC_IPR14, 0, 8>; // Bits [7:0] : Priority of interrupt 56
    };

    // NVIC_IPR15: Sets or reads interrupt priorities
    struct _NVIC_IPR15 : Register <0xE000E43C, ReadWrite, _NVIC_IPR15> {
        using PRI_N3 = Field <_NVIC_IPR15, 24, 8>; // Bits [31:24] : Priority of interrupt 63
        using PRI_N2 = Field <_NVIC_IPR15, 16, 8>; // Bits [23:16] : Priority of interrupt 62
        using PRI_N1 = Field <_NVIC_IPR15, 8, 8>; // Bits [15:8] : Priority of interrupt 61
        using PRI_N0 = Field <_NVIC_IPR15, 0, 8>; // Bits [7:0] : Priority of interrupt 60
    };

    // NVIC_IPR16: Sets or reads interrupt priorities
    struct _NVIC_IPR16 : Register <0xE000E440, ReadWrite, _NVIC_IPR16> {
        using PRI_N3 = Field <_NVIC_IPR16, 24, 8>; // Bits [31:24] : Priority of interrupt 67
        using PRI_N2 = Field <_NVIC_IPR16, 16, 8>; // Bits [23:16] : Priority of interrupt 66
        using PRI_N1 = Field <_NVIC_IPR16, 8, 8>; // Bits [15:8] : Priority of interrupt 65
        using PRI_N0 = Field <_NVIC_IPR16, 0, 8>; // Bits [7:0] : Priority of interrupt 64
    };

    // NVIC_IPR17: Sets or reads interrupt priorities
    struct _NVIC_IPR17 : Register <0xE000E444, ReadWrite, _NVIC_IPR17> {
        using PRI_N3 = Field <_NVIC_IPR17, 24, 8>; // Bits [31:24] : Priority of interrupt 71
        using PRI_N2 = Field <_NVIC_IPR17, 16, 8>; // Bits [23:16] : Priority of interrupt 70
        using PRI_N1 = Field <_NVIC_IPR17, 8, 8>; // Bits [15:8] : Priority of interrupt 69
        using PRI_N0 = Field <_NVIC_IPR17, 0, 8>; // Bits [7:0] : Priority of interrupt 68
    };

    // NVIC_IPR18: Sets or reads interrupt priorities
    struct _NVIC_IPR18 : Register <0xE000E448, ReadWrite, _NVIC_IPR18> {
        using PRI_N3 = Field <_NVIC_IPR18, 24, 8>; // Bits [31:24] : Priority of interrupt 75
        using PRI_N2 = Field <_NVIC_IPR18, 16, 8>; // Bits [23:16] : Priority of interrupt 74
        using PRI_N1 = Field <_NVIC_IPR18, 8, 8>; // Bits [15:8] : Priority of interrupt 73
        using PRI_N0 = Field <_NVIC_IPR18, 0, 8>; // Bits [7:0] : Priority of interrupt 72
    };

    // NVIC_IPR19: Sets or reads interrupt priorities
    struct _NVIC_IPR19 : Register <0xE000E44C, ReadWrite, _NVIC_IPR19> {
        using PRI_N3 = Field <_NVIC_IPR19, 24, 8>; // Bits [31:24] : Priority of interrupt 79
        using PRI_N2 = Field <_NVIC_IPR19, 16, 8>; // Bits [23:16] : Priority of interrupt 78
        using PRI_N1 = Field <_NVIC_IPR19, 8, 8>; // Bits [15:8] : Priority of interrupt 77
        using PRI_N0 = Field <_NVIC_IPR19, 0, 8>; // Bits [7:0] : Priority of interrupt 76
    };

    // NVIC_IPR20: Sets or reads interrupt priorities
    struct _NVIC_IPR20 : Register <0xE000E450, ReadWrite, _NVIC_IPR20> {
        using PRI_N3 = Field <_NVIC_IPR20, 24, 8>; // Bits [31:24] : Priority of interrupt 83
        using PRI_N2 = Field <_NVIC_IPR20, 16, 8>; // Bits [23:16] : Priority of interrupt 82
        using PRI_N1 = Field <_NVIC_IPR20, 8, 8>; // Bits [15:8] : Priority of interrupt 81
        using PRI_N0 = Field <_NVIC_IPR20, 0, 8>; // Bits [7:0] : Priority of interrupt 80
    };

    // NVIC_IPR21: Sets or reads interrupt priorities
    struct _NVIC_IPR21 : Register <0xE000E454, ReadWrite, _NVIC_IPR21> {
        using PRI_N3 = Field <_NVIC_IPR21, 24, 8>; // Bits [31:24] : Priority of interrupt 87
        using PRI_N2 = Field <_NVIC_IPR21, 16, 8>; // Bits [23:16] : Priority of interrupt 86
        using PRI_N1 = Field <_NVIC_IPR21, 8, 8>; // Bits [15:8] : Priority of interrupt 85
        using PRI_N0 = Field <_NVIC_IPR21, 0, 8>; // Bits [7:0] : Priority of interrupt 84
    };

    // NVIC_IPR22: Sets or reads interrupt priorities
    struct _NVIC_IPR22 : Register <0xE000E458, ReadWrite, _NVIC_IPR22> {
        using PRI_N3 = Field <_NVIC_IPR22, 24, 8>; // Bits [31:24] : Priority of interrupt 91
        using PRI_N2 = Field <_NVIC_IPR22, 16, 8>; // Bits [23:16] : Priority of interrupt 90
        using PRI_N1 = Field <_NVIC_IPR22, 8, 8>; // Bits [15:8] : Priority of interrupt 89
        using PRI_N0 = Field <_NVIC_IPR22, 0, 8>; // Bits [7:0] : Priority of interrupt 88
    };

    // NVIC_IPR23: Sets or reads interrupt priorities
    struct _NVIC_IPR23 : Register <0xE000E45C, ReadWrite, _NVIC_IPR23> {
        using PRI_N3 = Field <_NVIC_IPR23, 24, 8>; // Bits [31:24] : Priority of interrupt 95
        using PRI_N2 = Field <_NVIC_IPR23, 16, 8>; // Bits [23:16] : Priority of interrupt 94
        using PRI_N1 = Field <_NVIC_IPR23, 8, 8>; // Bits [15:8] : Priority of interrupt 93
        using PRI_N0 = Field <_NVIC_IPR23, 0, 8>; // Bits [7:0] : Priority of interrupt 92
    };

    // NVIC_IPR24: Sets or reads interrupt priorities
    struct _NVIC_IPR24 : Register <0xE000E460, ReadWrite, _NVIC_IPR24> {
        using PRI_N3 = Field <_NVIC_IPR24, 24, 8>; // Bits [31:24] : Priority of interrupt 99
        using PRI_N2 = Field <_NVIC_IPR24, 16, 8>; // Bits [23:16] : Priority of interrupt 98
        using PRI_N1 = Field <_NVIC_IPR24, 8, 8>; // Bits [15:8] : Priority of interrupt 97
        using PRI_N0 = Field <_NVIC_IPR24, 0, 8>; // Bits [7:0] : Priority of interrupt 96
    };

    // NVIC_IPR25: Sets or reads interrupt priorities
    struct _NVIC_IPR25 : Register <0xE000E464, ReadWrite, _NVIC_IPR25> {
        using PRI_N3 = Field <_NVIC_IPR25, 24, 8>; // Bits [31:24] : Priority of interrupt 103
        using PRI_N2 = Field <_NVIC_IPR25, 16, 8>; // Bits [23:16] : Priority of interrupt 102
        using PRI_N1 = Field <_NVIC_IPR25, 8, 8>; // Bits [15:8] : Priority of interrupt 101
        using PRI_N0 = Field <_NVIC_IPR25, 0, 8>; // Bits [7:0] : Priority of interrupt 100
    };

    // NVIC_IPR26: Sets or reads interrupt priorities
    struct _NVIC_IPR26 : Register <0xE000E468, ReadWrite, _NVIC_IPR26> {
        using PRI_N3 = Field <_NVIC_IPR26, 24, 8>; // Bits [31:24] : Priority of interrupt 107
        using PRI_N2 = Field <_NVIC_IPR26, 16, 8>; // Bits [23:16] : Priority of interrupt 106
        using PRI_N1 = Field <_NVIC_IPR26, 8, 8>; // Bits [15:8] : Priority of interrupt 105
        using PRI_N0 = Field <_NVIC_IPR26, 0, 8>; // Bits [7:0] : Priority of interrupt 104
    };

    // NVIC_IPR27: Sets or reads interrupt priorities
    struct _NVIC_IPR27 : Register <0xE000E46C, ReadWrite, _NVIC_IPR27> {
        using PRI_N3 = Field <_NVIC_IPR27, 24, 8>; // Bits [31:24] : Priority of interrupt 111
        using PRI_N2 = Field <_NVIC_IPR27, 16, 8>; // Bits [23:16] : Priority of interrupt 110
        using PRI_N1 = Field <_NVIC_IPR27, 8, 8>; // Bits [15:8] : Priority of interrupt 109
        using PRI_N0 = Field <_NVIC_IPR27, 0, 8>; // Bits [7:0] : Priority of interrupt 108
    };

    // NVIC_IPR28: Sets or reads interrupt priorities
    struct _NVIC_IPR28 : Register <0xE000E470, ReadWrite, _NVIC_IPR28> {
        using PRI_N3 = Field <_NVIC_IPR28, 24, 8>; // Bits [31:24] : Priority of interrupt 115
        using PRI_N2 = Field <_NVIC_IPR28, 16, 8>; // Bits [23:16] : Priority of interrupt 114
        using PRI_N1 = Field <_NVIC_IPR28, 8, 8>; // Bits [15:8] : Priority of interrupt 113
        using PRI_N0 = Field <_NVIC_IPR28, 0, 8>; // Bits [7:0] : Priority of interrupt 112
    };

    // NVIC_IPR29: Sets or reads interrupt priorities
    struct _NVIC_IPR29 : Register <0xE000E474, ReadWrite, _NVIC_IPR29> {
        using PRI_N3 = Field <_NVIC_IPR29, 24, 8>; // Bits [31:24] : Priority of interrupt 119
        using PRI_N2 = Field <_NVIC_IPR29, 16, 8>; // Bits [23:16] : Priority of interrupt 118
        using PRI_N1 = Field <_NVIC_IPR29, 8, 8>; // Bits [15:8] : Priority of interrupt 117
        using PRI_N0 = Field <_NVIC_IPR29, 0, 8>; // Bits [7:0] : Priority of interrupt 116
    };

    // NVIC_IPR30: Sets or reads interrupt priorities
    struct _NVIC_IPR30 : Register <0xE000E478, ReadWrite, _NVIC_IPR30> {
        using PRI_N3 = Field <_NVIC_IPR30, 24, 8>; // Bits [31:24] : Priority of interrupt 123
        using PRI_N2 = Field <_NVIC_IPR30, 16, 8>; // Bits [23:16] : Priority of interrupt 122
        using PRI_N1 = Field <_NVIC_IPR30, 8, 8>; // Bits [15:8] : Priority of interrupt 121
        using PRI_N0 = Field <_NVIC_IPR30, 0, 8>; // Bits [7:0] : Priority of interrupt 120
    };

    // NVIC_IPR31: Sets or reads interrupt priorities
    struct _NVIC_IPR31 : Register <0xE000E47C, ReadWrite, _NVIC_IPR31> {
        using PRI_N3 = Field <_NVIC_IPR31, 24, 8>; // Bits [31:24] : Priority of interrupt 127
        using PRI_N2 = Field <_NVIC_IPR31, 16, 8>; // Bits [23:16] : Priority of interrupt 126
        using PRI_N1 = Field <_NVIC_IPR31, 8, 8>; // Bits [15:8] : Priority of interrupt 125
        using PRI_N0 = Field <_NVIC_IPR31, 0, 8>; // Bits [7:0] : Priority of interrupt 124
    };

    // NVIC_IPR32: Sets or reads interrupt priorities
    struct _NVIC_IPR32 : Register <0xE000E480, ReadWrite, _NVIC_IPR32> {
        using PRI_N3 = Field <_NVIC_IPR32, 24, 8>; // Bits [31:24] : Priority of interrupt 131
        using PRI_N2 = Field <_NVIC_IPR32, 16, 8>; // Bits [23:16] : Priority of interrupt 130
        using PRI_N1 = Field <_NVIC_IPR32, 8, 8>; // Bits [15:8] : Priority of interrupt 129
        using PRI_N0 = Field <_NVIC_IPR32, 0, 8>; // Bits [7:0] : Priority of interrupt 128
    };

    // NVIC_IPR33: Sets or reads interrupt priorities
    struct _NVIC_IPR33 : Register <0xE000E484, ReadWrite, _NVIC_IPR33> {
        using PRI_N3 = Field <_NVIC_IPR33, 24, 8>; // Bits [31:24] : Priority of interrupt 135
        using PRI_N2 = Field <_NVIC_IPR33, 16, 8>; // Bits [23:16] : Priority of interrupt 134
        using PRI_N1 = Field <_NVIC_IPR33, 8, 8>; // Bits [15:8] : Priority of interrupt 133
        using PRI_N0 = Field <_NVIC_IPR33, 0, 8>; // Bits [7:0] : Priority of interrupt 132
    };

    // NVIC_IPR34: Sets or reads interrupt priorities
    struct _NVIC_IPR34 : Register <0xE000E488, ReadWrite, _NVIC_IPR34> {
        using PRI_N3 = Field <_NVIC_IPR34, 24, 8>; // Bits [31:24] : Priority of interrupt 139
        using PRI_N2 = Field <_NVIC_IPR34, 16, 8>; // Bits [23:16] : Priority of interrupt 138
        using PRI_N1 = Field <_NVIC_IPR34, 8, 8>; // Bits [15:8] : Priority of interrupt 137
        using PRI_N0 = Field <_NVIC_IPR34, 0, 8>; // Bits [7:0] : Priority of interrupt 136
    };

    // NVIC_IPR35: Sets or reads interrupt priorities
    struct _NVIC_IPR35 : Register <0xE000E48C, ReadWrite, _NVIC_IPR35> {
        using PRI_N3 = Field <_NVIC_IPR35, 24, 8>; // Bits [31:24] : Priority of interrupt 143
        using PRI_N2 = Field <_NVIC_IPR35, 16, 8>; // Bits [23:16] : Priority of interrupt 142
        using PRI_N1 = Field <_NVIC_IPR35, 8, 8>; // Bits [15:8] : Priority of interrupt 141
        using PRI_N0 = Field <_NVIC_IPR35, 0, 8>; // Bits [7:0] : Priority of interrupt 140
    };

    // NVIC_IPR36: Sets or reads interrupt priorities
    struct _NVIC_IPR36 : Register <0xE000E490, ReadWrite, _NVIC_IPR36> {
        using PRI_N3 = Field <_NVIC_IPR36, 24, 8>; // Bits [31:24] : Priority of interrupt 147
        using PRI_N2 = Field <_NVIC_IPR36, 16, 8>; // Bits [23:16] : Priority of interrupt 146
        using PRI_N1 = Field <_NVIC_IPR36, 8, 8>; // Bits [15:8] : Priority of interrupt 145
        using PRI_N0 = Field <_NVIC_IPR36, 0, 8>; // Bits [7:0] : Priority of interrupt 144
    };

    // NVIC_IPR37: Sets or reads interrupt priorities
    struct _NVIC_IPR37 : Register <0xE000E494, ReadWrite, _NVIC_IPR37> {
        using PRI_N3 = Field <_NVIC_IPR37, 24, 8>; // Bits [31:24] : Priority of interrupt 151
        using PRI_N2 = Field <_NVIC_IPR37, 16, 8>; // Bits [23:16] : Priority of interrupt 150
        using PRI_N1 = Field <_NVIC_IPR37, 8, 8>; // Bits [15:8] : Priority of interrupt 149
        using PRI_N0 = Field <_NVIC_IPR37, 0, 8>; // Bits [7:0] : Priority of interrupt 148
    };

    // NVIC_IPR38: Sets or reads interrupt priorities
    struct _NVIC_IPR38 : Register <0xE000E498, ReadWrite, _NVIC_IPR38> {
        using PRI_N3 = Field <_NVIC_IPR38, 24, 8>; // Bits [31:24] : Priority of interrupt 155
        using PRI_N2 = Field <_NVIC_IPR38, 16, 8>; // Bits [23:16] : Priority of interrupt 154
        using PRI_N1 = Field <_NVIC_IPR38, 8, 8>; // Bits [15:8] : Priority of interrupt 153
        using PRI_N0 = Field <_NVIC_IPR38, 0, 8>; // Bits [7:0] : Priority of interrupt 152
    };

    // NVIC_IPR39: Sets or reads interrupt priorities
    struct _NVIC_IPR39 : Register <0xE000E49C, ReadWrite, _NVIC_IPR39> {
        using PRI_N3 = Field <_NVIC_IPR39, 24, 8>; // Bits [31:24] : Priority of interrupt 159
        using PRI_N2 = Field <_NVIC_IPR39, 16, 8>; // Bits [23:16] : Priority of interrupt 158
        using PRI_N1 = Field <_NVIC_IPR39, 8, 8>; // Bits [15:8] : Priority of interrupt 157
        using PRI_N0 = Field <_NVIC_IPR39, 0, 8>; // Bits [7:0] : Priority of interrupt 156
    };

    // NVIC_IPR40: Sets or reads interrupt priorities
    struct _NVIC_IPR40 : Register <0xE000E4A0, ReadWrite, _NVIC_IPR40> {
        using PRI_N3 = Field <_NVIC_IPR40, 24, 8>; // Bits [31:24] : Priority of interrupt 163
        using PRI_N2 = Field <_NVIC_IPR40, 16, 8>; // Bits [23:16] : Priority of interrupt 162
        using PRI_N1 = Field <_NVIC_IPR40, 8, 8>; // Bits [15:8] : Priority of interrupt 161
        using PRI_N0 = Field <_NVIC_IPR40, 0, 8>; // Bits [7:0] : Priority of interrupt 160
    };

    // NVIC_IPR41: Sets or reads interrupt priorities
    struct _NVIC_IPR41 : Register <0xE000E4A4, ReadWrite, _NVIC_IPR41> {
        using PRI_N3 = Field <_NVIC_IPR41, 24, 8>; // Bits [31:24] : Priority of interrupt 167
        using PRI_N2 = Field <_NVIC_IPR41, 16, 8>; // Bits [23:16] : Priority of interrupt 166
        using PRI_N1 = Field <_NVIC_IPR41, 8, 8>; // Bits [15:8] : Priority of interrupt 165
        using PRI_N0 = Field <_NVIC_IPR41, 0, 8>; // Bits [7:0] : Priority of interrupt 164
    };

    // NVIC_IPR42: Sets or reads interrupt priorities
    struct _NVIC_IPR42 : Register <0xE000E4A8, ReadWrite, _NVIC_IPR42> {
        using PRI_N3 = Field <_NVIC_IPR42, 24, 8>; // Bits [31:24] : Priority of interrupt 171
        using PRI_N2 = Field <_NVIC_IPR42, 16, 8>; // Bits [23:16] : Priority of interrupt 170
        using PRI_N1 = Field <_NVIC_IPR42, 8, 8>; // Bits [15:8] : Priority of interrupt 169
        using PRI_N0 = Field <_NVIC_IPR42, 0, 8>; // Bits [7:0] : Priority of interrupt 168
    };

    // NVIC_IPR43: Sets or reads interrupt priorities
    struct _NVIC_IPR43 : Register <0xE000E4AC, ReadWrite, _NVIC_IPR43> {
        using PRI_N3 = Field <_NVIC_IPR43, 24, 8>; // Bits [31:24] : Priority of interrupt 175
        using PRI_N2 = Field <_NVIC_IPR43, 16, 8>; // Bits [23:16] : Priority of interrupt 174
        using PRI_N1 = Field <_NVIC_IPR43, 8, 8>; // Bits [15:8] : Priority of interrupt 173
        using PRI_N0 = Field <_NVIC_IPR43, 0, 8>; // Bits [7:0] : Priority of interrupt 172
    };

    // NVIC_IPR44: Sets or reads interrupt priorities
    struct _NVIC_IPR44 : Register <0xE000E4B0, ReadWrite, _NVIC_IPR44> {
        using PRI_N3 = Field <_NVIC_IPR44, 24, 8>; // Bits [31:24] : Priority of interrupt 179
        using PRI_N2 = Field <_NVIC_IPR44, 16, 8>; // Bits [23:16] : Priority of interrupt 178
        using PRI_N1 = Field <_NVIC_IPR44, 8, 8>; // Bits [15:8] : Priority of interrupt 177
        using PRI_N0 = Field <_NVIC_IPR44, 0, 8>; // Bits [7:0] : Priority of interrupt 176
    };

    // NVIC_IPR45: Sets or reads interrupt priorities
    struct _NVIC_IPR45 : Register <0xE000E4B4, ReadWrite, _NVIC_IPR45> {
        using PRI_N3 = Field <_NVIC_IPR45, 24, 8>; // Bits [31:24] : Priority of interrupt 183
        using PRI_N2 = Field <_NVIC_IPR45, 16, 8>; // Bits [23:16] : Priority of interrupt 182
        using PRI_N1 = Field <_NVIC_IPR45, 8, 8>; // Bits [15:8] : Priority of interrupt 181
        using PRI_N0 = Field <_NVIC_IPR45, 0, 8>; // Bits [7:0] : Priority of interrupt 180
    };

    // NVIC_IPR46: Sets or reads interrupt priorities
    struct _NVIC_IPR46 : Register <0xE000E4B8, ReadWrite, _NVIC_IPR46> {
        using PRI_N3 = Field <_NVIC_IPR46, 24, 8>; // Bits [31:24] : Priority of interrupt 187
        using PRI_N2 = Field <_NVIC_IPR46, 16, 8>; // Bits [23:16] : Priority of interrupt 186
        using PRI_N1 = Field <_NVIC_IPR46, 8, 8>; // Bits [15:8] : Priority of interrupt 185
        using PRI_N0 = Field <_NVIC_IPR46, 0, 8>; // Bits [7:0] : Priority of interrupt 184
    };

    // NVIC_IPR47: Sets or reads interrupt priorities
    struct _NVIC_IPR47 : Register <0xE000E4BC, ReadWrite, _NVIC_IPR47> {
        using PRI_N3 = Field <_NVIC_IPR47, 24, 8>; // Bits [31:24] : Priority of interrupt 191
        using PRI_N2 = Field <_NVIC_IPR47, 16, 8>; // Bits [23:16] : Priority of interrupt 190
        using PRI_N1 = Field <_NVIC_IPR47, 8, 8>; // Bits [15:8] : Priority of interrupt 189
        using PRI_N0 = Field <_NVIC_IPR47, 0, 8>; // Bits [7:0] : Priority of interrupt 188
    };

    // NVIC_IPR48: Sets or reads interrupt priorities
    struct _NVIC_IPR48 : Register <0xE000E4C0, ReadWrite, _NVIC_IPR48> {
        using PRI_N3 = Field <_NVIC_IPR48, 24, 8>; // Bits [31:24] : Priority of interrupt 195
        using PRI_N2 = Field <_NVIC_IPR48, 16, 8>; // Bits [23:16] : Priority of interrupt 194
        using PRI_N1 = Field <_NVIC_IPR48, 8, 8>; // Bits [15:8] : Priority of interrupt 193
        using PRI_N0 = Field <_NVIC_IPR48, 0, 8>; // Bits [7:0] : Priority of interrupt 192
    };

    // NVIC_IPR49: Sets or reads interrupt priorities
    struct _NVIC_IPR49 : Register <0xE000E4C4, ReadWrite, _NVIC_IPR49> {
        using PRI_N3 = Field <_NVIC_IPR49, 24, 8>; // Bits [31:24] : Priority of interrupt 199
        using PRI_N2 = Field <_NVIC_IPR49, 16, 8>; // Bits [23:16] : Priority of interrupt 198
        using PRI_N1 = Field <_NVIC_IPR49, 8, 8>; // Bits [15:8] : Priority of interrupt 197
        using PRI_N0 = Field <_NVIC_IPR49, 0, 8>; // Bits [7:0] : Priority of interrupt 196
    };

    // NVIC_IPR50: Sets or reads interrupt priorities
    struct _NVIC_IPR50 : Register <0xE000E4C8, ReadWrite, _NVIC_IPR50> {
        using PRI_N3 = Field <_NVIC_IPR50, 24, 8>; // Bits [31:24] : Priority of interrupt 203
        using PRI_N2 = Field <_NVIC_IPR50, 16, 8>; // Bits [23:16] : Priority of interrupt 202
        using PRI_N1 = Field <_NVIC_IPR50, 8, 8>; // Bits [15:8] : Priority of interrupt 201
        using PRI_N0 = Field <_NVIC_IPR50, 0, 8>; // Bits [7:0] : Priority of interrupt 200
    };

    // NVIC_IPR51: Sets or reads interrupt priorities
    struct _NVIC_IPR51 : Register <0xE000E4CC, ReadWrite, _NVIC_IPR51> {
        using PRI_N3 = Field <_NVIC_IPR51, 24, 8>; // Bits [31:24] : Priority of interrupt 207
        using PRI_N2 = Field <_NVIC_IPR51, 16, 8>; // Bits [23:16] : Priority of interrupt 206
        using PRI_N1 = Field <_NVIC_IPR51, 8, 8>; // Bits [15:8] : Priority of interrupt 205
        using PRI_N0 = Field <_NVIC_IPR51, 0, 8>; // Bits [7:0] : Priority of interrupt 204
    };

    // NVIC_IPR52: Sets or reads interrupt priorities
    struct _NVIC_IPR52 : Register <0xE000E4D0, ReadWrite, _NVIC_IPR52> {
        using PRI_N3 = Field <_NVIC_IPR52, 24, 8>; // Bits [31:24] : Priority of interrupt 211
        using PRI_N2 = Field <_NVIC_IPR52, 16, 8>; // Bits [23:16] : Priority of interrupt 210
        using PRI_N1 = Field <_NVIC_IPR52, 8, 8>; // Bits [15:8] : Priority of interrupt 209
        using PRI_N0 = Field <_NVIC_IPR52, 0, 8>; // Bits [7:0] : Priority of interrupt 208
    };

    // NVIC_IPR53: Sets or reads interrupt priorities
    struct _NVIC_IPR53 : Register <0xE000E4D4, ReadWrite, _NVIC_IPR53> {
        using PRI_N3 = Field <_NVIC_IPR53, 24, 8>; // Bits [31:24] : Priority of interrupt 215
        using PRI_N2 = Field <_NVIC_IPR53, 16, 8>; // Bits [23:16] : Priority of interrupt 214
        using PRI_N1 = Field <_NVIC_IPR53, 8, 8>; // Bits [15:8] : Priority of interrupt 213
        using PRI_N0 = Field <_NVIC_IPR53, 0, 8>; // Bits [7:0] : Priority of interrupt 212
    };

    // NVIC_IPR54: Sets or reads interrupt priorities
    struct _NVIC_IPR54 : Register <0xE000E4D8, ReadWrite, _NVIC_IPR54> {
        using PRI_N3 = Field <_NVIC_IPR54, 24, 8>; // Bits [31:24] : Priority of interrupt 219
        using PRI_N2 = Field <_NVIC_IPR54, 16, 8>; // Bits [23:16] : Priority of interrupt 218
        using PRI_N1 = Field <_NVIC_IPR54, 8, 8>; // Bits [15:8] : Priority of interrupt 217
        using PRI_N0 = Field <_NVIC_IPR54, 0, 8>; // Bits [7:0] : Priority of interrupt 216
    };

    // NVIC_IPR55: Sets or reads interrupt priorities
    struct _NVIC_IPR55 : Register <0xE000E4DC, ReadWrite, _NVIC_IPR55> {
        using PRI_N3 = Field <_NVIC_IPR55, 24, 8>; // Bits [31:24] : Priority of interrupt 223
        using PRI_N2 = Field <_NVIC_IPR55, 16, 8>; // Bits [23:16] : Priority of interrupt 222
        using PRI_N1 = Field <_NVIC_IPR55, 8, 8>; // Bits [15:8] : Priority of interrupt 221
        using PRI_N0 = Field <_NVIC_IPR55, 0, 8>; // Bits [7:0] : Priority of interrupt 220
    };

    // NVIC_IPR56: Sets or reads interrupt priorities
    struct _NVIC_IPR56 : Register <0xE000E4E0, ReadWrite, _NVIC_IPR56> {
        using PRI_N3 = Field <_NVIC_IPR56, 24, 8>; // Bits [31:24] : Priority of interrupt 227
        using PRI_N2 = Field <_NVIC_IPR56, 16, 8>; // Bits [23:16] : Priority of interrupt 226
        using PRI_N1 = Field <_NVIC_IPR56, 8, 8>; // Bits [15:8] : Priority of interrupt 225
        using PRI_N0 = Field <_NVIC_IPR56, 0, 8>; // Bits [7:0] : Priority of interrupt 224
    };

    // NVIC_IPR57: Sets or reads interrupt priorities
    struct _NVIC_IPR57 : Register <0xE000E4E4, ReadWrite, _NVIC_IPR57> {
        using PRI_N3 = Field <_NVIC_IPR57, 24, 8>; // Bits [31:24] : Priority of interrupt 231
        using PRI_N2 = Field <_NVIC_IPR57, 16, 8>; // Bits [23:16] : Priority of interrupt 230
        using PRI_N1 = Field <_NVIC_IPR57, 8, 8>; // Bits [15:8] : Priority of interrupt 229
        using PRI_N0 = Field <_NVIC_IPR57, 0, 8>; // Bits [7:0] : Priority of interrupt 228
    };

    // NVIC_IPR58: Sets or reads interrupt priorities
    struct _NVIC_IPR58 : Register <0xE000E4E8, ReadWrite, _NVIC_IPR58> {
        using PRI_N3 = Field <_NVIC_IPR58, 24, 8>; // Bits [31:24] : Priority of interrupt 235
        using PRI_N2 = Field <_NVIC_IPR58, 16, 8>; // Bits [23:16] : Priority of interrupt 234
        using PRI_N1 = Field <_NVIC_IPR58, 8, 8>; // Bits [15:8] : Priority of interrupt 233
        using PRI_N0 = Field <_NVIC_IPR58, 0, 8>; // Bits [7:0] : Priority of interrupt 232
    };

    // NVIC_IPR59: Sets or reads interrupt priorities
    struct _NVIC_IPR59 : Register <0xE000E4EC, ReadWrite, _NVIC_IPR59> {
        using PRI_N3 = Field <_NVIC_IPR59, 24, 8>; // Bits [31:24] : Priority of interrupt 239
        using PRI_N2 = Field <_NVIC_IPR59, 16, 8>; // Bits [23:16] : Priority of interrupt 238
        using PRI_N1 = Field <_NVIC_IPR59, 8, 8>; // Bits [15:8] : Priority of interrupt 237
        using PRI_N0 = Field <_NVIC_IPR59, 0, 8>; // Bits [7:0] : Priority of interrupt 236
    };

} // namespace NVIC

// Generated from xml file: ./xml-svd/cache_registers_v7em.xml

// --------------------------------------------
// Cache: Cache Control
// --------------------------------------------
namespace Cache {

    // CLIDR: Cache Level ID Register
    struct _CLIDR : Register <0xE000ED78, ReadOnly, _CLIDR> {
        using LoUU = Field <_CLIDR, 27, 3>; // Bits [29:27] : Indicates the Level of Unification Uniprocessor for the cache hierarchy
        using LoC = Field <_CLIDR, 24, 3>; // Bits [26:24] : Level of Coherency
        using LoUIS = Field <_CLIDR, 21, 3>; // Bits [23:21] : Indicates the Level of Unification Inner Shareable for the cache hierarchy
        using CL7 = Field <_CLIDR, 18, 3>; // Bits [20:18] : Cache Type 7
        using CL6 = Field <_CLIDR, 15, 3>; // Bits [17:15] : Cache Type 6
        using CL5 = Field <_CLIDR, 12, 3>; // Bits [14:12] : Cache Type 5
        using CL4 = Field <_CLIDR, 9, 3>; // Bits [11:9] : Cache Type 4
        using CL3 = Field <_CLIDR, 6, 3>; // Bits [8:6] : Cache Type 3
        using CL2 = Field <_CLIDR, 3, 3>; // Bits [5:3] : Cache Type 2
        using CL1 = Field <_CLIDR, 0, 3>; // Bits [2:0] : Cache Type 1
    };

    // CTR: Cache Type Register
    struct _CTR : Register <0xE000ED7C, ReadOnly, _CTR> {
        using F = Field <_CTR, 29, 3>; // Bits [31:29] : ARMv7 register format
        using CWG = Field <_CTR, 24, 4>; // Bits [27:24] : Cache Writeback Granule
        using ERG = Field <_CTR, 20, 4>; // Bits [23:20] : Exclusives Reservation Granule
        using DMinLine = Field <_CTR, 16, 4>; // Bits [19:16] : Log2 of the number of words in the smallest cache line of all the data and unified caches under the core control
        using L1IP = Field <_CTR, 14, 2>; // Bits [15:14] : Indicates the level 1 instruction cache policy for indexing and tagging
        using IminLine = Field <_CTR, 0, 4>; // Bits [3:0] : Log2 of the number of words in the smallest cache line of all the instruction caches under the control of the processor
    };

    // CCSIDR: Cache Size ID Register
    struct _CCSIDR : Register <0xE000ED80, ReadOnly, _CCSIDR> {
        using WT = Field <_CCSIDR, 31, 1>; // Bits [31] : Write-Through
        using WB = Field <_CCSIDR, 30, 1>; // Bits [30] : Write-Back
        using RA = Field <_CCSIDR, 29, 1>; // Bits [29] : Read-Allocation
        using WA = Field <_CCSIDR, 28, 1>; // Bits [28] : Write-Allocation
        using NS = Field <_CCSIDR, 13, 15>; // Bits [27:13] : Number of sets
        using A = Field <_CCSIDR, 3, 10>; // Bits [12:3] : Associativity
        using LS = Field <_CCSIDR, 0, 3>; // Bits [2:0] : Line Size
    };

    // CSSELR: Cache Size Selection Register
    struct _CSSELR : Register <0xE000ED84, ReadWrite, _CSSELR> {
        using L = Field <_CSSELR, 1, 3>; // Bits [3:1] : Level
        using IND = Field <_CSSELR, 0, 1>; // Bits [0] : Type
    };

    // ICIALLU: Instruction Cache Invalidate All to PoU
    struct _ICIALLU : Register <0xE000EF50, WriteOnly, _ICIALLU> {
    };

    // ICIMVAU: Instruction cache invalidate by MVA to PoU
    struct _ICIMVAU : Register <0xE000EF58, WriteOnly, _ICIMVAU> {
    };

    // DCIMVAC: Data cache invalidate by MVA to PoC
    struct _DCIMVAC : Register <0xE000EF5C, WriteOnly, _DCIMVAC> {
    };

    // DCISW: Data cache invalidate by set and way
    struct _DCISW : Register <0xE000EF60, WriteOnly, _DCISW> {
    };

    // DCCMVAU: Data cache clean by MVA to PoU
    struct _DCCMVAU : Register <0xE000EF64, WriteOnly, _DCCMVAU> {
    };

    // DCCMVAC: Data cache clean by MVA to PoC
    struct _DCCMVAC : Register <0xE000EF68, WriteOnly, _DCCMVAC> {
    };

    // DCCSW: Data cache clean by set and way
    struct _DCCSW : Register <0xE000EF6C, WriteOnly, _DCCSW> {
    };

    // DCCIMVAC: Data cache clean and invalidate by MVA to PoC
    struct _DCCIMVAC : Register <0xE000EF70, WriteOnly, _DCCIMVAC> {
    };

    // DCCISW: Data cache clean and invalidate by set and way
    struct _DCCISW : Register <0xE000EF74, WriteOnly, _DCCISW> {
    };

    // BPIALL: Branch predictor invalidate all
    struct _BPIALL : Register <0xE000EF78, WriteOnly, _BPIALL> {
    };

} // namespace Cache

// Generated from xml file: ./xml-svd/mpu_registers_v7m.xml

// --------------------------------------------
// MPU: Memory Protection Unit
// --------------------------------------------
namespace MPU {

    // MPU_TYPE: MPU Type Register
    struct _MPU_TYPE : Register <0xE000ED90, ReadOnly, _MPU_TYPE> {
        using SEPARATE = Field <_MPU_TYPE, 0, 1>; // Bits [0] : Indicates support for separate instruction and data address maps
        using DREGION = Field <_MPU_TYPE, 8, 8>; // Bits [15:8] : Number of regions supported by the MPU
        using IREGION = Field <_MPU_TYPE, 16, 8>; // Bits [23:16] : Number of instruction regions supported by the MPU
    };

    // MPU_CTRL: MPU Control Register
    struct  _MPU_CTRL : Register <0xE000ED94, ReadWrite, _MPU_CTRL> {
        using ENABLE = Field <_MPU_CTRL, 0, 1>; // Bits [0] : Enables the MPU
        using HFNMIENA = Field <_MPU_CTRL, 1, 1>; // Bits [1] : When the ENABLE bit is set to 1, controls whether handlers executing with priority less than 0 access memory with the MPU enabled or with the MPU disabled
        using PRIVDEFENA = Field <_MPU_CTRL, 2, 1>; // Bits [2] : When the ENABLE bit is set to 1, Enables the default memory map as a background region for privileged access
    };

    // MPU_RNR: MPU Region Number Register
    struct _MPU_RNR : Register <0xE000ED98, ReadWrite, _MPU_RNR> {
        using REGION = Field <_MPU_RNR, 0, 8>; // Bits [7:0] : Indicates the memory region accessed by MPU_RBAR and MPU_RSAR
    };

    // MPU_RBAR: MPU Region Base Address Register
    struct _MPU_RBAR : Register <0xE000ED9C, ReadWrite, _MPU_RBAR> {
        using REGION = Field <_MPU_RBAR, 0, 4>; // Bits [3:0] : On writes, can specify the number of the region to update. On reads, returns bits [3:0] of MPU_RNR
        using VALID = Field <_MPU_RBAR, 4, 1>; // Bits [4] : On writes, indicates whether the region to update is specified by MPU_RNR.REGION, or by the REGION value specified in this write. When using the REGION value specified by this write, MPU_RNR.REGION is updated to this value
        using ADDR = Field <_MPU_RBAR, 5, 27>; // Bits [31:5] : Base address of the region
    };

    // MPU_RASR: MPU Region Attribute and Size Register
    struct _MPU_RASR : Register <0xE000EDA0, ReadWrite, _MPU_RASR> {
        using ENABLE = Field <_MPU_RASR, 0, 1>; // Bits [0] : Enables this region
        using SIZE = Field <_MPU_RASR, 1, 5>; // Bits [5:1] : Indicates the region size
        using SRD = Field <_MPU_RASR, 8, 8>; // Bits [15:8] : Subregion Disable
        using B = Field <_MPU_RASR, 16, 1>; // Bits [16] : MPU Region Attribute field
        using C = Field <_MPU_RASR, 17, 1>; // Bits [17] : MPU Region Attribute field
        using S = Field <_MPU_RASR, 18, 1>; // Bits [18] : MPU Region Attribute field: Sharable
        using TEX = Field <_MPU_RASR, 19, 3>; // Bits [21:19] : MPU Region Attribute field
        using AP = Field <_MPU_RASR, 24, 3>; // Bits [26:24] : Access permissions
        using XN = Field <_MPU_RASR, 28, 1>; // Bits [28] : Execute Never
    };

    // MPU_RBAR_A1: MPU alias register for MPU Region Base Address Register
    struct _MPU_RBAR_A1 : Register <0xE000EDA4, ReadWrite, _MPU_RBAR_A1> {
        using REGION = Field <_MPU_RBAR_A1, 0, 4>; // Bits [3:0] : On writes, can specify the number of the region to update. On reads, returns bits [3:0] of MPU_RNR
        using VALID = Field <_MPU_RBAR_A1, 4, 1>; // Bits [4] : On writes, indicates whether the region to update is specified by MPU_RNR.REGION, or by the REGION value specified in this write. When using the REGION value specified by this write, MPU_RNR.REGION is updated to this value
        using ADDR = Field <_MPU_RBAR_A1, 5, 27>; // Bits [31:5] : Base address of the region
    };

    // MPU_RASR_A1: MPU alias register for MPU Region Attribute and Size Register
    struct _MPU_RASR_A1 : Register <0xE000EDA8, ReadWrite, _MPU_RASR_A1> {
        using ENABLE = Field <_MPU_RASR_A1, 0, 1>; // Bits [0] : Enables this region
        using SIZE = Field <_MPU_RASR_A1, 1, 5>; // Bits [5:1] : Indicates the region size
        using SRD = Field <_MPU_RASR_A1, 8, 8>; // Bits [15:8] : Subregion Disable
        using B = Field <_MPU_RASR_A1, 16, 1>; // Bits [16] : MPU Region Attribute field
        using C = Field <_MPU_RASR_A1, 17, 1>; // Bits [17] : MPU Region Attribute field
        using S = Field <_MPU_RASR_A1, 18, 1>; // Bits [18] : MPU Region Attribute field: Sharable
        using TEX = Field <_MPU_RASR_A1, 19, 3>; // Bits [21:19] : MPU Region Attribute field
        using AP = Field <_MPU_RASR_A1, 24, 3>; // Bits [26:24] : Access permissions
        using XN = Field <_MPU_RASR_A1, 28, 1>; // Bits [28] : Execute Never
    };

    // MPU_RBAR_A2: MPU alias register for MPU Region Base Address Register
    struct _MPU_RBAR_A2 : Register <0xE000EDAC, ReadWrite, _MPU_RBAR_A2> {
        using REGION = Field <_MPU_RBAR_A2, 0, 4>; // Bits [3:0] : On writes, can specify the number of the region to update. On reads, returns bits [3:0] of MPU_RNR
        using VALID = Field <_MPU_RBAR_A2, 4, 1>; // Bits [4] : On writes, indicates whether the region to update is specified by MPU_RNR.REGION, or by the REGION value specified in this write. When using the REGION value specified by this write, MPU_RNR.REGION is updated to this value
        using ADDR = Field <_MPU_RBAR_A2, 5, 27>; // Bits [31:5] : Base address of the region
    };

    // MPU_RASR_A2: MPU alias register for MPU Region Attribute and Size Register
    struct _MPU_RASR_A2 : Register <0xE000EDB0, ReadWrite, _MPU_RASR_A2> {
        using ENABLE = Field <_MPU_RASR_A2, 0, 1>; // Bits [0] : Enables this region
        using SIZE = Field <_MPU_RASR_A2, 1, 5>; // Bits [5:1] : Indicates the region size
        using SRD = Field <_MPU_RASR_A2, 8, 8>; // Bits [15:8] : Subregion Disable
        using B = Field <_MPU_RASR_A2, 16, 1>; // Bits [16] : MPU Region Attribute field
        using C = Field <_MPU_RASR_A2, 17, 1>; // Bits [17] : MPU Region Attribute field
        using S = Field <_MPU_RASR_A2, 18, 1>; // Bits [18] : MPU Region Attribute field: Sharable
        using TEX = Field <_MPU_RASR_A2, 19, 3>; // Bits [21:19] : MPU Region Attribute field
        using AP = Field <_MPU_RASR_A2, 24, 3>; // Bits [26:24] : Access permissions
        using XN = Field <_MPU_RASR_A2, 28, 1>; // Bits [28] : Execute Never
    };

    // MPU_RBAR_A3: MPU alias register for MPU Region Base Address Register
    struct _MPU_RBAR_A3 : Register <0xE000EDB4, ReadWrite, _MPU_RBAR_A3> {
        using REGION = Field <_MPU_RBAR_A3, 0, 4>; // Bits [3:0] : On writes, can specify the number of the region to update. On reads, returns bits [3:0] of MPU_RNR
        using VALID = Field <_MPU_RBAR_A3, 4, 1>; // Bits [4] : On writes, indicates whether the region to update is specified by MPU_RNR.REGION, or by the REGION value specified in this write. When using the REGION value specified by this write, MPU_RNR.REGION is updated to this value
        using ADDR = Field <_MPU_RBAR_A3, 5, 27>; // Bits [31:5] : Base address of the region
    };

    // MPU_RASR_A3: MPU alias register for MPU Region Attribute and Size Register
    struct _MPU_RASR_A3 : Register <0xE000EDB8, ReadWrite, _MPU_RASR_A3> {
        using ENABLE = Field <_MPU_RASR_A3, 0, 1>; // Bits [0] : Enables this region
        using SIZE = Field <_MPU_RASR_A3, 1, 5>; // Bits [5:1] : Indicates the region size
        using SRD = Field <_MPU_RASR_A3, 8, 8>; // Bits [15:8] : Subregion Disable
        using B = Field <_MPU_RASR_A3, 16, 1>; // Bits [16] : MPU Region Attribute field
        using C = Field <_MPU_RASR_A3, 17, 1>; // Bits [17] : MPU Region Attribute field
        using S = Field <_MPU_RASR_A3, 18, 1>; // Bits [18] : MPU Region Attribute field: Sharable
        using TEX = Field <_MPU_RASR_A3, 19, 3>; // Bits [21:19] : MPU Region Attribute field
        using AP = Field <_MPU_RASR_A3, 24, 3>; // Bits [26:24] : Access permissions
        using XN = Field <_MPU_RASR_A3, 28, 1>; // Bits [28] : Execute Never
    };

} // namespace MPU


/*-------------------------------------------------------------------------------
--------------------- End of Coretex-M7 Register Descripton ---------------------
-------------------------------------------------------------------------------*/


/*-----------------------------------------------------------------------------
------------------------ STM32F767 Register Descripton ------------------------
-------------------------------------------------------------------------------

Generating from file: ./mcore_regs.hpp*/


// --------------------------------------------
// RNG: Random number generator
// Base address: 0x50060800
// --------------------------------------------

namespace RNG {
    static constexpr uint32_t RNG_BASE = 0x50060800;

    // control register
    struct _CR : Register<RNG_BASE + 0x0, ReadWrite, _CR> {
        using IE = Field<_CR, 3, 1>; // Interrupt enable
        using RNGEN = Field<_CR, 2, 1>; // Random number generator enable
    };

    // status register
    struct _SR : Register<RNG_BASE + 0x4, ReadWrite, _SR> {
        using SEIS = Field<_SR, 6, 1>; // Seed error interrupt status
        using CEIS = Field<_SR, 5, 1>; // Clock error interrupt status
        using SECS = Field<_SR, 2, 1>; // Seed error current status
        using CECS = Field<_SR, 1, 1>; // Clock error current status
        using DRDY = Field<_SR, 0, 1>; // Data ready
    };

    // data register
    struct _DR : Register<RNG_BASE + 0x8, ReadOnly, _DR> {
        using RNDATA = Field<_DR, 0, 32>; // Random data
    };

} // namespace RNG

// --------------------------------------------
// HASH: Hash processor
// Base address: 0x50060400
// --------------------------------------------

namespace HASH {
    static constexpr uint32_t HASH_BASE = 0x50060400;

    // control register
    struct _CR : Register<HASH_BASE + 0x0, ReadWrite, _CR> {
        using INIT = Field<_CR, 2, 1>; // Initialize message digest calculation
        using DMAE = Field<_CR, 3, 1>; // DMA enable
        using DATATYPE = Field<_CR, 4, 2>; // Data type selection
        using MODE = Field<_CR, 6, 1>; // Mode selection
        using ALGO0 = Field<_CR, 7, 1>; // Algorithm selection
        using NBW = Field<_CR, 8, 4>; // Number of words already pushed
        using DINNE = Field<_CR, 12, 1>; // DIN not empty
        using MDMAT = Field<_CR, 13, 1>; // Multiple DMA Transfers
        using LKEY = Field<_CR, 16, 1>; // Long key selection
        using ALGO1 = Field<_CR, 18, 1>; // ALGO
    };

    // data input register
    struct _DIN : Register<HASH_BASE + 0x4, ReadWrite, _DIN> {
        using DATAIN = Field<_DIN, 0, 32>; // Data input
    };

    // start register
    struct _STR : Register<HASH_BASE + 0x8, ReadWrite, _STR> {
        using DCAL = Field<_STR, 8, 1>; // Digest calculation
        using NBLW = Field<_STR, 0, 5>; // Number of valid bits in the last word of the message
    };

    // digest registers
    struct _HR0 : Register<HASH_BASE + 0xC, ReadOnly, _HR0> {
        using H0 = Field<_HR0, 0, 32>; // H0
    };

    // digest registers
    struct _HR1 : Register<HASH_BASE + 0x10, ReadOnly, _HR1> {
        using H1 = Field<_HR1, 0, 32>; // H1
    };

    // digest registers
    struct _HR2 : Register<HASH_BASE + 0x14, ReadOnly, _HR2> {
        using H2 = Field<_HR2, 0, 32>; // H2
    };

    // digest registers
    struct _HR3 : Register<HASH_BASE + 0x18, ReadOnly, _HR3> {
        using H3 = Field<_HR3, 0, 32>; // H3
    };

    // digest registers
    struct _HR4 : Register<HASH_BASE + 0x1C, ReadOnly, _HR4> {
        using H4 = Field<_HR4, 0, 32>; // H4
    };

    // interrupt enable register
    struct _IMR : Register<HASH_BASE + 0x20, ReadWrite, _IMR> {
        using DCIE = Field<_IMR, 1, 1>; // Digest calculation completion interrupt enable
        using DINIE = Field<_IMR, 0, 1>; // Data input interrupt enable
    };

    // status register
    struct _SR : Register<HASH_BASE + 0x24, ReadWrite, _SR> {
        using BUSY = Field<_SR, 3, 1>; // Busy bit
        using DMAS = Field<_SR, 2, 1>; // DMA Status
        using DCIS = Field<_SR, 1, 1>; // Digest calculation completion interrupt status
        using DINIS = Field<_SR, 0, 1>; // Data input interrupt status
    };

    // context swap registers
    struct _CSR0 : Register<HASH_BASE + 0xF8, ReadWrite, _CSR0> {
        using CSR0 = Field<_CSR0, 0, 32>; // CSR0
    };

    // context swap registers
    struct _CSR1 : Register<HASH_BASE + 0xFC, ReadWrite, _CSR1> {
        using CSR1 = Field<_CSR1, 0, 32>; // CSR1
    };

    // context swap registers
    struct _CSR2 : Register<HASH_BASE + 0x100, ReadWrite, _CSR2> {
        using CSR2 = Field<_CSR2, 0, 32>; // CSR2
    };

    // context swap registers
    struct _CSR3 : Register<HASH_BASE + 0x104, ReadWrite, _CSR3> {
        using CSR3 = Field<_CSR3, 0, 32>; // CSR3
    };

    // context swap registers
    struct _CSR4 : Register<HASH_BASE + 0x108, ReadWrite, _CSR4> {
        using CSR4 = Field<_CSR4, 0, 32>; // CSR4
    };

    // context swap registers
    struct _CSR5 : Register<HASH_BASE + 0x10C, ReadWrite, _CSR5> {
        using CSR5 = Field<_CSR5, 0, 32>; // CSR5
    };

    // context swap registers
    struct _CSR6 : Register<HASH_BASE + 0x110, ReadWrite, _CSR6> {
        using CSR6 = Field<_CSR6, 0, 32>; // CSR6
    };

    // context swap registers
    struct _CSR7 : Register<HASH_BASE + 0x114, ReadWrite, _CSR7> {
        using CSR7 = Field<_CSR7, 0, 32>; // CSR7
    };

    // context swap registers
    struct _CSR8 : Register<HASH_BASE + 0x118, ReadWrite, _CSR8> {
        using CSR8 = Field<_CSR8, 0, 32>; // CSR8
    };

    // context swap registers
    struct _CSR9 : Register<HASH_BASE + 0x11C, ReadWrite, _CSR9> {
        using CSR9 = Field<_CSR9, 0, 32>; // CSR9
    };

    // context swap registers
    struct _CSR10 : Register<HASH_BASE + 0x120, ReadWrite, _CSR10> {
        using CSR10 = Field<_CSR10, 0, 32>; // CSR10
    };

    // context swap registers
    struct _CSR11 : Register<HASH_BASE + 0x124, ReadWrite, _CSR11> {
        using CSR11 = Field<_CSR11, 0, 32>; // CSR11
    };

    // context swap registers
    struct _CSR12 : Register<HASH_BASE + 0x128, ReadWrite, _CSR12> {
        using CSR12 = Field<_CSR12, 0, 32>; // CSR12
    };

    // context swap registers
    struct _CSR13 : Register<HASH_BASE + 0x12C, ReadWrite, _CSR13> {
        using CSR13 = Field<_CSR13, 0, 32>; // CSR13
    };

    // context swap registers
    struct _CSR14 : Register<HASH_BASE + 0x130, ReadWrite, _CSR14> {
        using CSR14 = Field<_CSR14, 0, 32>; // CSR14
    };

    // context swap registers
    struct _CSR15 : Register<HASH_BASE + 0x134, ReadWrite, _CSR15> {
        using CSR15 = Field<_CSR15, 0, 32>; // CSR15
    };

    // context swap registers
    struct _CSR16 : Register<HASH_BASE + 0x138, ReadWrite, _CSR16> {
        using CSR16 = Field<_CSR16, 0, 32>; // CSR16
    };

    // context swap registers
    struct _CSR17 : Register<HASH_BASE + 0x13C, ReadWrite, _CSR17> {
        using CSR17 = Field<_CSR17, 0, 32>; // CSR17
    };

    // context swap registers
    struct _CSR18 : Register<HASH_BASE + 0x140, ReadWrite, _CSR18> {
        using CSR18 = Field<_CSR18, 0, 32>; // CSR18
    };

    // context swap registers
    struct _CSR19 : Register<HASH_BASE + 0x144, ReadWrite, _CSR19> {
        using CSR19 = Field<_CSR19, 0, 32>; // CSR19
    };

    // context swap registers
    struct _CSR20 : Register<HASH_BASE + 0x148, ReadWrite, _CSR20> {
        using CSR20 = Field<_CSR20, 0, 32>; // CSR20
    };

    // context swap registers
    struct _CSR21 : Register<HASH_BASE + 0x14C, ReadWrite, _CSR21> {
        using CSR21 = Field<_CSR21, 0, 32>; // CSR21
    };

    // context swap registers
    struct _CSR22 : Register<HASH_BASE + 0x150, ReadWrite, _CSR22> {
        using CSR22 = Field<_CSR22, 0, 32>; // CSR22
    };

    // context swap registers
    struct _CSR23 : Register<HASH_BASE + 0x154, ReadWrite, _CSR23> {
        using CSR23 = Field<_CSR23, 0, 32>; // CSR23
    };

    // context swap registers
    struct _CSR24 : Register<HASH_BASE + 0x158, ReadWrite, _CSR24> {
        using CSR24 = Field<_CSR24, 0, 32>; // CSR24
    };

    // context swap registers
    struct _CSR25 : Register<HASH_BASE + 0x15C, ReadWrite, _CSR25> {
        using CSR25 = Field<_CSR25, 0, 32>; // CSR25
    };

    // context swap registers
    struct _CSR26 : Register<HASH_BASE + 0x160, ReadWrite, _CSR26> {
        using CSR26 = Field<_CSR26, 0, 32>; // CSR26
    };

    // context swap registers
    struct _CSR27 : Register<HASH_BASE + 0x164, ReadWrite, _CSR27> {
        using CSR27 = Field<_CSR27, 0, 32>; // CSR27
    };

    // context swap registers
    struct _CSR28 : Register<HASH_BASE + 0x168, ReadWrite, _CSR28> {
        using CSR28 = Field<_CSR28, 0, 32>; // CSR28
    };

    // context swap registers
    struct _CSR29 : Register<HASH_BASE + 0x16C, ReadWrite, _CSR29> {
        using CSR29 = Field<_CSR29, 0, 32>; // CSR29
    };

    // context swap registers
    struct _CSR30 : Register<HASH_BASE + 0x170, ReadWrite, _CSR30> {
        using CSR30 = Field<_CSR30, 0, 32>; // CSR30
    };

    // context swap registers
    struct _CSR31 : Register<HASH_BASE + 0x174, ReadWrite, _CSR31> {
        using CSR31 = Field<_CSR31, 0, 32>; // CSR31
    };

    // context swap registers
    struct _CSR32 : Register<HASH_BASE + 0x178, ReadWrite, _CSR32> {
        using CSR32 = Field<_CSR32, 0, 32>; // CSR32
    };

    // context swap registers
    struct _CSR33 : Register<HASH_BASE + 0x17C, ReadWrite, _CSR33> {
        using CSR33 = Field<_CSR33, 0, 32>; // CSR33
    };

    // context swap registers
    struct _CSR34 : Register<HASH_BASE + 0x180, ReadWrite, _CSR34> {
        using CSR34 = Field<_CSR34, 0, 32>; // CSR34
    };

    // context swap registers
    struct _CSR35 : Register<HASH_BASE + 0x184, ReadWrite, _CSR35> {
        using CSR35 = Field<_CSR35, 0, 32>; // CSR35
    };

    // context swap registers
    struct _CSR36 : Register<HASH_BASE + 0x188, ReadWrite, _CSR36> {
        using CSR36 = Field<_CSR36, 0, 32>; // CSR36
    };

    // context swap registers
    struct _CSR37 : Register<HASH_BASE + 0x18C, ReadWrite, _CSR37> {
        using CSR37 = Field<_CSR37, 0, 32>; // CSR37
    };

    // context swap registers
    struct _CSR38 : Register<HASH_BASE + 0x190, ReadWrite, _CSR38> {
        using CSR38 = Field<_CSR38, 0, 32>; // CSR38
    };

    // context swap registers
    struct _CSR39 : Register<HASH_BASE + 0x194, ReadWrite, _CSR39> {
        using CSR39 = Field<_CSR39, 0, 32>; // CSR39
    };

    // context swap registers
    struct _CSR40 : Register<HASH_BASE + 0x198, ReadWrite, _CSR40> {
        using CSR40 = Field<_CSR40, 0, 32>; // CSR40
    };

    // context swap registers
    struct _CSR41 : Register<HASH_BASE + 0x19C, ReadWrite, _CSR41> {
        using CSR41 = Field<_CSR41, 0, 32>; // CSR41
    };

    // context swap registers
    struct _CSR42 : Register<HASH_BASE + 0x1A0, ReadWrite, _CSR42> {
        using CSR42 = Field<_CSR42, 0, 32>; // CSR42
    };

    // context swap registers
    struct _CSR43 : Register<HASH_BASE + 0x1A4, ReadWrite, _CSR43> {
        using CSR43 = Field<_CSR43, 0, 32>; // CSR43
    };

    // context swap registers
    struct _CSR44 : Register<HASH_BASE + 0x1A8, ReadWrite, _CSR44> {
        using CSR44 = Field<_CSR44, 0, 32>; // CSR44
    };

    // context swap registers
    struct _CSR45 : Register<HASH_BASE + 0x1AC, ReadWrite, _CSR45> {
        using CSR45 = Field<_CSR45, 0, 32>; // CSR45
    };

    // context swap registers
    struct _CSR46 : Register<HASH_BASE + 0x1B0, ReadWrite, _CSR46> {
        using CSR46 = Field<_CSR46, 0, 32>; // CSR46
    };

    // context swap registers
    struct _CSR47 : Register<HASH_BASE + 0x1B4, ReadWrite, _CSR47> {
        using CSR47 = Field<_CSR47, 0, 32>; // CSR47
    };

    // context swap registers
    struct _CSR48 : Register<HASH_BASE + 0x1B8, ReadWrite, _CSR48> {
        using CSR48 = Field<_CSR48, 0, 32>; // CSR48
    };

    // context swap registers
    struct _CSR49 : Register<HASH_BASE + 0x1BC, ReadWrite, _CSR49> {
        using CSR49 = Field<_CSR49, 0, 32>; // CSR49
    };

    // context swap registers
    struct _CSR50 : Register<HASH_BASE + 0x1C0, ReadWrite, _CSR50> {
        using CSR50 = Field<_CSR50, 0, 32>; // CSR50
    };

    // context swap registers
    struct _CSR51 : Register<HASH_BASE + 0x1C4, ReadWrite, _CSR51> {
        using CSR51 = Field<_CSR51, 0, 32>; // CSR51
    };

    // context swap registers
    struct _CSR52 : Register<HASH_BASE + 0x1C8, ReadWrite, _CSR52> {
        using CSR52 = Field<_CSR52, 0, 32>; // CSR52
    };

    // context swap registers
    struct _CSR53 : Register<HASH_BASE + 0x1CC, ReadWrite, _CSR53> {
        using CSR53 = Field<_CSR53, 0, 32>; // CSR53
    };

    // HASH digest register
    struct _HASH_HR0 : Register<HASH_BASE + 0x310, ReadOnly, _HASH_HR0> {
        using H0 = Field<_HASH_HR0, 0, 32>; // H0
    };

    // read-only
    struct _HASH_HR1 : Register<HASH_BASE + 0x314, ReadOnly, _HASH_HR1> {
        using H1 = Field<_HASH_HR1, 0, 32>; // H1
    };

    // read-only
    struct _HASH_HR2 : Register<HASH_BASE + 0x318, ReadOnly, _HASH_HR2> {
        using H2 = Field<_HASH_HR2, 0, 32>; // H2
    };

    // read-only
    struct _HASH_HR3 : Register<HASH_BASE + 0x31C, ReadOnly, _HASH_HR3> {
        using H3 = Field<_HASH_HR3, 0, 32>; // H3
    };

    // read-only
    struct _HASH_HR4 : Register<HASH_BASE + 0x320, ReadOnly, _HASH_HR4> {
        using H4 = Field<_HASH_HR4, 0, 32>; // H4
    };

    // read-only
    struct _HASH_HR5 : Register<HASH_BASE + 0x324, ReadOnly, _HASH_HR5> {
        using H5 = Field<_HASH_HR5, 0, 32>; // H5
    };

    // read-only
    struct _HASH_HR6 : Register<HASH_BASE + 0x328, ReadOnly, _HASH_HR6> {
        using H6 = Field<_HASH_HR6, 0, 32>; // H6
    };

    // read-only
    struct _HASH_HR7 : Register<HASH_BASE + 0x32C, ReadOnly, _HASH_HR7> {
        using H7 = Field<_HASH_HR7, 0, 32>; // H7
    };

} // namespace HASH

// --------------------------------------------
// CRYP: Cryptographic processor
// Base address: 0x50060000
// --------------------------------------------

namespace CRYP {
    static constexpr uint32_t CRYP_BASE = 0x50060000;

    // control register
    struct _CR : Register<CRYP_BASE + 0x0, ReadWrite, _CR> {
        using ALGODIR = Field<_CR, 2, 1>; // Algorithm direction
        using ALGOMODE0 = Field<_CR, 3, 3>; // Algorithm mode
        using DATATYPE = Field<_CR, 6, 2>; // Data type selection
        using KEYSIZE = Field<_CR, 8, 2>; // Key size selection (AES mode only)
        using FFLUSH = Field<_CR, 14, 1>; // FIFO flush
        using CRYPEN = Field<_CR, 15, 1>; // Cryptographic processor enable
        using GCM_CCMPH = Field<_CR, 16, 2>; // GCM_CCMPH
        using ALGOMODE3 = Field<_CR, 19, 1>; // ALGOMODE
    };

    // status register
    struct _SR : Register<CRYP_BASE + 0x4, ReadOnly, _SR> {
        using BUSY = Field<_SR, 4, 1>; // Busy bit
        using OFFU = Field<_SR, 3, 1>; // Output FIFO full
        using OFNE = Field<_SR, 2, 1>; // Output FIFO not empty
        using IFNF = Field<_SR, 1, 1>; // Input FIFO not full
        using IFEM = Field<_SR, 0, 1>; // Input FIFO empty
    };

    // data input register
    struct _DIN : Register<CRYP_BASE + 0x8, ReadWrite, _DIN> {
        using DATAIN = Field<_DIN, 0, 32>; // Data input
    };

    // data output register
    struct _DOUT : Register<CRYP_BASE + 0xC, ReadOnly, _DOUT> {
        using DATAOUT = Field<_DOUT, 0, 32>; // Data output
    };

    // DMA control register
    struct _DMACR : Register<CRYP_BASE + 0x10, ReadWrite, _DMACR> {
        using DOEN = Field<_DMACR, 1, 1>; // DMA output enable
        using DIEN = Field<_DMACR, 0, 1>; // DMA input enable
    };

    // interrupt mask set/clear register
    struct _IMSCR : Register<CRYP_BASE + 0x14, ReadWrite, _IMSCR> {
        using OUTIM = Field<_IMSCR, 1, 1>; // Output FIFO service interrupt mask
        using INIM = Field<_IMSCR, 0, 1>; // Input FIFO service interrupt mask
    };

    // raw interrupt status register
    struct _RISR : Register<CRYP_BASE + 0x18, ReadOnly, _RISR> {
        using OUTRIS = Field<_RISR, 1, 1>; // Output FIFO service raw interrupt status
        using INRIS = Field<_RISR, 0, 1>; // Input FIFO service raw interrupt status
    };

    // masked interrupt status register
    struct _MISR : Register<CRYP_BASE + 0x1C, ReadOnly, _MISR> {
        using OUTMIS = Field<_MISR, 1, 1>; // Output FIFO service masked interrupt status
        using INMIS = Field<_MISR, 0, 1>; // Input FIFO service masked interrupt status
    };

    // key registers
    struct _K0LR : Register<CRYP_BASE + 0x20, WriteOnly, _K0LR> {
        using b224 = Field<_K0LR, 0, 1>; // b224
        using b225 = Field<_K0LR, 1, 1>; // b225
        using b226 = Field<_K0LR, 2, 1>; // b226
        using b227 = Field<_K0LR, 3, 1>; // b227
        using b228 = Field<_K0LR, 4, 1>; // b228
        using b229 = Field<_K0LR, 5, 1>; // b229
        using b230 = Field<_K0LR, 6, 1>; // b230
        using b231 = Field<_K0LR, 7, 1>; // b231
        using b232 = Field<_K0LR, 8, 1>; // b232
        using b233 = Field<_K0LR, 9, 1>; // b233
        using b234 = Field<_K0LR, 10, 1>; // b234
        using b235 = Field<_K0LR, 11, 1>; // b235
        using b236 = Field<_K0LR, 12, 1>; // b236
        using b237 = Field<_K0LR, 13, 1>; // b237
        using b238 = Field<_K0LR, 14, 1>; // b238
        using b239 = Field<_K0LR, 15, 1>; // b239
        using b240 = Field<_K0LR, 16, 1>; // b240
        using b241 = Field<_K0LR, 17, 1>; // b241
        using b242 = Field<_K0LR, 18, 1>; // b242
        using b243 = Field<_K0LR, 19, 1>; // b243
        using b244 = Field<_K0LR, 20, 1>; // b244
        using b245 = Field<_K0LR, 21, 1>; // b245
        using b246 = Field<_K0LR, 22, 1>; // b246
        using b247 = Field<_K0LR, 23, 1>; // b247
        using b248 = Field<_K0LR, 24, 1>; // b248
        using b249 = Field<_K0LR, 25, 1>; // b249
        using b250 = Field<_K0LR, 26, 1>; // b250
        using b251 = Field<_K0LR, 27, 1>; // b251
        using b252 = Field<_K0LR, 28, 1>; // b252
        using b253 = Field<_K0LR, 29, 1>; // b253
        using b254 = Field<_K0LR, 30, 1>; // b254
        using b255 = Field<_K0LR, 31, 1>; // b255
    };

    // key registers
    struct _K0RR : Register<CRYP_BASE + 0x24, WriteOnly, _K0RR> {
        using b192 = Field<_K0RR, 0, 1>; // b192
        using b193 = Field<_K0RR, 1, 1>; // b193
        using b194 = Field<_K0RR, 2, 1>; // b194
        using b195 = Field<_K0RR, 3, 1>; // b195
        using b196 = Field<_K0RR, 4, 1>; // b196
        using b197 = Field<_K0RR, 5, 1>; // b197
        using b198 = Field<_K0RR, 6, 1>; // b198
        using b199 = Field<_K0RR, 7, 1>; // b199
        using b200 = Field<_K0RR, 8, 1>; // b200
        using b201 = Field<_K0RR, 9, 1>; // b201
        using b202 = Field<_K0RR, 10, 1>; // b202
        using b203 = Field<_K0RR, 11, 1>; // b203
        using b204 = Field<_K0RR, 12, 1>; // b204
        using b205 = Field<_K0RR, 13, 1>; // b205
        using b206 = Field<_K0RR, 14, 1>; // b206
        using b207 = Field<_K0RR, 15, 1>; // b207
        using b208 = Field<_K0RR, 16, 1>; // b208
        using b209 = Field<_K0RR, 17, 1>; // b209
        using b210 = Field<_K0RR, 18, 1>; // b210
        using b211 = Field<_K0RR, 19, 1>; // b211
        using b212 = Field<_K0RR, 20, 1>; // b212
        using b213 = Field<_K0RR, 21, 1>; // b213
        using b214 = Field<_K0RR, 22, 1>; // b214
        using b215 = Field<_K0RR, 23, 1>; // b215
        using b216 = Field<_K0RR, 24, 1>; // b216
        using b217 = Field<_K0RR, 25, 1>; // b217
        using b218 = Field<_K0RR, 26, 1>; // b218
        using b219 = Field<_K0RR, 27, 1>; // b219
        using b220 = Field<_K0RR, 28, 1>; // b220
        using b221 = Field<_K0RR, 29, 1>; // b221
        using b222 = Field<_K0RR, 30, 1>; // b222
        using b223 = Field<_K0RR, 31, 1>; // b223
    };

    // key registers
    struct _K1LR : Register<CRYP_BASE + 0x28, WriteOnly, _K1LR> {
        using b160 = Field<_K1LR, 0, 1>; // b160
        using b161 = Field<_K1LR, 1, 1>; // b161
        using b162 = Field<_K1LR, 2, 1>; // b162
        using b163 = Field<_K1LR, 3, 1>; // b163
        using b164 = Field<_K1LR, 4, 1>; // b164
        using b165 = Field<_K1LR, 5, 1>; // b165
        using b166 = Field<_K1LR, 6, 1>; // b166
        using b167 = Field<_K1LR, 7, 1>; // b167
        using b168 = Field<_K1LR, 8, 1>; // b168
        using b169 = Field<_K1LR, 9, 1>; // b169
        using b170 = Field<_K1LR, 10, 1>; // b170
        using b171 = Field<_K1LR, 11, 1>; // b171
        using b172 = Field<_K1LR, 12, 1>; // b172
        using b173 = Field<_K1LR, 13, 1>; // b173
        using b174 = Field<_K1LR, 14, 1>; // b174
        using b175 = Field<_K1LR, 15, 1>; // b175
        using b176 = Field<_K1LR, 16, 1>; // b176
        using b177 = Field<_K1LR, 17, 1>; // b177
        using b178 = Field<_K1LR, 18, 1>; // b178
        using b179 = Field<_K1LR, 19, 1>; // b179
        using b180 = Field<_K1LR, 20, 1>; // b180
        using b181 = Field<_K1LR, 21, 1>; // b181
        using b182 = Field<_K1LR, 22, 1>; // b182
        using b183 = Field<_K1LR, 23, 1>; // b183
        using b184 = Field<_K1LR, 24, 1>; // b184
        using b185 = Field<_K1LR, 25, 1>; // b185
        using b186 = Field<_K1LR, 26, 1>; // b186
        using b187 = Field<_K1LR, 27, 1>; // b187
        using b188 = Field<_K1LR, 28, 1>; // b188
        using b189 = Field<_K1LR, 29, 1>; // b189
        using b190 = Field<_K1LR, 30, 1>; // b190
        using b191 = Field<_K1LR, 31, 1>; // b191
    };

    // key registers
    struct _K1RR : Register<CRYP_BASE + 0x2C, WriteOnly, _K1RR> {
        using b128 = Field<_K1RR, 0, 1>; // b128
        using b129 = Field<_K1RR, 1, 1>; // b129
        using b130 = Field<_K1RR, 2, 1>; // b130
        using b131 = Field<_K1RR, 3, 1>; // b131
        using b132 = Field<_K1RR, 4, 1>; // b132
        using b133 = Field<_K1RR, 5, 1>; // b133
        using b134 = Field<_K1RR, 6, 1>; // b134
        using b135 = Field<_K1RR, 7, 1>; // b135
        using b136 = Field<_K1RR, 8, 1>; // b136
        using b137 = Field<_K1RR, 9, 1>; // b137
        using b138 = Field<_K1RR, 10, 1>; // b138
        using b139 = Field<_K1RR, 11, 1>; // b139
        using b140 = Field<_K1RR, 12, 1>; // b140
        using b141 = Field<_K1RR, 13, 1>; // b141
        using b142 = Field<_K1RR, 14, 1>; // b142
        using b143 = Field<_K1RR, 15, 1>; // b143
        using b144 = Field<_K1RR, 16, 1>; // b144
        using b145 = Field<_K1RR, 17, 1>; // b145
        using b146 = Field<_K1RR, 18, 1>; // b146
        using b147 = Field<_K1RR, 19, 1>; // b147
        using b148 = Field<_K1RR, 20, 1>; // b148
        using b149 = Field<_K1RR, 21, 1>; // b149
        using b150 = Field<_K1RR, 22, 1>; // b150
        using b151 = Field<_K1RR, 23, 1>; // b151
        using b152 = Field<_K1RR, 24, 1>; // b152
        using b153 = Field<_K1RR, 25, 1>; // b153
        using b154 = Field<_K1RR, 26, 1>; // b154
        using b155 = Field<_K1RR, 27, 1>; // b155
        using b156 = Field<_K1RR, 28, 1>; // b156
        using b157 = Field<_K1RR, 29, 1>; // b157
        using b158 = Field<_K1RR, 30, 1>; // b158
        using b159 = Field<_K1RR, 31, 1>; // b159
    };

    // key registers
    struct _K2LR : Register<CRYP_BASE + 0x30, WriteOnly, _K2LR> {
        using b96 = Field<_K2LR, 0, 1>; // b96
        using b97 = Field<_K2LR, 1, 1>; // b97
        using b98 = Field<_K2LR, 2, 1>; // b98
        using b99 = Field<_K2LR, 3, 1>; // b99
        using b100 = Field<_K2LR, 4, 1>; // b100
        using b101 = Field<_K2LR, 5, 1>; // b101
        using b102 = Field<_K2LR, 6, 1>; // b102
        using b103 = Field<_K2LR, 7, 1>; // b103
        using b104 = Field<_K2LR, 8, 1>; // b104
        using b105 = Field<_K2LR, 9, 1>; // b105
        using b106 = Field<_K2LR, 10, 1>; // b106
        using b107 = Field<_K2LR, 11, 1>; // b107
        using b108 = Field<_K2LR, 12, 1>; // b108
        using b109 = Field<_K2LR, 13, 1>; // b109
        using b110 = Field<_K2LR, 14, 1>; // b110
        using b111 = Field<_K2LR, 15, 1>; // b111
        using b112 = Field<_K2LR, 16, 1>; // b112
        using b113 = Field<_K2LR, 17, 1>; // b113
        using b114 = Field<_K2LR, 18, 1>; // b114
        using b115 = Field<_K2LR, 19, 1>; // b115
        using b116 = Field<_K2LR, 20, 1>; // b116
        using b117 = Field<_K2LR, 21, 1>; // b117
        using b118 = Field<_K2LR, 22, 1>; // b118
        using b119 = Field<_K2LR, 23, 1>; // b119
        using b120 = Field<_K2LR, 24, 1>; // b120
        using b121 = Field<_K2LR, 25, 1>; // b121
        using b122 = Field<_K2LR, 26, 1>; // b122
        using b123 = Field<_K2LR, 27, 1>; // b123
        using b124 = Field<_K2LR, 28, 1>; // b124
        using b125 = Field<_K2LR, 29, 1>; // b125
        using b126 = Field<_K2LR, 30, 1>; // b126
        using b127 = Field<_K2LR, 31, 1>; // b127
    };

    // key registers
    struct _K2RR : Register<CRYP_BASE + 0x34, WriteOnly, _K2RR> {
        using b64 = Field<_K2RR, 0, 1>; // b64
        using b65 = Field<_K2RR, 1, 1>; // b65
        using b66 = Field<_K2RR, 2, 1>; // b66
        using b67 = Field<_K2RR, 3, 1>; // b67
        using b68 = Field<_K2RR, 4, 1>; // b68
        using b69 = Field<_K2RR, 5, 1>; // b69
        using b70 = Field<_K2RR, 6, 1>; // b70
        using b71 = Field<_K2RR, 7, 1>; // b71
        using b72 = Field<_K2RR, 8, 1>; // b72
        using b73 = Field<_K2RR, 9, 1>; // b73
        using b74 = Field<_K2RR, 10, 1>; // b74
        using b75 = Field<_K2RR, 11, 1>; // b75
        using b76 = Field<_K2RR, 12, 1>; // b76
        using b77 = Field<_K2RR, 13, 1>; // b77
        using b78 = Field<_K2RR, 14, 1>; // b78
        using b79 = Field<_K2RR, 15, 1>; // b79
        using b80 = Field<_K2RR, 16, 1>; // b80
        using b81 = Field<_K2RR, 17, 1>; // b81
        using b82 = Field<_K2RR, 18, 1>; // b82
        using b83 = Field<_K2RR, 19, 1>; // b83
        using b84 = Field<_K2RR, 20, 1>; // b84
        using b85 = Field<_K2RR, 21, 1>; // b85
        using b86 = Field<_K2RR, 22, 1>; // b86
        using b87 = Field<_K2RR, 23, 1>; // b87
        using b88 = Field<_K2RR, 24, 1>; // b88
        using b89 = Field<_K2RR, 25, 1>; // b89
        using b90 = Field<_K2RR, 26, 1>; // b90
        using b91 = Field<_K2RR, 27, 1>; // b91
        using b92 = Field<_K2RR, 28, 1>; // b92
        using b93 = Field<_K2RR, 29, 1>; // b93
        using b94 = Field<_K2RR, 30, 1>; // b94
        using b95 = Field<_K2RR, 31, 1>; // b95
    };

    // key registers
    struct _K3LR : Register<CRYP_BASE + 0x38, WriteOnly, _K3LR> {
        using b32 = Field<_K3LR, 0, 1>; // b32
        using b33 = Field<_K3LR, 1, 1>; // b33
        using b34 = Field<_K3LR, 2, 1>; // b34
        using b35 = Field<_K3LR, 3, 1>; // b35
        using b36 = Field<_K3LR, 4, 1>; // b36
        using b37 = Field<_K3LR, 5, 1>; // b37
        using b38 = Field<_K3LR, 6, 1>; // b38
        using b39 = Field<_K3LR, 7, 1>; // b39
        using b40 = Field<_K3LR, 8, 1>; // b40
        using b41 = Field<_K3LR, 9, 1>; // b41
        using b42 = Field<_K3LR, 10, 1>; // b42
        using b43 = Field<_K3LR, 11, 1>; // b43
        using b44 = Field<_K3LR, 12, 1>; // b44
        using b45 = Field<_K3LR, 13, 1>; // b45
        using b46 = Field<_K3LR, 14, 1>; // b46
        using b47 = Field<_K3LR, 15, 1>; // b47
        using b48 = Field<_K3LR, 16, 1>; // b48
        using b49 = Field<_K3LR, 17, 1>; // b49
        using b50 = Field<_K3LR, 18, 1>; // b50
        using b51 = Field<_K3LR, 19, 1>; // b51
        using b52 = Field<_K3LR, 20, 1>; // b52
        using b53 = Field<_K3LR, 21, 1>; // b53
        using b54 = Field<_K3LR, 22, 1>; // b54
        using b55 = Field<_K3LR, 23, 1>; // b55
        using b56 = Field<_K3LR, 24, 1>; // b56
        using b57 = Field<_K3LR, 25, 1>; // b57
        using b58 = Field<_K3LR, 26, 1>; // b58
        using b59 = Field<_K3LR, 27, 1>; // b59
        using b60 = Field<_K3LR, 28, 1>; // b60
        using b61 = Field<_K3LR, 29, 1>; // b61
        using b62 = Field<_K3LR, 30, 1>; // b62
        using b63 = Field<_K3LR, 31, 1>; // b63
    };

    // key registers
    struct _K3RR : Register<CRYP_BASE + 0x3C, WriteOnly, _K3RR> {
        using b0 = Field<_K3RR, 0, 1>; // b0
        using b1 = Field<_K3RR, 1, 1>; // b1
        using b2 = Field<_K3RR, 2, 1>; // b2
        using b3 = Field<_K3RR, 3, 1>; // b3
        using b4 = Field<_K3RR, 4, 1>; // b4
        using b5 = Field<_K3RR, 5, 1>; // b5
        using b6 = Field<_K3RR, 6, 1>; // b6
        using b7 = Field<_K3RR, 7, 1>; // b7
        using b8 = Field<_K3RR, 8, 1>; // b8
        using b9 = Field<_K3RR, 9, 1>; // b9
        using b10 = Field<_K3RR, 10, 1>; // b10
        using b11 = Field<_K3RR, 11, 1>; // b11
        using b12 = Field<_K3RR, 12, 1>; // b12
        using b13 = Field<_K3RR, 13, 1>; // b13
        using b14 = Field<_K3RR, 14, 1>; // b14
        using b15 = Field<_K3RR, 15, 1>; // b15
        using b16 = Field<_K3RR, 16, 1>; // b16
        using b17 = Field<_K3RR, 17, 1>; // b17
        using b18 = Field<_K3RR, 18, 1>; // b18
        using b19 = Field<_K3RR, 19, 1>; // b19
        using b20 = Field<_K3RR, 20, 1>; // b20
        using b21 = Field<_K3RR, 21, 1>; // b21
        using b22 = Field<_K3RR, 22, 1>; // b22
        using b23 = Field<_K3RR, 23, 1>; // b23
        using b24 = Field<_K3RR, 24, 1>; // b24
        using b25 = Field<_K3RR, 25, 1>; // b25
        using b26 = Field<_K3RR, 26, 1>; // b26
        using b27 = Field<_K3RR, 27, 1>; // b27
        using b28 = Field<_K3RR, 28, 1>; // b28
        using b29 = Field<_K3RR, 29, 1>; // b29
        using b30 = Field<_K3RR, 30, 1>; // b30
        using b31 = Field<_K3RR, 31, 1>; // b31
    };

    // initialization vector registers
    struct _IV0LR : Register<CRYP_BASE + 0x40, ReadWrite, _IV0LR> {
        using IV31 = Field<_IV0LR, 0, 1>; // IV31
        using IV30 = Field<_IV0LR, 1, 1>; // IV30
        using IV29 = Field<_IV0LR, 2, 1>; // IV29
        using IV28 = Field<_IV0LR, 3, 1>; // IV28
        using IV27 = Field<_IV0LR, 4, 1>; // IV27
        using IV26 = Field<_IV0LR, 5, 1>; // IV26
        using IV25 = Field<_IV0LR, 6, 1>; // IV25
        using IV24 = Field<_IV0LR, 7, 1>; // IV24
        using IV23 = Field<_IV0LR, 8, 1>; // IV23
        using IV22 = Field<_IV0LR, 9, 1>; // IV22
        using IV21 = Field<_IV0LR, 10, 1>; // IV21
        using IV20 = Field<_IV0LR, 11, 1>; // IV20
        using IV19 = Field<_IV0LR, 12, 1>; // IV19
        using IV18 = Field<_IV0LR, 13, 1>; // IV18
        using IV17 = Field<_IV0LR, 14, 1>; // IV17
        using IV16 = Field<_IV0LR, 15, 1>; // IV16
        using IV15 = Field<_IV0LR, 16, 1>; // IV15
        using IV14 = Field<_IV0LR, 17, 1>; // IV14
        using IV13 = Field<_IV0LR, 18, 1>; // IV13
        using IV12 = Field<_IV0LR, 19, 1>; // IV12
        using IV11 = Field<_IV0LR, 20, 1>; // IV11
        using IV10 = Field<_IV0LR, 21, 1>; // IV10
        using IV9 = Field<_IV0LR, 22, 1>; // IV9
        using IV8 = Field<_IV0LR, 23, 1>; // IV8
        using IV7 = Field<_IV0LR, 24, 1>; // IV7
        using IV6 = Field<_IV0LR, 25, 1>; // IV6
        using IV5 = Field<_IV0LR, 26, 1>; // IV5
        using IV4 = Field<_IV0LR, 27, 1>; // IV4
        using IV3 = Field<_IV0LR, 28, 1>; // IV3
        using IV2 = Field<_IV0LR, 29, 1>; // IV2
        using IV1 = Field<_IV0LR, 30, 1>; // IV1
        using IV0 = Field<_IV0LR, 31, 1>; // IV0
    };

    // initialization vector registers
    struct _IV0RR : Register<CRYP_BASE + 0x44, ReadWrite, _IV0RR> {
        using IV63 = Field<_IV0RR, 0, 1>; // IV63
        using IV62 = Field<_IV0RR, 1, 1>; // IV62
        using IV61 = Field<_IV0RR, 2, 1>; // IV61
        using IV60 = Field<_IV0RR, 3, 1>; // IV60
        using IV59 = Field<_IV0RR, 4, 1>; // IV59
        using IV58 = Field<_IV0RR, 5, 1>; // IV58
        using IV57 = Field<_IV0RR, 6, 1>; // IV57
        using IV56 = Field<_IV0RR, 7, 1>; // IV56
        using IV55 = Field<_IV0RR, 8, 1>; // IV55
        using IV54 = Field<_IV0RR, 9, 1>; // IV54
        using IV53 = Field<_IV0RR, 10, 1>; // IV53
        using IV52 = Field<_IV0RR, 11, 1>; // IV52
        using IV51 = Field<_IV0RR, 12, 1>; // IV51
        using IV50 = Field<_IV0RR, 13, 1>; // IV50
        using IV49 = Field<_IV0RR, 14, 1>; // IV49
        using IV48 = Field<_IV0RR, 15, 1>; // IV48
        using IV47 = Field<_IV0RR, 16, 1>; // IV47
        using IV46 = Field<_IV0RR, 17, 1>; // IV46
        using IV45 = Field<_IV0RR, 18, 1>; // IV45
        using IV44 = Field<_IV0RR, 19, 1>; // IV44
        using IV43 = Field<_IV0RR, 20, 1>; // IV43
        using IV42 = Field<_IV0RR, 21, 1>; // IV42
        using IV41 = Field<_IV0RR, 22, 1>; // IV41
        using IV40 = Field<_IV0RR, 23, 1>; // IV40
        using IV39 = Field<_IV0RR, 24, 1>; // IV39
        using IV38 = Field<_IV0RR, 25, 1>; // IV38
        using IV37 = Field<_IV0RR, 26, 1>; // IV37
        using IV36 = Field<_IV0RR, 27, 1>; // IV36
        using IV35 = Field<_IV0RR, 28, 1>; // IV35
        using IV34 = Field<_IV0RR, 29, 1>; // IV34
        using IV33 = Field<_IV0RR, 30, 1>; // IV33
        using IV32 = Field<_IV0RR, 31, 1>; // IV32
    };

    // initialization vector registers
    struct _IV1LR : Register<CRYP_BASE + 0x48, ReadWrite, _IV1LR> {
        using IV95 = Field<_IV1LR, 0, 1>; // IV95
        using IV94 = Field<_IV1LR, 1, 1>; // IV94
        using IV93 = Field<_IV1LR, 2, 1>; // IV93
        using IV92 = Field<_IV1LR, 3, 1>; // IV92
        using IV91 = Field<_IV1LR, 4, 1>; // IV91
        using IV90 = Field<_IV1LR, 5, 1>; // IV90
        using IV89 = Field<_IV1LR, 6, 1>; // IV89
        using IV88 = Field<_IV1LR, 7, 1>; // IV88
        using IV87 = Field<_IV1LR, 8, 1>; // IV87
        using IV86 = Field<_IV1LR, 9, 1>; // IV86
        using IV85 = Field<_IV1LR, 10, 1>; // IV85
        using IV84 = Field<_IV1LR, 11, 1>; // IV84
        using IV83 = Field<_IV1LR, 12, 1>; // IV83
        using IV82 = Field<_IV1LR, 13, 1>; // IV82
        using IV81 = Field<_IV1LR, 14, 1>; // IV81
        using IV80 = Field<_IV1LR, 15, 1>; // IV80
        using IV79 = Field<_IV1LR, 16, 1>; // IV79
        using IV78 = Field<_IV1LR, 17, 1>; // IV78
        using IV77 = Field<_IV1LR, 18, 1>; // IV77
        using IV76 = Field<_IV1LR, 19, 1>; // IV76
        using IV75 = Field<_IV1LR, 20, 1>; // IV75
        using IV74 = Field<_IV1LR, 21, 1>; // IV74
        using IV73 = Field<_IV1LR, 22, 1>; // IV73
        using IV72 = Field<_IV1LR, 23, 1>; // IV72
        using IV71 = Field<_IV1LR, 24, 1>; // IV71
        using IV70 = Field<_IV1LR, 25, 1>; // IV70
        using IV69 = Field<_IV1LR, 26, 1>; // IV69
        using IV68 = Field<_IV1LR, 27, 1>; // IV68
        using IV67 = Field<_IV1LR, 28, 1>; // IV67
        using IV66 = Field<_IV1LR, 29, 1>; // IV66
        using IV65 = Field<_IV1LR, 30, 1>; // IV65
        using IV64 = Field<_IV1LR, 31, 1>; // IV64
    };

    // initialization vector registers
    struct _IV1RR : Register<CRYP_BASE + 0x4C, ReadWrite, _IV1RR> {
        using IV127 = Field<_IV1RR, 0, 1>; // IV127
        using IV126 = Field<_IV1RR, 1, 1>; // IV126
        using IV125 = Field<_IV1RR, 2, 1>; // IV125
        using IV124 = Field<_IV1RR, 3, 1>; // IV124
        using IV123 = Field<_IV1RR, 4, 1>; // IV123
        using IV122 = Field<_IV1RR, 5, 1>; // IV122
        using IV121 = Field<_IV1RR, 6, 1>; // IV121
        using IV120 = Field<_IV1RR, 7, 1>; // IV120
        using IV119 = Field<_IV1RR, 8, 1>; // IV119
        using IV118 = Field<_IV1RR, 9, 1>; // IV118
        using IV117 = Field<_IV1RR, 10, 1>; // IV117
        using IV116 = Field<_IV1RR, 11, 1>; // IV116
        using IV115 = Field<_IV1RR, 12, 1>; // IV115
        using IV114 = Field<_IV1RR, 13, 1>; // IV114
        using IV113 = Field<_IV1RR, 14, 1>; // IV113
        using IV112 = Field<_IV1RR, 15, 1>; // IV112
        using IV111 = Field<_IV1RR, 16, 1>; // IV111
        using IV110 = Field<_IV1RR, 17, 1>; // IV110
        using IV109 = Field<_IV1RR, 18, 1>; // IV109
        using IV108 = Field<_IV1RR, 19, 1>; // IV108
        using IV107 = Field<_IV1RR, 20, 1>; // IV107
        using IV106 = Field<_IV1RR, 21, 1>; // IV106
        using IV105 = Field<_IV1RR, 22, 1>; // IV105
        using IV104 = Field<_IV1RR, 23, 1>; // IV104
        using IV103 = Field<_IV1RR, 24, 1>; // IV103
        using IV102 = Field<_IV1RR, 25, 1>; // IV102
        using IV101 = Field<_IV1RR, 26, 1>; // IV101
        using IV100 = Field<_IV1RR, 27, 1>; // IV100
        using IV99 = Field<_IV1RR, 28, 1>; // IV99
        using IV98 = Field<_IV1RR, 29, 1>; // IV98
        using IV97 = Field<_IV1RR, 30, 1>; // IV97
        using IV96 = Field<_IV1RR, 31, 1>; // IV96
    };

    // context swap register
    struct _CSGCMCCM0R : Register<CRYP_BASE + 0x50, ReadWrite, _CSGCMCCM0R> {
        using CSGCMCCM0R = Field<_CSGCMCCM0R, 0, 32>; // CSGCMCCM0R
    };

    // context swap register
    struct _CSGCMCCM1R : Register<CRYP_BASE + 0x54, ReadWrite, _CSGCMCCM1R> {
        using CSGCMCCM1R = Field<_CSGCMCCM1R, 0, 32>; // CSGCMCCM1R
    };

    // context swap register
    struct _CSGCMCCM2R : Register<CRYP_BASE + 0x58, ReadWrite, _CSGCMCCM2R> {
        using CSGCMCCM2R = Field<_CSGCMCCM2R, 0, 32>; // CSGCMCCM2R
    };

    // context swap register
    struct _CSGCMCCM3R : Register<CRYP_BASE + 0x5C, ReadWrite, _CSGCMCCM3R> {
        using CSGCMCCM3R = Field<_CSGCMCCM3R, 0, 32>; // CSGCMCCM3R
    };

    // context swap register
    struct _CSGCMCCM4R : Register<CRYP_BASE + 0x60, ReadWrite, _CSGCMCCM4R> {
        using CSGCMCCM4R = Field<_CSGCMCCM4R, 0, 32>; // CSGCMCCM4R
    };

    // context swap register
    struct _CSGCMCCM5R : Register<CRYP_BASE + 0x64, ReadWrite, _CSGCMCCM5R> {
        using CSGCMCCM5R = Field<_CSGCMCCM5R, 0, 32>; // CSGCMCCM5R
    };

    // context swap register
    struct _CSGCMCCM6R : Register<CRYP_BASE + 0x68, ReadWrite, _CSGCMCCM6R> {
        using CSGCMCCM6R = Field<_CSGCMCCM6R, 0, 32>; // CSGCMCCM6R
    };

    // context swap register
    struct _CSGCMCCM7R : Register<CRYP_BASE + 0x6C, ReadWrite, _CSGCMCCM7R> {
        using CSGCMCCM7R = Field<_CSGCMCCM7R, 0, 32>; // CSGCMCCM7R
    };

    // context swap register
    struct _CSGCM0R : Register<CRYP_BASE + 0x70, ReadWrite, _CSGCM0R> {
        using CSGCM0R = Field<_CSGCM0R, 0, 32>; // CSGCM0R
    };

    // context swap register
    struct _CSGCM1R : Register<CRYP_BASE + 0x74, ReadWrite, _CSGCM1R> {
        using CSGCM1R = Field<_CSGCM1R, 0, 32>; // CSGCM1R
    };

    // context swap register
    struct _CSGCM2R : Register<CRYP_BASE + 0x78, ReadWrite, _CSGCM2R> {
        using CSGCM2R = Field<_CSGCM2R, 0, 32>; // CSGCM2R
    };

    // context swap register
    struct _CSGCM3R : Register<CRYP_BASE + 0x7C, ReadWrite, _CSGCM3R> {
        using CSGCM3R = Field<_CSGCM3R, 0, 32>; // CSGCM3R
    };

    // context swap register
    struct _CSGCM4R : Register<CRYP_BASE + 0x80, ReadWrite, _CSGCM4R> {
        using CSGCM4R = Field<_CSGCM4R, 0, 32>; // CSGCM4R
    };

    // context swap register
    struct _CSGCM5R : Register<CRYP_BASE + 0x84, ReadWrite, _CSGCM5R> {
        using CSGCM5R = Field<_CSGCM5R, 0, 32>; // CSGCM5R
    };

    // context swap register
    struct _CSGCM6R : Register<CRYP_BASE + 0x88, ReadWrite, _CSGCM6R> {
        using CSGCM6R = Field<_CSGCM6R, 0, 32>; // CSGCM6R
    };

    // context swap register
    struct _CSGCM7R : Register<CRYP_BASE + 0x8C, ReadWrite, _CSGCM7R> {
        using CSGCM7R = Field<_CSGCM7R, 0, 32>; // CSGCM7R
    };

} // namespace CRYP

// --------------------------------------------
// DCMI: Digital camera interface
// Base address: 0x50050000
// --------------------------------------------

namespace DCMI {
    static constexpr uint32_t DCMI_BASE = 0x50050000;

    // control register 1
    struct _CR : Register<DCMI_BASE + 0x0, ReadWrite, _CR> {
        using ENABLE = Field<_CR, 14, 1>; // DCMI enable
        using EDM = Field<_CR, 10, 2>; // Extended data mode
        using FCRC = Field<_CR, 8, 2>; // Frame capture rate control
        using VSPOL = Field<_CR, 7, 1>; // Vertical synchronization polarity
        using HSPOL = Field<_CR, 6, 1>; // Horizontal synchronization polarity
        using PCKPOL = Field<_CR, 5, 1>; // Pixel clock polarity
        using ESS = Field<_CR, 4, 1>; // Embedded synchronization select
        using JPEG = Field<_CR, 3, 1>; // JPEG format
        using CROP = Field<_CR, 2, 1>; // Crop feature
        using CM = Field<_CR, 1, 1>; // Capture mode
        using CAPTURE = Field<_CR, 0, 1>; // Capture enable
    };

    // status register
    struct _SR : Register<DCMI_BASE + 0x4, ReadOnly, _SR> {
        using FNE = Field<_SR, 2, 1>; // FIFO not empty
        using VSYNC = Field<_SR, 1, 1>; // VSYNC
        using HSYNC = Field<_SR, 0, 1>; // HSYNC
    };

    // raw interrupt status register
    struct _RIS : Register<DCMI_BASE + 0x8, ReadOnly, _RIS> {
        using LINE_RIS = Field<_RIS, 4, 1>; // Line raw interrupt status
        using VSYNC_RIS = Field<_RIS, 3, 1>; // VSYNC raw interrupt status
        using ERR_RIS = Field<_RIS, 2, 1>; // Synchronization error raw interrupt status
        using OVR_RIS = Field<_RIS, 1, 1>; // Overrun raw interrupt status
        using FRAME_RIS = Field<_RIS, 0, 1>; // Capture complete raw interrupt status
    };

    // interrupt enable register
    struct _IER : Register<DCMI_BASE + 0xC, ReadWrite, _IER> {
        using LINE_IE = Field<_IER, 4, 1>; // Line interrupt enable
        using VSYNC_IE = Field<_IER, 3, 1>; // VSYNC interrupt enable
        using ERR_IE = Field<_IER, 2, 1>; // Synchronization error interrupt enable
        using OVR_IE = Field<_IER, 1, 1>; // Overrun interrupt enable
        using FRAME_IE = Field<_IER, 0, 1>; // Capture complete interrupt enable
    };

    // masked interrupt status register
    struct _MIS : Register<DCMI_BASE + 0x10, ReadOnly, _MIS> {
        using LINE_MIS = Field<_MIS, 4, 1>; // Line masked interrupt status
        using VSYNC_MIS = Field<_MIS, 3, 1>; // VSYNC masked interrupt status
        using ERR_MIS = Field<_MIS, 2, 1>; // Synchronization error masked interrupt status
        using OVR_MIS = Field<_MIS, 1, 1>; // Overrun masked interrupt status
        using FRAME_MIS = Field<_MIS, 0, 1>; // Capture complete masked interrupt status
    };

    // interrupt clear register
    struct _ICR : Register<DCMI_BASE + 0x14, WriteOnly, _ICR> {
        using LINE_ISC = Field<_ICR, 4, 1>; // line interrupt status clear
        using VSYNC_ISC = Field<_ICR, 3, 1>; // Vertical synch interrupt status clear
        using ERR_ISC = Field<_ICR, 2, 1>; // Synchronization error interrupt status clear
        using OVR_ISC = Field<_ICR, 1, 1>; // Overrun interrupt status clear
        using FRAME_ISC = Field<_ICR, 0, 1>; // Capture complete interrupt status clear
    };

    // embedded synchronization code register
    struct _ESCR : Register<DCMI_BASE + 0x18, ReadWrite, _ESCR> {
        using FEC = Field<_ESCR, 24, 8>; // Frame end delimiter code
        using LEC = Field<_ESCR, 16, 8>; // Line end delimiter code
        using LSC = Field<_ESCR, 8, 8>; // Line start delimiter code
        using FSC = Field<_ESCR, 0, 8>; // Frame start delimiter code
    };

    // embedded synchronization unmask register
    struct _ESUR : Register<DCMI_BASE + 0x1C, ReadWrite, _ESUR> {
        using FEU = Field<_ESUR, 24, 8>; // Frame end delimiter unmask
        using LEU = Field<_ESUR, 16, 8>; // Line end delimiter unmask
        using LSU = Field<_ESUR, 8, 8>; // Line start delimiter unmask
        using FSU = Field<_ESUR, 0, 8>; // Frame start delimiter unmask
    };

    // crop window start
    struct _CWSTRT : Register<DCMI_BASE + 0x20, ReadWrite, _CWSTRT> {
        using VST = Field<_CWSTRT, 16, 13>; // Vertical start line count
        using HOFFCNT = Field<_CWSTRT, 0, 14>; // Horizontal offset count
    };

    // crop window size
    struct _CWSIZE : Register<DCMI_BASE + 0x24, ReadWrite, _CWSIZE> {
        using VLINE = Field<_CWSIZE, 16, 14>; // Vertical line count
        using CAPCNT = Field<_CWSIZE, 0, 14>; // Capture count
    };

    // data register
    struct _DR : Register<DCMI_BASE + 0x28, ReadOnly, _DR> {
        using Byte3 = Field<_DR, 24, 8>; // Data byte 3
        using Byte2 = Field<_DR, 16, 8>; // Data byte 2
        using Byte1 = Field<_DR, 8, 8>; // Data byte 1
        using Byte0 = Field<_DR, 0, 8>; // Data byte 0
    };

} // namespace DCMI

// --------------------------------------------
// FMC: Flexible memory controller
// Base address: 0xA0000000
// --------------------------------------------

namespace FMC {
    static constexpr uint32_t FMC_BASE = 0xA0000000;

    // SRAM/NOR-Flash chip-select control register 1
    struct _BCR1 : Register<FMC_BASE + 0x0, ReadWrite, _BCR1> {
        using CCLKEN = Field<_BCR1, 20, 1>; // CCLKEN
        using CBURSTRW = Field<_BCR1, 19, 1>; // CBURSTRW
        using ASYNCWAIT = Field<_BCR1, 15, 1>; // ASYNCWAIT
        using EXTMOD = Field<_BCR1, 14, 1>; // EXTMOD
        using WAITEN = Field<_BCR1, 13, 1>; // WAITEN
        using WREN = Field<_BCR1, 12, 1>; // WREN
        using WAITCFG = Field<_BCR1, 11, 1>; // WAITCFG
        using WAITPOL = Field<_BCR1, 9, 1>; // WAITPOL
        using BURSTEN = Field<_BCR1, 8, 1>; // BURSTEN
        using FACCEN = Field<_BCR1, 6, 1>; // FACCEN
        using MWID = Field<_BCR1, 4, 2>; // MWID
        using MTYP = Field<_BCR1, 2, 2>; // MTYP
        using MUXEN = Field<_BCR1, 1, 1>; // MUXEN
        using MBKEN = Field<_BCR1, 0, 1>; // MBKEN
    };

    // SRAM/NOR-Flash chip-select timing register 1
    struct _BTR1 : Register<FMC_BASE + 0x4, ReadWrite, _BTR1> {
        using ACCMOD = Field<_BTR1, 28, 2>; // ACCMOD
        using DATLAT = Field<_BTR1, 24, 4>; // DATLAT
        using CLKDIV = Field<_BTR1, 20, 4>; // CLKDIV
        using BUSTURN = Field<_BTR1, 16, 4>; // BUSTURN
        using DATAST = Field<_BTR1, 8, 8>; // DATAST
        using ADDHLD = Field<_BTR1, 4, 4>; // ADDHLD
        using ADDSET = Field<_BTR1, 0, 4>; // ADDSET
    };

    // SRAM/NOR-Flash chip-select control register 2
    struct _BCR2 : Register<FMC_BASE + 0x8, ReadWrite, _BCR2> {
        using CBURSTRW = Field<_BCR2, 19, 1>; // CBURSTRW
        using ASYNCWAIT = Field<_BCR2, 15, 1>; // ASYNCWAIT
        using EXTMOD = Field<_BCR2, 14, 1>; // EXTMOD
        using WAITEN = Field<_BCR2, 13, 1>; // WAITEN
        using WREN = Field<_BCR2, 12, 1>; // WREN
        using WAITCFG = Field<_BCR2, 11, 1>; // WAITCFG
        using WRAPMOD = Field<_BCR2, 10, 1>; // WRAPMOD
        using WAITPOL = Field<_BCR2, 9, 1>; // WAITPOL
        using BURSTEN = Field<_BCR2, 8, 1>; // BURSTEN
        using FACCEN = Field<_BCR2, 6, 1>; // FACCEN
        using MWID = Field<_BCR2, 4, 2>; // MWID
        using MTYP = Field<_BCR2, 2, 2>; // MTYP
        using MUXEN = Field<_BCR2, 1, 1>; // MUXEN
        using MBKEN = Field<_BCR2, 0, 1>; // MBKEN
    };

    // SRAM/NOR-Flash chip-select timing register 2
    struct _BTR2 : Register<FMC_BASE + 0xC, ReadWrite, _BTR2> {
        using ACCMOD = Field<_BTR2, 28, 2>; // ACCMOD
        using DATLAT = Field<_BTR2, 24, 4>; // DATLAT
        using CLKDIV = Field<_BTR2, 20, 4>; // CLKDIV
        using BUSTURN = Field<_BTR2, 16, 4>; // BUSTURN
        using DATAST = Field<_BTR2, 8, 8>; // DATAST
        using ADDHLD = Field<_BTR2, 4, 4>; // ADDHLD
        using ADDSET = Field<_BTR2, 0, 4>; // ADDSET
    };

    // SRAM/NOR-Flash chip-select control register 3
    struct _BCR3 : Register<FMC_BASE + 0x10, ReadWrite, _BCR3> {
        using CBURSTRW = Field<_BCR3, 19, 1>; // CBURSTRW
        using ASYNCWAIT = Field<_BCR3, 15, 1>; // ASYNCWAIT
        using EXTMOD = Field<_BCR3, 14, 1>; // EXTMOD
        using WAITEN = Field<_BCR3, 13, 1>; // WAITEN
        using WREN = Field<_BCR3, 12, 1>; // WREN
        using WAITCFG = Field<_BCR3, 11, 1>; // WAITCFG
        using WRAPMOD = Field<_BCR3, 10, 1>; // WRAPMOD
        using WAITPOL = Field<_BCR3, 9, 1>; // WAITPOL
        using BURSTEN = Field<_BCR3, 8, 1>; // BURSTEN
        using FACCEN = Field<_BCR3, 6, 1>; // FACCEN
        using MWID = Field<_BCR3, 4, 2>; // MWID
        using MTYP = Field<_BCR3, 2, 2>; // MTYP
        using MUXEN = Field<_BCR3, 1, 1>; // MUXEN
        using MBKEN = Field<_BCR3, 0, 1>; // MBKEN
    };

    // SRAM/NOR-Flash chip-select timing register 3
    struct _BTR3 : Register<FMC_BASE + 0x14, ReadWrite, _BTR3> {
        using ACCMOD = Field<_BTR3, 28, 2>; // ACCMOD
        using DATLAT = Field<_BTR3, 24, 4>; // DATLAT
        using CLKDIV = Field<_BTR3, 20, 4>; // CLKDIV
        using BUSTURN = Field<_BTR3, 16, 4>; // BUSTURN
        using DATAST = Field<_BTR3, 8, 8>; // DATAST
        using ADDHLD = Field<_BTR3, 4, 4>; // ADDHLD
        using ADDSET = Field<_BTR3, 0, 4>; // ADDSET
    };

    // SRAM/NOR-Flash chip-select control register 4
    struct _BCR4 : Register<FMC_BASE + 0x18, ReadWrite, _BCR4> {
        using CBURSTRW = Field<_BCR4, 19, 1>; // CBURSTRW
        using ASYNCWAIT = Field<_BCR4, 15, 1>; // ASYNCWAIT
        using EXTMOD = Field<_BCR4, 14, 1>; // EXTMOD
        using WAITEN = Field<_BCR4, 13, 1>; // WAITEN
        using WREN = Field<_BCR4, 12, 1>; // WREN
        using WAITCFG = Field<_BCR4, 11, 1>; // WAITCFG
        using WRAPMOD = Field<_BCR4, 10, 1>; // WRAPMOD
        using WAITPOL = Field<_BCR4, 9, 1>; // WAITPOL
        using BURSTEN = Field<_BCR4, 8, 1>; // BURSTEN
        using FACCEN = Field<_BCR4, 6, 1>; // FACCEN
        using MWID = Field<_BCR4, 4, 2>; // MWID
        using MTYP = Field<_BCR4, 2, 2>; // MTYP
        using MUXEN = Field<_BCR4, 1, 1>; // MUXEN
        using MBKEN = Field<_BCR4, 0, 1>; // MBKEN
    };

    // SRAM/NOR-Flash chip-select timing register 4
    struct _BTR4 : Register<FMC_BASE + 0x1C, ReadWrite, _BTR4> {
        using ACCMOD = Field<_BTR4, 28, 2>; // ACCMOD
        using DATLAT = Field<_BTR4, 24, 4>; // DATLAT
        using CLKDIV = Field<_BTR4, 20, 4>; // CLKDIV
        using BUSTURN = Field<_BTR4, 16, 4>; // BUSTURN
        using DATAST = Field<_BTR4, 8, 8>; // DATAST
        using ADDHLD = Field<_BTR4, 4, 4>; // ADDHLD
        using ADDSET = Field<_BTR4, 0, 4>; // ADDSET
    };

    // PC Card/NAND Flash control register
    struct _PCR : Register<FMC_BASE + 0x80, ReadWrite, _PCR> {
        using ECCPS = Field<_PCR, 17, 3>; // ECCPS
        using TAR = Field<_PCR, 13, 4>; // TAR
        using TCLR = Field<_PCR, 9, 4>; // TCLR
        using ECCEN = Field<_PCR, 6, 1>; // ECCEN
        using PWID = Field<_PCR, 4, 2>; // PWID
        using PTYP = Field<_PCR, 3, 1>; // PTYP
        using PBKEN = Field<_PCR, 2, 1>; // PBKEN
        using PWAITEN = Field<_PCR, 1, 1>; // PWAITEN
    };

    // FIFO status and interrupt register
    struct _SR : Register<FMC_BASE + 0x84, ReadWrite, _SR> {
        using FEMPT = Field<_SR, 6, 1>; // FEMPT
        using IFEN = Field<_SR, 5, 1>; // IFEN
        using ILEN = Field<_SR, 4, 1>; // ILEN
        using IREN = Field<_SR, 3, 1>; // IREN
        using IFS = Field<_SR, 2, 1>; // IFS
        using ILS = Field<_SR, 1, 1>; // ILS
        using IRS = Field<_SR, 0, 1>; // IRS
    };

    // Common memory space timing register
    struct _PMEM : Register<FMC_BASE + 0x88, ReadWrite, _PMEM> {
        using MEMHIZx = Field<_PMEM, 24, 8>; // MEMHIZx
        using MEMHOLDx = Field<_PMEM, 16, 8>; // MEMHOLDx
        using MEMWAITx = Field<_PMEM, 8, 8>; // MEMWAITx
        using MEMSETx = Field<_PMEM, 0, 8>; // MEMSETx
    };

    // Attribute memory space timing register
    struct _PATT : Register<FMC_BASE + 0x8C, ReadWrite, _PATT> {
        using ATTHIZx = Field<_PATT, 24, 8>; // ATTHIZx
        using ATTHOLDx = Field<_PATT, 16, 8>; // ATTHOLDx
        using ATTWAITx = Field<_PATT, 8, 8>; // ATTWAITx
        using ATTSETx = Field<_PATT, 0, 8>; // ATTSETx
    };

    // ECC result register
    struct _ECCR : Register<FMC_BASE + 0x94, ReadOnly, _ECCR> {
        using ECCx = Field<_ECCR, 0, 32>; // ECCx
    };

    // SRAM/NOR-Flash write timing registers 1
    struct _BWTR1 : Register<FMC_BASE + 0x104, ReadWrite, _BWTR1> {
        using ACCMOD = Field<_BWTR1, 28, 2>; // ACCMOD
        using DATLAT = Field<_BWTR1, 24, 4>; // DATLAT
        using CLKDIV = Field<_BWTR1, 20, 4>; // CLKDIV
        using DATAST = Field<_BWTR1, 8, 8>; // DATAST
        using ADDHLD = Field<_BWTR1, 4, 4>; // ADDHLD
        using ADDSET = Field<_BWTR1, 0, 4>; // ADDSET
    };

    // SRAM/NOR-Flash write timing registers 2
    struct _BWTR2 : Register<FMC_BASE + 0x10C, ReadWrite, _BWTR2> {
        using ACCMOD = Field<_BWTR2, 28, 2>; // ACCMOD
        using DATLAT = Field<_BWTR2, 24, 4>; // DATLAT
        using CLKDIV = Field<_BWTR2, 20, 4>; // CLKDIV
        using DATAST = Field<_BWTR2, 8, 8>; // DATAST
        using ADDHLD = Field<_BWTR2, 4, 4>; // ADDHLD
        using ADDSET = Field<_BWTR2, 0, 4>; // ADDSET
    };

    // SRAM/NOR-Flash write timing registers 3
    struct _BWTR3 : Register<FMC_BASE + 0x114, ReadWrite, _BWTR3> {
        using ACCMOD = Field<_BWTR3, 28, 2>; // ACCMOD
        using DATLAT = Field<_BWTR3, 24, 4>; // DATLAT
        using CLKDIV = Field<_BWTR3, 20, 4>; // CLKDIV
        using DATAST = Field<_BWTR3, 8, 8>; // DATAST
        using ADDHLD = Field<_BWTR3, 4, 4>; // ADDHLD
        using ADDSET = Field<_BWTR3, 0, 4>; // ADDSET
    };

    // SRAM/NOR-Flash write timing registers 4
    struct _BWTR4 : Register<FMC_BASE + 0x11C, ReadWrite, _BWTR4> {
        using ACCMOD = Field<_BWTR4, 28, 2>; // ACCMOD
        using DATLAT = Field<_BWTR4, 24, 4>; // DATLAT
        using CLKDIV = Field<_BWTR4, 20, 4>; // CLKDIV
        using DATAST = Field<_BWTR4, 8, 8>; // DATAST
        using ADDHLD = Field<_BWTR4, 4, 4>; // ADDHLD
        using ADDSET = Field<_BWTR4, 0, 4>; // ADDSET
    };

    // SDRAM Control Register 1
    struct _SDCR1 : Register<FMC_BASE + 0x140, ReadWrite, _SDCR1> {
        using NC = Field<_SDCR1, 0, 2>; // Number of column address bits
        using NR = Field<_SDCR1, 2, 2>; // Number of row address bits
        using MWID = Field<_SDCR1, 4, 2>; // Memory data bus width
        using NB = Field<_SDCR1, 6, 1>; // Number of internal banks
        using CAS = Field<_SDCR1, 7, 2>; // CAS latency
        using WP = Field<_SDCR1, 9, 1>; // Write protection
        using SDCLK = Field<_SDCR1, 10, 2>; // SDRAM clock configuration
        using RBURST = Field<_SDCR1, 12, 1>; // Burst read
        using RPIPE = Field<_SDCR1, 13, 2>; // Read pipe
    };

    // SDRAM Control Register 2
    struct _SDCR2 : Register<FMC_BASE + 0x144, ReadWrite, _SDCR2> {
        using NC = Field<_SDCR2, 0, 2>; // Number of column address bits
        using NR = Field<_SDCR2, 2, 2>; // Number of row address bits
        using MWID = Field<_SDCR2, 4, 2>; // Memory data bus width
        using NB = Field<_SDCR2, 6, 1>; // Number of internal banks
        using CAS = Field<_SDCR2, 7, 2>; // CAS latency
        using WP = Field<_SDCR2, 9, 1>; // Write protection
        using SDCLK = Field<_SDCR2, 10, 2>; // SDRAM clock configuration
        using RBURST = Field<_SDCR2, 12, 1>; // Burst read
        using RPIPE = Field<_SDCR2, 13, 2>; // Read pipe
    };

    // SDRAM Timing register 1
    struct _SDTR1 : Register<FMC_BASE + 0x148, ReadWrite, _SDTR1> {
        using TMRD = Field<_SDTR1, 0, 4>; // Load Mode Register to Active
        using TXSR = Field<_SDTR1, 4, 4>; // Exit self-refresh delay
        using TRAS = Field<_SDTR1, 8, 4>; // Self refresh time
        using TRC = Field<_SDTR1, 12, 4>; // Row cycle delay
        using TWR = Field<_SDTR1, 16, 4>; // Recovery delay
        using TRP = Field<_SDTR1, 20, 4>; // Row precharge delay
        using TRCD = Field<_SDTR1, 24, 4>; // Row to column delay
    };

    // SDRAM Timing register 2
    struct _SDTR2 : Register<FMC_BASE + 0x14C, ReadWrite, _SDTR2> {
        using TMRD = Field<_SDTR2, 0, 4>; // Load Mode Register to Active
        using TXSR = Field<_SDTR2, 4, 4>; // Exit self-refresh delay
        using TRAS = Field<_SDTR2, 8, 4>; // Self refresh time
        using TRC = Field<_SDTR2, 12, 4>; // Row cycle delay
        using TWR = Field<_SDTR2, 16, 4>; // Recovery delay
        using TRP = Field<_SDTR2, 20, 4>; // Row precharge delay
        using TRCD = Field<_SDTR2, 24, 4>; // Row to column delay
    };

    // SDRAM Command Mode register
    struct _SDCMR : Register<FMC_BASE + 0x150, ReadWrite, _SDCMR> {
        using MODE = Field<_SDCMR, 0, 3>; // Command mode
        using CTB2 = Field<_SDCMR, 3, 1>; // Command target bank 2
        using CTB1 = Field<_SDCMR, 4, 1>; // Command target bank 1
        using NRFS = Field<_SDCMR, 5, 4>; // Number of Auto-refresh
        using MRD = Field<_SDCMR, 9, 13>; // Mode Register definition
    };

    // SDRAM Refresh Timer register
    struct _SDRTR : Register<FMC_BASE + 0x154, ReadWrite, _SDRTR> {
        using CRE = Field<_SDRTR, 0, 1>; // Clear Refresh error flag
        using COUNT = Field<_SDRTR, 1, 13>; // Refresh Timer Count
        using REIE = Field<_SDRTR, 14, 1>; // RES Interrupt Enable
    };

    // SDRAM Status register
    struct _SDSR : Register<FMC_BASE + 0x158, ReadOnly, _SDSR> {
        using RE = Field<_SDSR, 0, 1>; // Refresh error flag
        using MODES1 = Field<_SDSR, 1, 2>; // Status Mode for Bank 1
        using MODES2 = Field<_SDSR, 3, 2>; // Status Mode for Bank 2
        using BUSY = Field<_SDSR, 5, 1>; // Busy status
    };

} // namespace FMC

// --------------------------------------------
// DMA2: DMA controller
// Base address: 0x40026400
// --------------------------------------------

namespace DMA2 {
    static constexpr uint32_t DMA2_BASE = 0x40026400;

    // low interrupt status register
    struct _LISR : Register<DMA2_BASE + 0x0, ReadOnly, _LISR> {
        using TCIF3 = Field<_LISR, 27, 1>; // Stream x transfer complete interrupt flag (x = 3..0)
        using HTIF3 = Field<_LISR, 26, 1>; // Stream x half transfer interrupt flag (x=3..0)
        using TEIF3 = Field<_LISR, 25, 1>; // Stream x transfer error interrupt flag (x=3..0)
        using DMEIF3 = Field<_LISR, 24, 1>; // Stream x direct mode error interrupt flag (x=3..0)
        using FEIF3 = Field<_LISR, 22, 1>; // Stream x FIFO error interrupt flag (x=3..0)
        using TCIF2 = Field<_LISR, 21, 1>; // Stream x transfer complete interrupt flag (x = 3..0)
        using HTIF2 = Field<_LISR, 20, 1>; // Stream x half transfer interrupt flag (x=3..0)
        using TEIF2 = Field<_LISR, 19, 1>; // Stream x transfer error interrupt flag (x=3..0)
        using DMEIF2 = Field<_LISR, 18, 1>; // Stream x direct mode error interrupt flag (x=3..0)
        using FEIF2 = Field<_LISR, 16, 1>; // Stream x FIFO error interrupt flag (x=3..0)
        using TCIF1 = Field<_LISR, 11, 1>; // Stream x transfer complete interrupt flag (x = 3..0)
        using HTIF1 = Field<_LISR, 10, 1>; // Stream x half transfer interrupt flag (x=3..0)
        using TEIF1 = Field<_LISR, 9, 1>; // Stream x transfer error interrupt flag (x=3..0)
        using DMEIF1 = Field<_LISR, 8, 1>; // Stream x direct mode error interrupt flag (x=3..0)
        using FEIF1 = Field<_LISR, 6, 1>; // Stream x FIFO error interrupt flag (x=3..0)
        using TCIF0 = Field<_LISR, 5, 1>; // Stream x transfer complete interrupt flag (x = 3..0)
        using HTIF0 = Field<_LISR, 4, 1>; // Stream x half transfer interrupt flag (x=3..0)
        using TEIF0 = Field<_LISR, 3, 1>; // Stream x transfer error interrupt flag (x=3..0)
        using DMEIF0 = Field<_LISR, 2, 1>; // Stream x direct mode error interrupt flag (x=3..0)
        using FEIF0 = Field<_LISR, 0, 1>; // Stream x FIFO error interrupt flag (x=3..0)
    };

    // high interrupt status register
    struct _HISR : Register<DMA2_BASE + 0x4, ReadOnly, _HISR> {
        using TCIF7 = Field<_HISR, 27, 1>; // Stream x transfer complete interrupt flag (x=7..4)
        using HTIF7 = Field<_HISR, 26, 1>; // Stream x half transfer interrupt flag (x=7..4)
        using TEIF7 = Field<_HISR, 25, 1>; // Stream x transfer error interrupt flag (x=7..4)
        using DMEIF7 = Field<_HISR, 24, 1>; // Stream x direct mode error interrupt flag (x=7..4)
        using FEIF7 = Field<_HISR, 22, 1>; // Stream x FIFO error interrupt flag (x=7..4)
        using TCIF6 = Field<_HISR, 21, 1>; // Stream x transfer complete interrupt flag (x=7..4)
        using HTIF6 = Field<_HISR, 20, 1>; // Stream x half transfer interrupt flag (x=7..4)
        using TEIF6 = Field<_HISR, 19, 1>; // Stream x transfer error interrupt flag (x=7..4)
        using DMEIF6 = Field<_HISR, 18, 1>; // Stream x direct mode error interrupt flag (x=7..4)
        using FEIF6 = Field<_HISR, 16, 1>; // Stream x FIFO error interrupt flag (x=7..4)
        using TCIF5 = Field<_HISR, 11, 1>; // Stream x transfer complete interrupt flag (x=7..4)
        using HTIF5 = Field<_HISR, 10, 1>; // Stream x half transfer interrupt flag (x=7..4)
        using TEIF5 = Field<_HISR, 9, 1>; // Stream x transfer error interrupt flag (x=7..4)
        using DMEIF5 = Field<_HISR, 8, 1>; // Stream x direct mode error interrupt flag (x=7..4)
        using FEIF5 = Field<_HISR, 6, 1>; // Stream x FIFO error interrupt flag (x=7..4)
        using TCIF4 = Field<_HISR, 5, 1>; // Stream x transfer complete interrupt flag (x=7..4)
        using HTIF4 = Field<_HISR, 4, 1>; // Stream x half transfer interrupt flag (x=7..4)
        using TEIF4 = Field<_HISR, 3, 1>; // Stream x transfer error interrupt flag (x=7..4)
        using DMEIF4 = Field<_HISR, 2, 1>; // Stream x direct mode error interrupt flag (x=7..4)
        using FEIF4 = Field<_HISR, 0, 1>; // Stream x FIFO error interrupt flag (x=7..4)
    };

    // low interrupt flag clear register
    struct _LIFCR : Register<DMA2_BASE + 0x8, ReadWrite, _LIFCR> {
        using CTCIF3 = Field<_LIFCR, 27, 1>; // Stream x clear transfer complete interrupt flag (x = 3..0)
        using CHTIF3 = Field<_LIFCR, 26, 1>; // Stream x clear half transfer interrupt flag (x = 3..0)
        using CTEIF3 = Field<_LIFCR, 25, 1>; // Stream x clear transfer error interrupt flag (x = 3..0)
        using CDMEIF3 = Field<_LIFCR, 24, 1>; // Stream x clear direct mode error interrupt flag (x = 3..0)
        using CFEIF3 = Field<_LIFCR, 22, 1>; // Stream x clear FIFO error interrupt flag (x = 3..0)
        using CTCIF2 = Field<_LIFCR, 21, 1>; // Stream x clear transfer complete interrupt flag (x = 3..0)
        using CHTIF2 = Field<_LIFCR, 20, 1>; // Stream x clear half transfer interrupt flag (x = 3..0)
        using CTEIF2 = Field<_LIFCR, 19, 1>; // Stream x clear transfer error interrupt flag (x = 3..0)
        using CDMEIF2 = Field<_LIFCR, 18, 1>; // Stream x clear direct mode error interrupt flag (x = 3..0)
        using CFEIF2 = Field<_LIFCR, 16, 1>; // Stream x clear FIFO error interrupt flag (x = 3..0)
        using CTCIF1 = Field<_LIFCR, 11, 1>; // Stream x clear transfer complete interrupt flag (x = 3..0)
        using CHTIF1 = Field<_LIFCR, 10, 1>; // Stream x clear half transfer interrupt flag (x = 3..0)
        using CTEIF1 = Field<_LIFCR, 9, 1>; // Stream x clear transfer error interrupt flag (x = 3..0)
        using CDMEIF1 = Field<_LIFCR, 8, 1>; // Stream x clear direct mode error interrupt flag (x = 3..0)
        using CFEIF1 = Field<_LIFCR, 6, 1>; // Stream x clear FIFO error interrupt flag (x = 3..0)
        using CTCIF0 = Field<_LIFCR, 5, 1>; // Stream x clear transfer complete interrupt flag (x = 3..0)
        using CHTIF0 = Field<_LIFCR, 4, 1>; // Stream x clear half transfer interrupt flag (x = 3..0)
        using CTEIF0 = Field<_LIFCR, 3, 1>; // Stream x clear transfer error interrupt flag (x = 3..0)
        using CDMEIF0 = Field<_LIFCR, 2, 1>; // Stream x clear direct mode error interrupt flag (x = 3..0)
        using CFEIF0 = Field<_LIFCR, 0, 1>; // Stream x clear FIFO error interrupt flag (x = 3..0)
    };

    // high interrupt flag clear register
    struct _HIFCR : Register<DMA2_BASE + 0xC, ReadWrite, _HIFCR> {
        using CTCIF7 = Field<_HIFCR, 27, 1>; // Stream x clear transfer complete interrupt flag (x = 7..4)
        using CHTIF7 = Field<_HIFCR, 26, 1>; // Stream x clear half transfer interrupt flag (x = 7..4)
        using CTEIF7 = Field<_HIFCR, 25, 1>; // Stream x clear transfer error interrupt flag (x = 7..4)
        using CDMEIF7 = Field<_HIFCR, 24, 1>; // Stream x clear direct mode error interrupt flag (x = 7..4)
        using CFEIF7 = Field<_HIFCR, 22, 1>; // Stream x clear FIFO error interrupt flag (x = 7..4)
        using CTCIF6 = Field<_HIFCR, 21, 1>; // Stream x clear transfer complete interrupt flag (x = 7..4)
        using CHTIF6 = Field<_HIFCR, 20, 1>; // Stream x clear half transfer interrupt flag (x = 7..4)
        using CTEIF6 = Field<_HIFCR, 19, 1>; // Stream x clear transfer error interrupt flag (x = 7..4)
        using CDMEIF6 = Field<_HIFCR, 18, 1>; // Stream x clear direct mode error interrupt flag (x = 7..4)
        using CFEIF6 = Field<_HIFCR, 16, 1>; // Stream x clear FIFO error interrupt flag (x = 7..4)
        using CTCIF5 = Field<_HIFCR, 11, 1>; // Stream x clear transfer complete interrupt flag (x = 7..4)
        using CHTIF5 = Field<_HIFCR, 10, 1>; // Stream x clear half transfer interrupt flag (x = 7..4)
        using CTEIF5 = Field<_HIFCR, 9, 1>; // Stream x clear transfer error interrupt flag (x = 7..4)
        using CDMEIF5 = Field<_HIFCR, 8, 1>; // Stream x clear direct mode error interrupt flag (x = 7..4)
        using CFEIF5 = Field<_HIFCR, 6, 1>; // Stream x clear FIFO error interrupt flag (x = 7..4)
        using CTCIF4 = Field<_HIFCR, 5, 1>; // Stream x clear transfer complete interrupt flag (x = 7..4)
        using CHTIF4 = Field<_HIFCR, 4, 1>; // Stream x clear half transfer interrupt flag (x = 7..4)
        using CTEIF4 = Field<_HIFCR, 3, 1>; // Stream x clear transfer error interrupt flag (x = 7..4)
        using CDMEIF4 = Field<_HIFCR, 2, 1>; // Stream x clear direct mode error interrupt flag (x = 7..4)
        using CFEIF4 = Field<_HIFCR, 0, 1>; // Stream x clear FIFO error interrupt flag (x = 7..4)
    };

    // stream x configuration register
    struct _S0CR : Register<DMA2_BASE + 0x10, ReadWrite, _S0CR> {
        using CHSEL = Field<_S0CR, 25, 4>; // Channel selection
        using MBURST = Field<_S0CR, 23, 2>; // Memory burst transfer configuration
        using PBURST = Field<_S0CR, 21, 2>; // Peripheral burst transfer configuration
        using CT = Field<_S0CR, 19, 1>; // Current target (only in double buffer mode)
        using DBM = Field<_S0CR, 18, 1>; // Double buffer mode
        using PL = Field<_S0CR, 16, 2>; // Priority level
        using PINCOS = Field<_S0CR, 15, 1>; // Peripheral increment offset size
        using MSIZE = Field<_S0CR, 13, 2>; // Memory data size
        using PSIZE = Field<_S0CR, 11, 2>; // Peripheral data size
        using MINC = Field<_S0CR, 10, 1>; // Memory increment mode
        using PINC = Field<_S0CR, 9, 1>; // Peripheral increment mode
        using CIRC = Field<_S0CR, 8, 1>; // Circular mode
        using DIR = Field<_S0CR, 6, 2>; // Data transfer direction
        using PFCTRL = Field<_S0CR, 5, 1>; // Peripheral flow controller
        using TCIE = Field<_S0CR, 4, 1>; // Transfer complete interrupt enable
        using HTIE = Field<_S0CR, 3, 1>; // Half transfer interrupt enable
        using TEIE = Field<_S0CR, 2, 1>; // Transfer error interrupt enable
        using DMEIE = Field<_S0CR, 1, 1>; // Direct mode error interrupt enable
        using EN = Field<_S0CR, 0, 1>; // Stream enable / flag stream ready when read low
    };

    // stream x number of data register
    struct _S0NDTR : Register<DMA2_BASE + 0x14, ReadWrite, _S0NDTR> {
        using NDT = Field<_S0NDTR, 0, 16>; // Number of data items to transfer
    };

    // stream x peripheral address register
    struct _S0PAR : Register<DMA2_BASE + 0x18, ReadWrite, _S0PAR> {
        using PA = Field<_S0PAR, 0, 32>; // Peripheral address
    };

    // stream x memory 0 address register
    struct _S0M0AR : Register<DMA2_BASE + 0x1C, ReadWrite, _S0M0AR> {
        using M0A = Field<_S0M0AR, 0, 32>; // Memory 0 address
    };

    // stream x memory 1 address register
    struct _S0M1AR : Register<DMA2_BASE + 0x20, ReadWrite, _S0M1AR> {
        using M1A = Field<_S0M1AR, 0, 32>; // Memory 1 address (used in case of Double buffer mode)
    };

    // stream x FIFO control register
    struct _S0FCR : Register<DMA2_BASE + 0x24, ReadWrite, _S0FCR> {
        using FEIE = Field<_S0FCR, 7, 1>; // FIFO error interrupt enable
        using FS = Field<_S0FCR, 3, 3>; // FIFO status
        using DMDIS = Field<_S0FCR, 2, 1>; // Direct mode disable
        using FTH = Field<_S0FCR, 0, 2>; // FIFO threshold selection
    };

    // stream x configuration register
    struct _S1CR : Register<DMA2_BASE + 0x28, ReadWrite, _S1CR> {
        using CHSEL = Field<_S1CR, 25, 4>; // Channel selection
        using MBURST = Field<_S1CR, 23, 2>; // Memory burst transfer configuration
        using PBURST = Field<_S1CR, 21, 2>; // Peripheral burst transfer configuration
        using ACK = Field<_S1CR, 20, 1>; // ACK
        using CT = Field<_S1CR, 19, 1>; // Current target (only in double buffer mode)
        using DBM = Field<_S1CR, 18, 1>; // Double buffer mode
        using PL = Field<_S1CR, 16, 2>; // Priority level
        using PINCOS = Field<_S1CR, 15, 1>; // Peripheral increment offset size
        using MSIZE = Field<_S1CR, 13, 2>; // Memory data size
        using PSIZE = Field<_S1CR, 11, 2>; // Peripheral data size
        using MINC = Field<_S1CR, 10, 1>; // Memory increment mode
        using PINC = Field<_S1CR, 9, 1>; // Peripheral increment mode
        using CIRC = Field<_S1CR, 8, 1>; // Circular mode
        using DIR = Field<_S1CR, 6, 2>; // Data transfer direction
        using PFCTRL = Field<_S1CR, 5, 1>; // Peripheral flow controller
        using TCIE = Field<_S1CR, 4, 1>; // Transfer complete interrupt enable
        using HTIE = Field<_S1CR, 3, 1>; // Half transfer interrupt enable
        using TEIE = Field<_S1CR, 2, 1>; // Transfer error interrupt enable
        using DMEIE = Field<_S1CR, 1, 1>; // Direct mode error interrupt enable
        using EN = Field<_S1CR, 0, 1>; // Stream enable / flag stream ready when read low
    };

    // stream x number of data register
    struct _S1NDTR : Register<DMA2_BASE + 0x2C, ReadWrite, _S1NDTR> {
        using NDT = Field<_S1NDTR, 0, 16>; // Number of data items to transfer
    };

    // stream x peripheral address register
    struct _S1PAR : Register<DMA2_BASE + 0x30, ReadWrite, _S1PAR> {
        using PA = Field<_S1PAR, 0, 32>; // Peripheral address
    };

    // stream x memory 0 address register
    struct _S1M0AR : Register<DMA2_BASE + 0x34, ReadWrite, _S1M0AR> {
        using M0A = Field<_S1M0AR, 0, 32>; // Memory 0 address
    };

    // stream x memory 1 address register
    struct _S1M1AR : Register<DMA2_BASE + 0x38, ReadWrite, _S1M1AR> {
        using M1A = Field<_S1M1AR, 0, 32>; // Memory 1 address (used in case of Double buffer mode)
    };

    // stream x FIFO control register
    struct _S1FCR : Register<DMA2_BASE + 0x3C, ReadWrite, _S1FCR> {
        using FEIE = Field<_S1FCR, 7, 1>; // FIFO error interrupt enable
        using FS = Field<_S1FCR, 3, 3>; // FIFO status
        using DMDIS = Field<_S1FCR, 2, 1>; // Direct mode disable
        using FTH = Field<_S1FCR, 0, 2>; // FIFO threshold selection
    };

    // stream x configuration register
    struct _S2CR : Register<DMA2_BASE + 0x40, ReadWrite, _S2CR> {
        using CHSEL = Field<_S2CR, 25, 4>; // Channel selection
        using MBURST = Field<_S2CR, 23, 2>; // Memory burst transfer configuration
        using PBURST = Field<_S2CR, 21, 2>; // Peripheral burst transfer configuration
        using ACK = Field<_S2CR, 20, 1>; // ACK
        using CT = Field<_S2CR, 19, 1>; // Current target (only in double buffer mode)
        using DBM = Field<_S2CR, 18, 1>; // Double buffer mode
        using PL = Field<_S2CR, 16, 2>; // Priority level
        using PINCOS = Field<_S2CR, 15, 1>; // Peripheral increment offset size
        using MSIZE = Field<_S2CR, 13, 2>; // Memory data size
        using PSIZE = Field<_S2CR, 11, 2>; // Peripheral data size
        using MINC = Field<_S2CR, 10, 1>; // Memory increment mode
        using PINC = Field<_S2CR, 9, 1>; // Peripheral increment mode
        using CIRC = Field<_S2CR, 8, 1>; // Circular mode
        using DIR = Field<_S2CR, 6, 2>; // Data transfer direction
        using PFCTRL = Field<_S2CR, 5, 1>; // Peripheral flow controller
        using TCIE = Field<_S2CR, 4, 1>; // Transfer complete interrupt enable
        using HTIE = Field<_S2CR, 3, 1>; // Half transfer interrupt enable
        using TEIE = Field<_S2CR, 2, 1>; // Transfer error interrupt enable
        using DMEIE = Field<_S2CR, 1, 1>; // Direct mode error interrupt enable
        using EN = Field<_S2CR, 0, 1>; // Stream enable / flag stream ready when read low
    };

    // stream x number of data register
    struct _S2NDTR : Register<DMA2_BASE + 0x44, ReadWrite, _S2NDTR> {
        using NDT = Field<_S2NDTR, 0, 16>; // Number of data items to transfer
    };

    // stream x peripheral address register
    struct _S2PAR : Register<DMA2_BASE + 0x48, ReadWrite, _S2PAR> {
        using PA = Field<_S2PAR, 0, 32>; // Peripheral address
    };

    // stream x memory 0 address register
    struct _S2M0AR : Register<DMA2_BASE + 0x4C, ReadWrite, _S2M0AR> {
        using M0A = Field<_S2M0AR, 0, 32>; // Memory 0 address
    };

    // stream x memory 1 address register
    struct _S2M1AR : Register<DMA2_BASE + 0x50, ReadWrite, _S2M1AR> {
        using M1A = Field<_S2M1AR, 0, 32>; // Memory 1 address (used in case of Double buffer mode)
    };

    // stream x FIFO control register
    struct _S2FCR : Register<DMA2_BASE + 0x54, ReadWrite, _S2FCR> {
        using FEIE = Field<_S2FCR, 7, 1>; // FIFO error interrupt enable
        using FS = Field<_S2FCR, 3, 3>; // FIFO status
        using DMDIS = Field<_S2FCR, 2, 1>; // Direct mode disable
        using FTH = Field<_S2FCR, 0, 2>; // FIFO threshold selection
    };

    // stream x configuration register
    struct _S3CR : Register<DMA2_BASE + 0x58, ReadWrite, _S3CR> {
        using CHSEL = Field<_S3CR, 25, 4>; // Channel selection
        using MBURST = Field<_S3CR, 23, 2>; // Memory burst transfer configuration
        using PBURST = Field<_S3CR, 21, 2>; // Peripheral burst transfer configuration
        using ACK = Field<_S3CR, 20, 1>; // ACK
        using CT = Field<_S3CR, 19, 1>; // Current target (only in double buffer mode)
        using DBM = Field<_S3CR, 18, 1>; // Double buffer mode
        using PL = Field<_S3CR, 16, 2>; // Priority level
        using PINCOS = Field<_S3CR, 15, 1>; // Peripheral increment offset size
        using MSIZE = Field<_S3CR, 13, 2>; // Memory data size
        using PSIZE = Field<_S3CR, 11, 2>; // Peripheral data size
        using MINC = Field<_S3CR, 10, 1>; // Memory increment mode
        using PINC = Field<_S3CR, 9, 1>; // Peripheral increment mode
        using CIRC = Field<_S3CR, 8, 1>; // Circular mode
        using DIR = Field<_S3CR, 6, 2>; // Data transfer direction
        using PFCTRL = Field<_S3CR, 5, 1>; // Peripheral flow controller
        using TCIE = Field<_S3CR, 4, 1>; // Transfer complete interrupt enable
        using HTIE = Field<_S3CR, 3, 1>; // Half transfer interrupt enable
        using TEIE = Field<_S3CR, 2, 1>; // Transfer error interrupt enable
        using DMEIE = Field<_S3CR, 1, 1>; // Direct mode error interrupt enable
        using EN = Field<_S3CR, 0, 1>; // Stream enable / flag stream ready when read low
    };

    // stream x number of data register
    struct _S3NDTR : Register<DMA2_BASE + 0x5C, ReadWrite, _S3NDTR> {
        using NDT = Field<_S3NDTR, 0, 16>; // Number of data items to transfer
    };

    // stream x peripheral address register
    struct _S3PAR : Register<DMA2_BASE + 0x60, ReadWrite, _S3PAR> {
        using PA = Field<_S3PAR, 0, 32>; // Peripheral address
    };

    // stream x memory 0 address register
    struct _S3M0AR : Register<DMA2_BASE + 0x64, ReadWrite, _S3M0AR> {
        using M0A = Field<_S3M0AR, 0, 32>; // Memory 0 address
    };

    // stream x memory 1 address register
    struct _S3M1AR : Register<DMA2_BASE + 0x68, ReadWrite, _S3M1AR> {
        using M1A = Field<_S3M1AR, 0, 32>; // Memory 1 address (used in case of Double buffer mode)
    };

    // stream x FIFO control register
    struct _S3FCR : Register<DMA2_BASE + 0x6C, ReadWrite, _S3FCR> {
        using FEIE = Field<_S3FCR, 7, 1>; // FIFO error interrupt enable
        using FS = Field<_S3FCR, 3, 3>; // FIFO status
        using DMDIS = Field<_S3FCR, 2, 1>; // Direct mode disable
        using FTH = Field<_S3FCR, 0, 2>; // FIFO threshold selection
    };

    // stream x configuration register
    struct _S4CR : Register<DMA2_BASE + 0x70, ReadWrite, _S4CR> {
        using CHSEL = Field<_S4CR, 25, 3>; // Channel selection
        using MBURST = Field<_S4CR, 23, 2>; // Memory burst transfer configuration
        using PBURST = Field<_S4CR, 21, 2>; // Peripheral burst transfer configuration
        using ACK = Field<_S4CR, 20, 1>; // ACK
        using CT = Field<_S4CR, 19, 1>; // Current target (only in double buffer mode)
        using DBM = Field<_S4CR, 18, 1>; // Double buffer mode
        using PL = Field<_S4CR, 16, 2>; // Priority level
        using PINCOS = Field<_S4CR, 15, 1>; // Peripheral increment offset size
        using MSIZE = Field<_S4CR, 13, 2>; // Memory data size
        using PSIZE = Field<_S4CR, 11, 2>; // Peripheral data size
        using MINC = Field<_S4CR, 10, 1>; // Memory increment mode
        using PINC = Field<_S4CR, 9, 1>; // Peripheral increment mode
        using CIRC = Field<_S4CR, 8, 1>; // Circular mode
        using DIR = Field<_S4CR, 6, 2>; // Data transfer direction
        using PFCTRL = Field<_S4CR, 5, 1>; // Peripheral flow controller
        using TCIE = Field<_S4CR, 4, 1>; // Transfer complete interrupt enable
        using HTIE = Field<_S4CR, 3, 1>; // Half transfer interrupt enable
        using TEIE = Field<_S4CR, 2, 1>; // Transfer error interrupt enable
        using DMEIE = Field<_S4CR, 1, 1>; // Direct mode error interrupt enable
        using EN = Field<_S4CR, 0, 1>; // Stream enable / flag stream ready when read low
    };

    // stream x number of data register
    struct _S4NDTR : Register<DMA2_BASE + 0x74, ReadWrite, _S4NDTR> {
        using NDT = Field<_S4NDTR, 0, 16>; // Number of data items to transfer
    };

    // stream x peripheral address register
    struct _S4PAR : Register<DMA2_BASE + 0x78, ReadWrite, _S4PAR> {
        using PA = Field<_S4PAR, 0, 32>; // Peripheral address
    };

    // stream x memory 0 address register
    struct _S4M0AR : Register<DMA2_BASE + 0x7C, ReadWrite, _S4M0AR> {
        using M0A = Field<_S4M0AR, 0, 32>; // Memory 0 address
    };

    // stream x memory 1 address register
    struct _S4M1AR : Register<DMA2_BASE + 0x80, ReadWrite, _S4M1AR> {
        using M1A = Field<_S4M1AR, 0, 32>; // Memory 1 address (used in case of Double buffer mode)
    };

    // stream x FIFO control register
    struct _S4FCR : Register<DMA2_BASE + 0x84, ReadWrite, _S4FCR> {
        using FEIE = Field<_S4FCR, 7, 1>; // FIFO error interrupt enable
        using FS = Field<_S4FCR, 3, 3>; // FIFO status
        using DMDIS = Field<_S4FCR, 2, 1>; // Direct mode disable
        using FTH = Field<_S4FCR, 0, 2>; // FIFO threshold selection
    };

    // stream x configuration register
    struct _S5CR : Register<DMA2_BASE + 0x88, ReadWrite, _S5CR> {
        using CHSEL = Field<_S5CR, 25, 4>; // Channel selection
        using MBURST = Field<_S5CR, 23, 2>; // Memory burst transfer configuration
        using PBURST = Field<_S5CR, 21, 2>; // Peripheral burst transfer configuration
        using ACK = Field<_S5CR, 20, 1>; // ACK
        using CT = Field<_S5CR, 19, 1>; // Current target (only in double buffer mode)
        using DBM = Field<_S5CR, 18, 1>; // Double buffer mode
        using PL = Field<_S5CR, 16, 2>; // Priority level
        using PINCOS = Field<_S5CR, 15, 1>; // Peripheral increment offset size
        using MSIZE = Field<_S5CR, 13, 2>; // Memory data size
        using PSIZE = Field<_S5CR, 11, 2>; // Peripheral data size
        using MINC = Field<_S5CR, 10, 1>; // Memory increment mode
        using PINC = Field<_S5CR, 9, 1>; // Peripheral increment mode
        using CIRC = Field<_S5CR, 8, 1>; // Circular mode
        using DIR = Field<_S5CR, 6, 2>; // Data transfer direction
        using PFCTRL = Field<_S5CR, 5, 1>; // Peripheral flow controller
        using TCIE = Field<_S5CR, 4, 1>; // Transfer complete interrupt enable
        using HTIE = Field<_S5CR, 3, 1>; // Half transfer interrupt enable
        using TEIE = Field<_S5CR, 2, 1>; // Transfer error interrupt enable
        using DMEIE = Field<_S5CR, 1, 1>; // Direct mode error interrupt enable
        using EN = Field<_S5CR, 0, 1>; // Stream enable / flag stream ready when read low
    };

    // stream x number of data register
    struct _S5NDTR : Register<DMA2_BASE + 0x8C, ReadWrite, _S5NDTR> {
        using NDT = Field<_S5NDTR, 0, 16>; // Number of data items to transfer
    };

    // stream x peripheral address register
    struct _S5PAR : Register<DMA2_BASE + 0x90, ReadWrite, _S5PAR> {
        using PA = Field<_S5PAR, 0, 32>; // Peripheral address
    };

    // stream x memory 0 address register
    struct _S5M0AR : Register<DMA2_BASE + 0x94, ReadWrite, _S5M0AR> {
        using M0A = Field<_S5M0AR, 0, 32>; // Memory 0 address
    };

    // stream x memory 1 address register
    struct _S5M1AR : Register<DMA2_BASE + 0x98, ReadWrite, _S5M1AR> {
        using M1A = Field<_S5M1AR, 0, 32>; // Memory 1 address (used in case of Double buffer mode)
    };

    // stream x FIFO control register
    struct _S5FCR : Register<DMA2_BASE + 0x9C, ReadWrite, _S5FCR> {
        using FEIE = Field<_S5FCR, 7, 1>; // FIFO error interrupt enable
        using FS = Field<_S5FCR, 3, 3>; // FIFO status
        using DMDIS = Field<_S5FCR, 2, 1>; // Direct mode disable
        using FTH = Field<_S5FCR, 0, 2>; // FIFO threshold selection
    };

    // stream x configuration register
    struct _S6CR : Register<DMA2_BASE + 0xA0, ReadWrite, _S6CR> {
        using CHSEL = Field<_S6CR, 25, 4>; // Channel selection
        using MBURST = Field<_S6CR, 23, 2>; // Memory burst transfer configuration
        using PBURST = Field<_S6CR, 21, 2>; // Peripheral burst transfer configuration
        using ACK = Field<_S6CR, 20, 1>; // ACK
        using CT = Field<_S6CR, 19, 1>; // Current target (only in double buffer mode)
        using DBM = Field<_S6CR, 18, 1>; // Double buffer mode
        using PL = Field<_S6CR, 16, 2>; // Priority level
        using PINCOS = Field<_S6CR, 15, 1>; // Peripheral increment offset size
        using MSIZE = Field<_S6CR, 13, 2>; // Memory data size
        using PSIZE = Field<_S6CR, 11, 2>; // Peripheral data size
        using MINC = Field<_S6CR, 10, 1>; // Memory increment mode
        using PINC = Field<_S6CR, 9, 1>; // Peripheral increment mode
        using CIRC = Field<_S6CR, 8, 1>; // Circular mode
        using DIR = Field<_S6CR, 6, 2>; // Data transfer direction
        using PFCTRL = Field<_S6CR, 5, 1>; // Peripheral flow controller
        using TCIE = Field<_S6CR, 4, 1>; // Transfer complete interrupt enable
        using HTIE = Field<_S6CR, 3, 1>; // Half transfer interrupt enable
        using TEIE = Field<_S6CR, 2, 1>; // Transfer error interrupt enable
        using DMEIE = Field<_S6CR, 1, 1>; // Direct mode error interrupt enable
        using EN = Field<_S6CR, 0, 1>; // Stream enable / flag stream ready when read low
    };

    // stream x number of data register
    struct _S6NDTR : Register<DMA2_BASE + 0xA4, ReadWrite, _S6NDTR> {
        using NDT = Field<_S6NDTR, 0, 16>; // Number of data items to transfer
    };

    // stream x peripheral address register
    struct _S6PAR : Register<DMA2_BASE + 0xA8, ReadWrite, _S6PAR> {
        using PA = Field<_S6PAR, 0, 32>; // Peripheral address
    };

    // stream x memory 0 address register
    struct _S6M0AR : Register<DMA2_BASE + 0xAC, ReadWrite, _S6M0AR> {
        using M0A = Field<_S6M0AR, 0, 32>; // Memory 0 address
    };

    // stream x memory 1 address register
    struct _S6M1AR : Register<DMA2_BASE + 0xB0, ReadWrite, _S6M1AR> {
        using M1A = Field<_S6M1AR, 0, 32>; // Memory 1 address (used in case of Double buffer mode)
    };

    // stream x FIFO control register
    struct _S6FCR : Register<DMA2_BASE + 0xB4, ReadWrite, _S6FCR> {
        using FEIE = Field<_S6FCR, 7, 1>; // FIFO error interrupt enable
        using FS = Field<_S6FCR, 3, 3>; // FIFO status
        using DMDIS = Field<_S6FCR, 2, 1>; // Direct mode disable
        using FTH = Field<_S6FCR, 0, 2>; // FIFO threshold selection
    };

    // stream x configuration register
    struct _S7CR : Register<DMA2_BASE + 0xB8, ReadWrite, _S7CR> {
        using CHSEL = Field<_S7CR, 25, 4>; // Channel selection
        using MBURST = Field<_S7CR, 23, 2>; // Memory burst transfer configuration
        using PBURST = Field<_S7CR, 21, 2>; // Peripheral burst transfer configuration
        using ACK = Field<_S7CR, 20, 1>; // ACK
        using CT = Field<_S7CR, 19, 1>; // Current target (only in double buffer mode)
        using DBM = Field<_S7CR, 18, 1>; // Double buffer mode
        using PL = Field<_S7CR, 16, 2>; // Priority level
        using PINCOS = Field<_S7CR, 15, 1>; // Peripheral increment offset size
        using MSIZE = Field<_S7CR, 13, 2>; // Memory data size
        using PSIZE = Field<_S7CR, 11, 2>; // Peripheral data size
        using MINC = Field<_S7CR, 10, 1>; // Memory increment mode
        using PINC = Field<_S7CR, 9, 1>; // Peripheral increment mode
        using CIRC = Field<_S7CR, 8, 1>; // Circular mode
        using DIR = Field<_S7CR, 6, 2>; // Data transfer direction
        using PFCTRL = Field<_S7CR, 5, 1>; // Peripheral flow controller
        using TCIE = Field<_S7CR, 4, 1>; // Transfer complete interrupt enable
        using HTIE = Field<_S7CR, 3, 1>; // Half transfer interrupt enable
        using TEIE = Field<_S7CR, 2, 1>; // Transfer error interrupt enable
        using DMEIE = Field<_S7CR, 1, 1>; // Direct mode error interrupt enable
        using EN = Field<_S7CR, 0, 1>; // Stream enable / flag stream ready when read low
    };

    // stream x number of data register
    struct _S7NDTR : Register<DMA2_BASE + 0xBC, ReadWrite, _S7NDTR> {
        using NDT = Field<_S7NDTR, 0, 16>; // Number of data items to transfer
    };

    // stream x peripheral address register
    struct _S7PAR : Register<DMA2_BASE + 0xC0, ReadWrite, _S7PAR> {
        using PA = Field<_S7PAR, 0, 32>; // Peripheral address
    };

    // stream x memory 0 address register
    struct _S7M0AR : Register<DMA2_BASE + 0xC4, ReadWrite, _S7M0AR> {
        using M0A = Field<_S7M0AR, 0, 32>; // Memory 0 address
    };

    // stream x memory 1 address register
    struct _S7M1AR : Register<DMA2_BASE + 0xC8, ReadWrite, _S7M1AR> {
        using M1A = Field<_S7M1AR, 0, 32>; // Memory 1 address (used in case of Double buffer mode)
    };

    // stream x FIFO control register
    struct _S7FCR : Register<DMA2_BASE + 0xCC, ReadWrite, _S7FCR> {
        using FEIE = Field<_S7FCR, 7, 1>; // FIFO error interrupt enable
        using FS = Field<_S7FCR, 3, 3>; // FIFO status
        using DMDIS = Field<_S7FCR, 2, 1>; // Direct mode disable
        using FTH = Field<_S7FCR, 0, 2>; // FIFO threshold selection
    };

} // namespace DMA2

// --------------------------------------------
// DMA1: 
// Base address: 0x40026000
// --------------------------------------------

namespace DMA1 {
    static constexpr uint32_t DMA1_BASE = 0x40026000;

} // namespace DMA1

// --------------------------------------------
// RCC: Reset and clock control
// Base address: 0x40023800
// --------------------------------------------

namespace RCC {
    static constexpr uint32_t RCC_BASE = 0x40023800;

    // clock control register
    struct _CR : Register<RCC_BASE + 0x0, ReadWrite, _CR> {
        using PLLI2SRDY = Field<_CR, 27, 1>; // PLLI2S clock ready flag
        using PLLI2SON = Field<_CR, 26, 1>; // PLLI2S enable
        using PLLRDY = Field<_CR, 25, 1>; // Main PLL (PLL) clock ready flag
        using PLLON = Field<_CR, 24, 1>; // Main PLL (PLL) enable
        using CSSON = Field<_CR, 19, 1>; // Clock security system enable
        using HSEBYP = Field<_CR, 18, 1>; // HSE clock bypass
        using HSERDY = Field<_CR, 17, 1>; // HSE clock ready flag
        using HSEON = Field<_CR, 16, 1>; // HSE clock enable
        using HSICAL = Field<_CR, 8, 8>; // Internal high-speed clock calibration
        using HSITRIM = Field<_CR, 3, 5>; // Internal high-speed clock trimming
        using HSIRDY = Field<_CR, 1, 1>; // Internal high-speed clock ready flag
        using HSION = Field<_CR, 0, 1>; // Internal high-speed clock enable
    };

    // PLL configuration register
    struct _PLLCFGR : Register<RCC_BASE + 0x4, ReadWrite, _PLLCFGR> {
        using PLLQ = Field<_PLLCFGR, 24, 4>; // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
        using PLLSRC = Field<_PLLCFGR, 22, 1>; // Main PLL(PLL) and audio PLL (PLLI2S) entry clock source
        using PLLP = Field<_PLLCFGR, 16, 2>; // Main PLL (PLL) division factor for main system clock
        using PLLN = Field<_PLLCFGR, 6, 9>; // Main PLL (PLL) multiplication factor for VCO
        using PLLM = Field<_PLLCFGR, 0, 6>; // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
    };

    // clock configuration register
    struct _CFGR : Register<RCC_BASE + 0x8, ReadWrite, _CFGR> {
        using MCO2 = Field<_CFGR, 30, 2>; // Microcontroller clock output 2
        using MCO2PRE = Field<_CFGR, 27, 3>; // MCO2 prescaler
        using MCO1PRE = Field<_CFGR, 24, 3>; // MCO1 prescaler
        using I2SSRC = Field<_CFGR, 23, 1>; // I2S clock selection
        using MCO1 = Field<_CFGR, 21, 2>; // Microcontroller clock output 1
        using RTCPRE = Field<_CFGR, 16, 5>; // HSE division factor for RTC clock
        using PPRE2 = Field<_CFGR, 13, 3>; // APB high-speed prescaler (APB2)
        using PPRE1 = Field<_CFGR, 10, 3>; // APB Low speed prescaler (APB1)
        using HPRE = Field<_CFGR, 4, 4>; // AHB prescaler
        using SWS = Field<_CFGR, 2, 2>; // System clock switch status
        using SW = Field<_CFGR, 0, 2>; // System clock switch
    };

    // clock interrupt register
    struct _CIR : Register<RCC_BASE + 0xC, ReadWrite, _CIR> {
        using CSSC = Field<_CIR, 23, 1>; // Clock security system interrupt clear
        using PLLSAIRDYC = Field<_CIR, 22, 1>; // PLLSAI Ready Interrupt Clear
        using PLLI2SRDYC = Field<_CIR, 21, 1>; // PLLI2S ready interrupt clear
        using PLLRDYC = Field<_CIR, 20, 1>; // Main PLL(PLL) ready interrupt clear
        using HSERDYC = Field<_CIR, 19, 1>; // HSE ready interrupt clear
        using HSIRDYC = Field<_CIR, 18, 1>; // HSI ready interrupt clear
        using LSERDYC = Field<_CIR, 17, 1>; // LSE ready interrupt clear
        using LSIRDYC = Field<_CIR, 16, 1>; // LSI ready interrupt clear
        using PLLSAIRDYIE = Field<_CIR, 14, 1>; // PLLSAI Ready Interrupt Enable
        using PLLI2SRDYIE = Field<_CIR, 13, 1>; // PLLI2S ready interrupt enable
        using PLLRDYIE = Field<_CIR, 12, 1>; // Main PLL (PLL) ready interrupt enable
        using HSERDYIE = Field<_CIR, 11, 1>; // HSE ready interrupt enable
        using HSIRDYIE = Field<_CIR, 10, 1>; // HSI ready interrupt enable
        using LSERDYIE = Field<_CIR, 9, 1>; // LSE ready interrupt enable
        using LSIRDYIE = Field<_CIR, 8, 1>; // LSI ready interrupt enable
        using CSSF = Field<_CIR, 7, 1>; // Clock security system interrupt flag
        using PLLSAIRDYF = Field<_CIR, 6, 1>; // PLLSAI ready interrupt flag
        using PLLI2SRDYF = Field<_CIR, 5, 1>; // PLLI2S ready interrupt flag
        using PLLRDYF = Field<_CIR, 4, 1>; // Main PLL (PLL) ready interrupt flag
        using HSERDYF = Field<_CIR, 3, 1>; // HSE ready interrupt flag
        using HSIRDYF = Field<_CIR, 2, 1>; // HSI ready interrupt flag
        using LSERDYF = Field<_CIR, 1, 1>; // LSE ready interrupt flag
        using LSIRDYF = Field<_CIR, 0, 1>; // LSI ready interrupt flag
    };

    // AHB1 peripheral reset register
    struct _AHB1RSTR : Register<RCC_BASE + 0x10, ReadWrite, _AHB1RSTR> {
        using OTGHSRST = Field<_AHB1RSTR, 29, 1>; // USB OTG HS module reset
        using ETHMACRST = Field<_AHB1RSTR, 25, 1>; // Ethernet MAC reset
        using DMA2DRST = Field<_AHB1RSTR, 23, 1>; // DMA2D reset
        using DMA2RST = Field<_AHB1RSTR, 22, 1>; // DMA2 reset
        using DMA1RST = Field<_AHB1RSTR, 21, 1>; // DMA2 reset
        using CRCRST = Field<_AHB1RSTR, 12, 1>; // CRC reset
        using GPIOKRST = Field<_AHB1RSTR, 10, 1>; // IO port K reset
        using GPIOJRST = Field<_AHB1RSTR, 9, 1>; // IO port J reset
        using GPIOIRST = Field<_AHB1RSTR, 8, 1>; // IO port I reset
        using GPIOHRST = Field<_AHB1RSTR, 7, 1>; // IO port H reset
        using GPIOGRST = Field<_AHB1RSTR, 6, 1>; // IO port G reset
        using GPIOFRST = Field<_AHB1RSTR, 5, 1>; // IO port F reset
        using GPIOERST = Field<_AHB1RSTR, 4, 1>; // IO port E reset
        using GPIODRST = Field<_AHB1RSTR, 3, 1>; // IO port D reset
        using GPIOCRST = Field<_AHB1RSTR, 2, 1>; // IO port C reset
        using GPIOBRST = Field<_AHB1RSTR, 1, 1>; // IO port B reset
        using GPIOARST = Field<_AHB1RSTR, 0, 1>; // IO port A reset
    };

    // AHB2 peripheral reset register
    struct _AHB2RSTR : Register<RCC_BASE + 0x14, ReadWrite, _AHB2RSTR> {
        using OTGFSRST = Field<_AHB2RSTR, 7, 1>; // USB OTG FS module reset
        using RNGRST = Field<_AHB2RSTR, 6, 1>; // Random number generator module reset
        using HSAHRST = Field<_AHB2RSTR, 5, 1>; // Hash module reset
        using CRYPRST = Field<_AHB2RSTR, 4, 1>; // Cryptographic module reset
        using DCMIRST = Field<_AHB2RSTR, 0, 1>; // Camera interface reset
    };

    // AHB3 peripheral reset register
    struct _AHB3RSTR : Register<RCC_BASE + 0x18, ReadWrite, _AHB3RSTR> {
        using FMCRST = Field<_AHB3RSTR, 0, 1>; // Flexible memory controller module reset
        using QSPIRST = Field<_AHB3RSTR, 1, 1>; // Quad SPI memory controller reset
    };

    // APB1 peripheral reset register
    struct _APB1RSTR : Register<RCC_BASE + 0x20, ReadWrite, _APB1RSTR> {
        using TIM2RST = Field<_APB1RSTR, 0, 1>; // TIM2 reset
        using TIM3RST = Field<_APB1RSTR, 1, 1>; // TIM3 reset
        using TIM4RST = Field<_APB1RSTR, 2, 1>; // TIM4 reset
        using TIM5RST = Field<_APB1RSTR, 3, 1>; // TIM5 reset
        using TIM6RST = Field<_APB1RSTR, 4, 1>; // TIM6 reset
        using TIM7RST = Field<_APB1RSTR, 5, 1>; // TIM7 reset
        using TIM12RST = Field<_APB1RSTR, 6, 1>; // TIM12 reset
        using TIM13RST = Field<_APB1RSTR, 7, 1>; // TIM13 reset
        using TIM14RST = Field<_APB1RSTR, 8, 1>; // TIM14 reset
        using LPTIM1RST = Field<_APB1RSTR, 9, 1>; // Low power timer 1 reset
        using WWDGRST = Field<_APB1RSTR, 11, 1>; // Window watchdog reset
        using CAN3RST = Field<_APB1RSTR, 13, 1>; // CAN 3 reset
        using SPI2RST = Field<_APB1RSTR, 14, 1>; // SPI 2 reset
        using SPI3RST = Field<_APB1RSTR, 15, 1>; // SPI 3 reset
        using SPDIFRXRST = Field<_APB1RSTR, 16, 1>; // SPDIF-RX reset
        using UART2RST = Field<_APB1RSTR, 17, 1>; // USART 2 reset
        using UART3RST = Field<_APB1RSTR, 18, 1>; // USART 3 reset
        using UART4RST = Field<_APB1RSTR, 19, 1>; // USART 4 reset
        using UART5RST = Field<_APB1RSTR, 20, 1>; // USART 5 reset
        using I2C1RST = Field<_APB1RSTR, 21, 1>; // I2C 1 reset
        using I2C2RST = Field<_APB1RSTR, 22, 1>; // I2C 2 reset
        using I2C3RST = Field<_APB1RSTR, 23, 1>; // I2C3 reset
        using I2C4RST = Field<_APB1RSTR, 24, 1>; // I2C 4 reset
        using CAN1RST = Field<_APB1RSTR, 25, 1>; // CAN1 reset
        using CAN2RST = Field<_APB1RSTR, 26, 1>; // CAN2 reset
        using CECRST = Field<_APB1RSTR, 27, 1>; // HDMI-CEC reset
        using PWRRST = Field<_APB1RSTR, 28, 1>; // Power interface reset
        using DACRST = Field<_APB1RSTR, 29, 1>; // DAC reset
        using UART7RST = Field<_APB1RSTR, 30, 1>; // UART7 reset
        using UART8RST = Field<_APB1RSTR, 31, 1>; // UART8 reset
    };

    // APB2 peripheral reset register
    struct _APB2RSTR : Register<RCC_BASE + 0x24, ReadWrite, _APB2RSTR> {
        using TIM1RST = Field<_APB2RSTR, 0, 1>; // TIM1 reset
        using TIM8RST = Field<_APB2RSTR, 1, 1>; // TIM8 reset
        using USART1RST = Field<_APB2RSTR, 4, 1>; // USART1 reset
        using USART6RST = Field<_APB2RSTR, 5, 1>; // USART6 reset
        using ADCRST = Field<_APB2RSTR, 8, 1>; // ADC interface reset (common to all ADCs)
        using SPI1RST = Field<_APB2RSTR, 12, 1>; // SPI 1 reset
        using SPI4RST = Field<_APB2RSTR, 13, 1>; // SPI4 reset
        using SYSCFGRST = Field<_APB2RSTR, 14, 1>; // System configuration controller reset
        using TIM9RST = Field<_APB2RSTR, 16, 1>; // TIM9 reset
        using TIM10RST = Field<_APB2RSTR, 17, 1>; // TIM10 reset
        using TIM11RST = Field<_APB2RSTR, 18, 1>; // TIM11 reset
        using SPI5RST = Field<_APB2RSTR, 20, 1>; // SPI5 reset
        using SPI6RST = Field<_APB2RSTR, 21, 1>; // SPI6 reset
        using SAI1RST = Field<_APB2RSTR, 22, 1>; // SAI1 reset
        using LTDCRST = Field<_APB2RSTR, 26, 1>; // LTDC reset
        using SAI2RST = Field<_APB2RSTR, 23, 1>; // SAI2 reset
        using SDMMC1RST = Field<_APB2RSTR, 11, 1>; // SDMMC1 reset
    };

    // AHB1 peripheral clock register
    struct _AHB1ENR : Register<RCC_BASE + 0x30, ReadWrite, _AHB1ENR> {
        using OTGHSULPIEN = Field<_AHB1ENR, 30, 1>; // USB OTG HSULPI clock enable
        using OTGHSEN = Field<_AHB1ENR, 29, 1>; // USB OTG HS clock enable
        using ETHMACPTPEN = Field<_AHB1ENR, 28, 1>; // Ethernet PTP clock enable
        using ETHMACRXEN = Field<_AHB1ENR, 27, 1>; // Ethernet Reception clock enable
        using ETHMACTXEN = Field<_AHB1ENR, 26, 1>; // Ethernet Transmission clock enable
        using ETHMACEN = Field<_AHB1ENR, 25, 1>; // Ethernet MAC clock enable
        using DMA2DEN = Field<_AHB1ENR, 23, 1>; // DMA2D clock enable
        using DMA2EN = Field<_AHB1ENR, 22, 1>; // DMA2 clock enable
        using DMA1EN = Field<_AHB1ENR, 21, 1>; // DMA1 clock enable
        using CCMDATARAMEN = Field<_AHB1ENR, 20, 1>; // CCM data RAM clock enable
        using BKPSRAMEN = Field<_AHB1ENR, 18, 1>; // Backup SRAM interface clock enable
        using CRCEN = Field<_AHB1ENR, 12, 1>; // CRC clock enable
        using GPIOKEN = Field<_AHB1ENR, 10, 1>; // IO port K clock enable
        using GPIOJEN = Field<_AHB1ENR, 9, 1>; // IO port J clock enable
        using GPIOIEN = Field<_AHB1ENR, 8, 1>; // IO port I clock enable
        using GPIOHEN = Field<_AHB1ENR, 7, 1>; // IO port H clock enable
        using GPIOGEN = Field<_AHB1ENR, 6, 1>; // IO port G clock enable
        using GPIOFEN = Field<_AHB1ENR, 5, 1>; // IO port F clock enable
        using GPIOEEN = Field<_AHB1ENR, 4, 1>; // IO port E clock enable
        using GPIODEN = Field<_AHB1ENR, 3, 1>; // IO port D clock enable
        using GPIOCEN = Field<_AHB1ENR, 2, 1>; // IO port C clock enable
        using GPIOBEN = Field<_AHB1ENR, 1, 1>; // IO port B clock enable
        using GPIOAEN = Field<_AHB1ENR, 0, 1>; // IO port A clock enable
    };

    // AHB2 peripheral clock enable register
    struct _AHB2ENR : Register<RCC_BASE + 0x34, ReadWrite, _AHB2ENR> {
        using OTGFSEN = Field<_AHB2ENR, 7, 1>; // USB OTG FS clock enable
        using RNGEN = Field<_AHB2ENR, 6, 1>; // Random number generator clock enable
        using HASHEN = Field<_AHB2ENR, 5, 1>; // Hash modules clock enable
        using CRYPEN = Field<_AHB2ENR, 4, 1>; // Cryptographic modules clock enable
        using DCMIEN = Field<_AHB2ENR, 0, 1>; // Camera interface enable
    };

    // AHB3 peripheral clock enable register
    struct _AHB3ENR : Register<RCC_BASE + 0x38, ReadWrite, _AHB3ENR> {
        using FMCEN = Field<_AHB3ENR, 0, 1>; // Flexible memory controller module clock enable
        using QSPIEN = Field<_AHB3ENR, 1, 1>; // Quad SPI memory controller clock enable
    };

    // APB1 peripheral clock enable register
    struct _APB1ENR : Register<RCC_BASE + 0x40, ReadWrite, _APB1ENR> {
        using TIM2EN = Field<_APB1ENR, 0, 1>; // TIM2 clock enable
        using TIM3EN = Field<_APB1ENR, 1, 1>; // TIM3 clock enable
        using TIM4EN = Field<_APB1ENR, 2, 1>; // TIM4 clock enable
        using TIM5EN = Field<_APB1ENR, 3, 1>; // TIM5 clock enable
        using TIM6EN = Field<_APB1ENR, 4, 1>; // TIM6 clock enable
        using TIM7EN = Field<_APB1ENR, 5, 1>; // TIM7 clock enable
        using TIM12EN = Field<_APB1ENR, 6, 1>; // TIM12 clock enable
        using TIM13EN = Field<_APB1ENR, 7, 1>; // TIM13 clock enable
        using TIM14EN = Field<_APB1ENR, 8, 1>; // TIM14 clock enable
        using LPTMI1EN = Field<_APB1ENR, 9, 1>; // Low power timer 1 clock enable
        using RTCAPBEN = Field<_APB1ENR, 10, 1>; // RTC register interface clock enable
        using WWDGEN = Field<_APB1ENR, 11, 1>; // Window watchdog clock enable
        using CAN3EN = Field<_APB1ENR, 13, 1>; // CAN 3 clock enable
        using SPI2EN = Field<_APB1ENR, 14, 1>; // SPI2 clock enable
        using SPI3EN = Field<_APB1ENR, 15, 1>; // SPI3 clock enable
        using SPDIFRXEN = Field<_APB1ENR, 16, 1>; // SPDIF-RX clock enable
        using USART2EN = Field<_APB1ENR, 17, 1>; // USART 2 clock enable
        using USART3EN = Field<_APB1ENR, 18, 1>; // USART3 clock enable
        using UART4EN = Field<_APB1ENR, 19, 1>; // UART4 clock enable
        using UART5EN = Field<_APB1ENR, 20, 1>; // UART5 clock enable
        using I2C1EN = Field<_APB1ENR, 21, 1>; // I2C1 clock enable
        using I2C2EN = Field<_APB1ENR, 22, 1>; // I2C2 clock enable
        using I2C3EN = Field<_APB1ENR, 23, 1>; // I2C3 clock enable
        using I2C4EN = Field<_APB1ENR, 24, 1>; // I2C4 clock enable
        using CAN1EN = Field<_APB1ENR, 25, 1>; // CAN 1 clock enable
        using CAN2EN = Field<_APB1ENR, 26, 1>; // CAN 2 clock enable
        using CECEN = Field<_APB1ENR, 27, 1>; // HDMI-CEN clock enable
        using PWREN = Field<_APB1ENR, 28, 1>; // Power interface clock enable
        using DACEN = Field<_APB1ENR, 29, 1>; // DAC interface clock enable
        using UART7ENR = Field<_APB1ENR, 30, 1>; // UART7 clock enable
        using UART8ENR = Field<_APB1ENR, 31, 1>; // UART8 clock enable
    };

    // APB2 peripheral clock enable register
    struct _APB2ENR : Register<RCC_BASE + 0x44, ReadWrite, _APB2ENR> {
        using TIM1EN = Field<_APB2ENR, 0, 1>; // TIM1 clock enable
        using TIM8EN = Field<_APB2ENR, 1, 1>; // TIM8 clock enable
        using USART1EN = Field<_APB2ENR, 4, 1>; // USART1 clock enable
        using USART6EN = Field<_APB2ENR, 5, 1>; // USART6 clock enable
        using ADC1EN = Field<_APB2ENR, 8, 1>; // ADC1 clock enable
        using ADC2EN = Field<_APB2ENR, 9, 1>; // ADC2 clock enable
        using ADC3EN = Field<_APB2ENR, 10, 1>; // ADC3 clock enable
        using SPI1EN = Field<_APB2ENR, 12, 1>; // SPI1 clock enable
        using SPI4ENR = Field<_APB2ENR, 13, 1>; // SPI4 clock enable
        using SYSCFGEN = Field<_APB2ENR, 14, 1>; // System configuration controller clock enable
        using TIM9EN = Field<_APB2ENR, 16, 1>; // TIM9 clock enable
        using TIM10EN = Field<_APB2ENR, 17, 1>; // TIM10 clock enable
        using TIM11EN = Field<_APB2ENR, 18, 1>; // TIM11 clock enable
        using SPI5ENR = Field<_APB2ENR, 20, 1>; // SPI5 clock enable
        using SPI6ENR = Field<_APB2ENR, 21, 1>; // SPI6 clock enable
        using SAI1EN = Field<_APB2ENR, 22, 1>; // SAI1 clock enable
        using LTDCEN = Field<_APB2ENR, 26, 1>; // LTDC clock enable
        using SAI2EN = Field<_APB2ENR, 23, 1>; // SAI2 clock enable
        using SDMMC1EN = Field<_APB2ENR, 11, 1>; // SDMMC1 clock enable
    };

    // AHB1 peripheral clock enable in low power mode register
    struct _AHB1LPENR : Register<RCC_BASE + 0x50, ReadWrite, _AHB1LPENR> {
        using GPIOALPEN = Field<_AHB1LPENR, 0, 1>; // IO port A clock enable during sleep mode
        using GPIOBLPEN = Field<_AHB1LPENR, 1, 1>; // IO port B clock enable during Sleep mode
        using GPIOCLPEN = Field<_AHB1LPENR, 2, 1>; // IO port C clock enable during Sleep mode
        using GPIODLPEN = Field<_AHB1LPENR, 3, 1>; // IO port D clock enable during Sleep mode
        using GPIOELPEN = Field<_AHB1LPENR, 4, 1>; // IO port E clock enable during Sleep mode
        using GPIOFLPEN = Field<_AHB1LPENR, 5, 1>; // IO port F clock enable during Sleep mode
        using GPIOGLPEN = Field<_AHB1LPENR, 6, 1>; // IO port G clock enable during Sleep mode
        using GPIOHLPEN = Field<_AHB1LPENR, 7, 1>; // IO port H clock enable during Sleep mode
        using GPIOILPEN = Field<_AHB1LPENR, 8, 1>; // IO port I clock enable during Sleep mode
        using GPIOJLPEN = Field<_AHB1LPENR, 9, 1>; // IO port J clock enable during Sleep mode
        using GPIOKLPEN = Field<_AHB1LPENR, 10, 1>; // IO port K clock enable during Sleep mode
        using CRCLPEN = Field<_AHB1LPENR, 12, 1>; // CRC clock enable during Sleep mode
        using FLITFLPEN = Field<_AHB1LPENR, 15, 1>; // Flash interface clock enable during Sleep mode
        using SRAM1LPEN = Field<_AHB1LPENR, 16, 1>; // SRAM 1interface clock enable during Sleep mode
        using SRAM2LPEN = Field<_AHB1LPENR, 17, 1>; // SRAM 2 interface clock enable during Sleep mode
        using BKPSRAMLPEN = Field<_AHB1LPENR, 18, 1>; // Backup SRAM interface clock enable during Sleep mode
        using SRAM3LPEN = Field<_AHB1LPENR, 19, 1>; // SRAM 3 interface clock enable during Sleep mode
        using DMA1LPEN = Field<_AHB1LPENR, 21, 1>; // DMA1 clock enable during Sleep mode
        using DMA2LPEN = Field<_AHB1LPENR, 22, 1>; // DMA2 clock enable during Sleep mode
        using DMA2DLPEN = Field<_AHB1LPENR, 23, 1>; // DMA2D clock enable during Sleep mode
        using ETHMACLPEN = Field<_AHB1LPENR, 25, 1>; // Ethernet MAC clock enable during Sleep mode
        using ETHMACTXLPEN = Field<_AHB1LPENR, 26, 1>; // Ethernet transmission clock enable during Sleep mode
        using ETHMACRXLPEN = Field<_AHB1LPENR, 27, 1>; // Ethernet reception clock enable during Sleep mode
        using ETHMACPTPLPEN = Field<_AHB1LPENR, 28, 1>; // Ethernet PTP clock enable during Sleep mode
        using OTGHSLPEN = Field<_AHB1LPENR, 29, 1>; // USB OTG HS clock enable during Sleep mode
        using OTGHSULPILPEN = Field<_AHB1LPENR, 30, 1>; // USB OTG HS ULPI clock enable during Sleep mode
    };

    // AHB2 peripheral clock enable in low power mode register
    struct _AHB2LPENR : Register<RCC_BASE + 0x54, ReadWrite, _AHB2LPENR> {
        using OTGFSLPEN = Field<_AHB2LPENR, 7, 1>; // USB OTG FS clock enable during Sleep mode
        using RNGLPEN = Field<_AHB2LPENR, 6, 1>; // Random number generator clock enable during Sleep mode
        using HASHLPEN = Field<_AHB2LPENR, 5, 1>; // Hash modules clock enable during Sleep mode
        using CRYPLPEN = Field<_AHB2LPENR, 4, 1>; // Cryptography modules clock enable during Sleep mode
        using DCMILPEN = Field<_AHB2LPENR, 0, 1>; // Camera interface enable during Sleep mode
    };

    // AHB3 peripheral clock enable in low power mode register
    struct _AHB3LPENR : Register<RCC_BASE + 0x58, ReadWrite, _AHB3LPENR> {
        using FMCLPEN = Field<_AHB3LPENR, 0, 1>; // Flexible memory controller module clock enable during Sleep mode
        using QSPILPEN = Field<_AHB3LPENR, 1, 1>; // Quand SPI memory controller clock enable during Sleep mode
    };

    // APB1 peripheral clock enable in low power mode register
    struct _APB1LPENR : Register<RCC_BASE + 0x60, ReadWrite, _APB1LPENR> {
        using TIM2LPEN = Field<_APB1LPENR, 0, 1>; // TIM2 clock enable during Sleep mode
        using TIM3LPEN = Field<_APB1LPENR, 1, 1>; // TIM3 clock enable during Sleep mode
        using TIM4LPEN = Field<_APB1LPENR, 2, 1>; // TIM4 clock enable during Sleep mode
        using TIM5LPEN = Field<_APB1LPENR, 3, 1>; // TIM5 clock enable during Sleep mode
        using TIM6LPEN = Field<_APB1LPENR, 4, 1>; // TIM6 clock enable during Sleep mode
        using TIM7LPEN = Field<_APB1LPENR, 5, 1>; // TIM7 clock enable during Sleep mode
        using TIM12LPEN = Field<_APB1LPENR, 6, 1>; // TIM12 clock enable during Sleep mode
        using TIM13LPEN = Field<_APB1LPENR, 7, 1>; // TIM13 clock enable during Sleep mode
        using TIM14LPEN = Field<_APB1LPENR, 8, 1>; // TIM14 clock enable during Sleep mode
        using WWDGLPEN = Field<_APB1LPENR, 11, 1>; // Window watchdog clock enable during Sleep mode
        using SPI2LPEN = Field<_APB1LPENR, 14, 1>; // SPI2 clock enable during Sleep mode
        using SPI3LPEN = Field<_APB1LPENR, 15, 1>; // SPI3 clock enable during Sleep mode
        using USART2LPEN = Field<_APB1LPENR, 17, 1>; // USART2 clock enable during Sleep mode
        using USART3LPEN = Field<_APB1LPENR, 18, 1>; // USART3 clock enable during Sleep mode
        using UART4LPEN = Field<_APB1LPENR, 19, 1>; // UART4 clock enable during Sleep mode
        using UART5LPEN = Field<_APB1LPENR, 20, 1>; // UART5 clock enable during Sleep mode
        using I2C1LPEN = Field<_APB1LPENR, 21, 1>; // I2C1 clock enable during Sleep mode
        using I2C2LPEN = Field<_APB1LPENR, 22, 1>; // I2C2 clock enable during Sleep mode
        using I2C3LPEN = Field<_APB1LPENR, 23, 1>; // I2C3 clock enable during Sleep mode
        using CAN1LPEN = Field<_APB1LPENR, 25, 1>; // CAN 1 clock enable during Sleep mode
        using CAN2LPEN = Field<_APB1LPENR, 26, 1>; // CAN 2 clock enable during Sleep mode
        using PWRLPEN = Field<_APB1LPENR, 28, 1>; // Power interface clock enable during Sleep mode
        using DACLPEN = Field<_APB1LPENR, 29, 1>; // DAC interface clock enable during Sleep mode
        using UART7LPEN = Field<_APB1LPENR, 30, 1>; // UART7 clock enable during Sleep mode
        using UART8LPEN = Field<_APB1LPENR, 31, 1>; // UART8 clock enable during Sleep mode
        using SPDIFRXLPEN = Field<_APB1LPENR, 16, 1>; // SPDIF-RX clock enable during sleep mode
        using CECLPEN = Field<_APB1LPENR, 27, 1>; // HDMI-CEN clock enable during Sleep mode
        using LPTIM1LPEN = Field<_APB1LPENR, 9, 1>; // low power timer 1 clock enable during Sleep mode
        using I2C4LPEN = Field<_APB1LPENR, 24, 1>; // I2C4 clock enable during Sleep mode
    };

    // APB2 peripheral clock enabled in low power mode register
    struct _APB2LPENR : Register<RCC_BASE + 0x64, ReadWrite, _APB2LPENR> {
        using TIM1LPEN = Field<_APB2LPENR, 0, 1>; // TIM1 clock enable during Sleep mode
        using TIM8LPEN = Field<_APB2LPENR, 1, 1>; // TIM8 clock enable during Sleep mode
        using USART1LPEN = Field<_APB2LPENR, 4, 1>; // USART1 clock enable during Sleep mode
        using USART6LPEN = Field<_APB2LPENR, 5, 1>; // USART6 clock enable during Sleep mode
        using ADC1LPEN = Field<_APB2LPENR, 8, 1>; // ADC1 clock enable during Sleep mode
        using ADC2LPEN = Field<_APB2LPENR, 9, 1>; // ADC2 clock enable during Sleep mode
        using ADC3LPEN = Field<_APB2LPENR, 10, 1>; // ADC 3 clock enable during Sleep mode
        using SPI1LPEN = Field<_APB2LPENR, 12, 1>; // SPI 1 clock enable during Sleep mode
        using SPI4LPEN = Field<_APB2LPENR, 13, 1>; // SPI 4 clock enable during Sleep mode
        using SYSCFGLPEN = Field<_APB2LPENR, 14, 1>; // System configuration controller clock enable during Sleep mode
        using TIM9LPEN = Field<_APB2LPENR, 16, 1>; // TIM9 clock enable during sleep mode
        using TIM10LPEN = Field<_APB2LPENR, 17, 1>; // TIM10 clock enable during Sleep mode
        using TIM11LPEN = Field<_APB2LPENR, 18, 1>; // TIM11 clock enable during Sleep mode
        using SPI5LPEN = Field<_APB2LPENR, 20, 1>; // SPI 5 clock enable during Sleep mode
        using SPI6LPEN = Field<_APB2LPENR, 21, 1>; // SPI 6 clock enable during Sleep mode
        using SAI1LPEN = Field<_APB2LPENR, 22, 1>; // SAI1 clock enable during sleep mode
        using LTDCLPEN = Field<_APB2LPENR, 26, 1>; // LTDC clock enable during sleep mode
        using SAI2LPEN = Field<_APB2LPENR, 23, 1>; // SAI2 clock enable during sleep mode
        using SDMMC1LPEN = Field<_APB2LPENR, 11, 1>; // SDMMC1 clock enable during Sleep mode
    };

    // Backup domain control register
    struct _BDCR : Register<RCC_BASE + 0x70, ReadWrite, _BDCR> {
        using BDRST = Field<_BDCR, 16, 1>; // Backup domain software reset
        using RTCEN = Field<_BDCR, 15, 1>; // RTC clock enable
        using RTCSEL1 = Field<_BDCR, 9, 1>; // RTC clock source selection
        using RTCSEL0 = Field<_BDCR, 8, 1>; // RTC clock source selection
        using LSEBYP = Field<_BDCR, 2, 1>; // External low-speed oscillator bypass
        using LSERDY = Field<_BDCR, 1, 1>; // External low-speed oscillator ready
        using LSEON = Field<_BDCR, 0, 1>; // External low-speed oscillator enable
    };

    // clock control & status register
    struct _CSR : Register<RCC_BASE + 0x74, ReadWrite, _CSR> {
        using LPWRRSTF = Field<_CSR, 31, 1>; // Low-power reset flag
        using WWDGRSTF = Field<_CSR, 30, 1>; // Window watchdog reset flag
        using WDGRSTF = Field<_CSR, 29, 1>; // Independent watchdog reset flag
        using SFTRSTF = Field<_CSR, 28, 1>; // Software reset flag
        using PORRSTF = Field<_CSR, 27, 1>; // POR/PDR reset flag
        using PADRSTF = Field<_CSR, 26, 1>; // PIN reset flag
        using BORRSTF = Field<_CSR, 25, 1>; // BOR reset flag
        using RMVF = Field<_CSR, 24, 1>; // Remove reset flag
        using LSIRDY = Field<_CSR, 1, 1>; // Internal low-speed oscillator ready
        using LSION = Field<_CSR, 0, 1>; // Internal low-speed oscillator enable
    };

    // spread spectrum clock generation register
    struct _SSCGR : Register<RCC_BASE + 0x80, ReadWrite, _SSCGR> {
        using SSCGEN = Field<_SSCGR, 31, 1>; // Spread spectrum modulation enable
        using SPREADSEL = Field<_SSCGR, 30, 1>; // Spread Select
        using INCSTEP = Field<_SSCGR, 13, 15>; // Incrementation step
        using MODPER = Field<_SSCGR, 0, 13>; // Modulation period
    };

    // PLLI2S configuration register
    struct _PLLI2SCFGR : Register<RCC_BASE + 0x84, ReadWrite, _PLLI2SCFGR> {
        using PLLI2SR = Field<_PLLI2SCFGR, 28, 3>; // PLLI2S division factor for I2S clocks
        using PLLI2SQ = Field<_PLLI2SCFGR, 24, 4>; // PLLI2S division factor for SAI1 clock
        using PLLI2SN = Field<_PLLI2SCFGR, 6, 9>; // PLLI2S multiplication factor for VCO
    };

    // PLL configuration register
    struct _PLLSAICFGR : Register<RCC_BASE + 0x88, ReadWrite, _PLLSAICFGR> {
        using PLLSAIN = Field<_PLLSAICFGR, 6, 9>; // PLLSAI division factor for VCO
        using PLLSAIP = Field<_PLLSAICFGR, 16, 2>; // PLLSAI division factor for 48MHz clock
        using PLLSAIQ = Field<_PLLSAICFGR, 24, 4>; // PLLSAI division factor for SAI clock
        using PLLSAIR = Field<_PLLSAICFGR, 28, 3>; // PLLSAI division factor for LCD clock
    };

    // dedicated clocks configuration register
    struct _DKCFGR1 : Register<RCC_BASE + 0x8C, ReadWrite, _DKCFGR1> {
        using PLLI2SDIV = Field<_DKCFGR1, 0, 5>; // PLLI2S division factor for SAI1 clock
        using PLLSAIDIVQ = Field<_DKCFGR1, 8, 5>; // PLLSAI division factor for SAI1 clock
        using PLLSAIDIVR = Field<_DKCFGR1, 16, 2>; // division factor for LCD_CLK
        using SAI1SEL = Field<_DKCFGR1, 20, 2>; // SAI1 clock source selection
        using SAI2SEL = Field<_DKCFGR1, 22, 2>; // SAI2 clock source selection
        using TIMPRE = Field<_DKCFGR1, 24, 1>; // Timers clocks prescalers selection
    };

    // dedicated clocks configuration register
    struct _DKCFGR2 : Register<RCC_BASE + 0x90, ReadWrite, _DKCFGR2> {
        using USART1SEL = Field<_DKCFGR2, 0, 2>; // USART 1 clock source selection
        using USART2SEL = Field<_DKCFGR2, 2, 2>; // USART 2 clock source selection
        using USART3SEL = Field<_DKCFGR2, 4, 2>; // USART 3 clock source selection
        using UART4SEL = Field<_DKCFGR2, 6, 2>; // UART 4 clock source selection
        using UART5SEL = Field<_DKCFGR2, 8, 2>; // UART 5 clock source selection
        using USART6SEL = Field<_DKCFGR2, 10, 2>; // USART 6 clock source selection
        using UART7SEL = Field<_DKCFGR2, 12, 2>; // UART 7 clock source selection
        using UART8SEL = Field<_DKCFGR2, 14, 2>; // UART 8 clock source selection
        using I2C1SEL = Field<_DKCFGR2, 16, 2>; // I2C1 clock source selection
        using I2C2SEL = Field<_DKCFGR2, 18, 2>; // I2C2 clock source selection
        using I2C3SEL = Field<_DKCFGR2, 20, 2>; // I2C3 clock source selection
        using I2C4SEL = Field<_DKCFGR2, 22, 2>; // I2C4 clock source selection
        using LPTIM1SEL = Field<_DKCFGR2, 24, 2>; // Low power timer 1 clock source selection
        using CECSEL = Field<_DKCFGR2, 26, 1>; // HDMI-CEC clock source selection
        using CK48MSEL = Field<_DKCFGR2, 27, 1>; // 48MHz clock source selection
        using SDMMC1SEL = Field<_DKCFGR2, 28, 1>; // SDMMC1 clock source selection
        using SDMMC2SEL = Field<_DKCFGR2, 29, 1>; // SDMMC2 clock source selection
        using DSISEL = Field<_DKCFGR2, 30, 1>; // DSI clock source selection
    };

} // namespace RCC

// --------------------------------------------
// GPIOD: General-purpose I/Os
// Base address: 0X40020C00
// --------------------------------------------

namespace GPIOD {
    static constexpr uint32_t GPIOD_BASE = 0X40020C00;

    // GPIO port mode register
    struct _MODER : Register<GPIOD_BASE + 0x0, ReadWrite, _MODER> {
        using MODER15 = Field<_MODER, 30, 2>; // Port x configuration bits (y = 0..15)
        using MODER14 = Field<_MODER, 28, 2>; // Port x configuration bits (y = 0..15)
        using MODER13 = Field<_MODER, 26, 2>; // Port x configuration bits (y = 0..15)
        using MODER12 = Field<_MODER, 24, 2>; // Port x configuration bits (y = 0..15)
        using MODER11 = Field<_MODER, 22, 2>; // Port x configuration bits (y = 0..15)
        using MODER10 = Field<_MODER, 20, 2>; // Port x configuration bits (y = 0..15)
        using MODER9 = Field<_MODER, 18, 2>; // Port x configuration bits (y = 0..15)
        using MODER8 = Field<_MODER, 16, 2>; // Port x configuration bits (y = 0..15)
        using MODER7 = Field<_MODER, 14, 2>; // Port x configuration bits (y = 0..15)
        using MODER6 = Field<_MODER, 12, 2>; // Port x configuration bits (y = 0..15)
        using MODER5 = Field<_MODER, 10, 2>; // Port x configuration bits (y = 0..15)
        using MODER4 = Field<_MODER, 8, 2>; // Port x configuration bits (y = 0..15)
        using MODER3 = Field<_MODER, 6, 2>; // Port x configuration bits (y = 0..15)
        using MODER2 = Field<_MODER, 4, 2>; // Port x configuration bits (y = 0..15)
        using MODER1 = Field<_MODER, 2, 2>; // Port x configuration bits (y = 0..15)
        using MODER0 = Field<_MODER, 0, 2>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port output type register
    struct _OTYPER : Register<GPIOD_BASE + 0x4, ReadWrite, _OTYPER> {
        using OT15 = Field<_OTYPER, 15, 1>; // Port x configuration bits (y = 0..15)
        using OT14 = Field<_OTYPER, 14, 1>; // Port x configuration bits (y = 0..15)
        using OT13 = Field<_OTYPER, 13, 1>; // Port x configuration bits (y = 0..15)
        using OT12 = Field<_OTYPER, 12, 1>; // Port x configuration bits (y = 0..15)
        using OT11 = Field<_OTYPER, 11, 1>; // Port x configuration bits (y = 0..15)
        using OT10 = Field<_OTYPER, 10, 1>; // Port x configuration bits (y = 0..15)
        using OT9 = Field<_OTYPER, 9, 1>; // Port x configuration bits (y = 0..15)
        using OT8 = Field<_OTYPER, 8, 1>; // Port x configuration bits (y = 0..15)
        using OT7 = Field<_OTYPER, 7, 1>; // Port x configuration bits (y = 0..15)
        using OT6 = Field<_OTYPER, 6, 1>; // Port x configuration bits (y = 0..15)
        using OT5 = Field<_OTYPER, 5, 1>; // Port x configuration bits (y = 0..15)
        using OT4 = Field<_OTYPER, 4, 1>; // Port x configuration bits (y = 0..15)
        using OT3 = Field<_OTYPER, 3, 1>; // Port x configuration bits (y = 0..15)
        using OT2 = Field<_OTYPER, 2, 1>; // Port x configuration bits (y = 0..15)
        using OT1 = Field<_OTYPER, 1, 1>; // Port x configuration bits (y = 0..15)
        using OT0 = Field<_OTYPER, 0, 1>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port output speed register
    struct _OSPEEDR : Register<GPIOD_BASE + 0x8, ReadWrite, _OSPEEDR> {
        using OSPEEDR15 = Field<_OSPEEDR, 30, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR14 = Field<_OSPEEDR, 28, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR13 = Field<_OSPEEDR, 26, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR12 = Field<_OSPEEDR, 24, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR11 = Field<_OSPEEDR, 22, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR10 = Field<_OSPEEDR, 20, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR9 = Field<_OSPEEDR, 18, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR8 = Field<_OSPEEDR, 16, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR7 = Field<_OSPEEDR, 14, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR6 = Field<_OSPEEDR, 12, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR5 = Field<_OSPEEDR, 10, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR4 = Field<_OSPEEDR, 8, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR3 = Field<_OSPEEDR, 6, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR2 = Field<_OSPEEDR, 4, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR1 = Field<_OSPEEDR, 2, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR0 = Field<_OSPEEDR, 0, 2>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port pull-up/pull-down register
    struct _PUPDR : Register<GPIOD_BASE + 0xC, ReadWrite, _PUPDR> {
        using PUPDR15 = Field<_PUPDR, 30, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR14 = Field<_PUPDR, 28, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR13 = Field<_PUPDR, 26, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR12 = Field<_PUPDR, 24, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR11 = Field<_PUPDR, 22, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR10 = Field<_PUPDR, 20, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR9 = Field<_PUPDR, 18, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR8 = Field<_PUPDR, 16, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR7 = Field<_PUPDR, 14, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR6 = Field<_PUPDR, 12, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR5 = Field<_PUPDR, 10, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR4 = Field<_PUPDR, 8, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR3 = Field<_PUPDR, 6, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR2 = Field<_PUPDR, 4, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR1 = Field<_PUPDR, 2, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR0 = Field<_PUPDR, 0, 2>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port input data register
    struct _IDR : Register<GPIOD_BASE + 0x10, ReadOnly, _IDR> {
        using IDR15 = Field<_IDR, 15, 1>; // Port input data (y = 0..15)
        using IDR14 = Field<_IDR, 14, 1>; // Port input data (y = 0..15)
        using IDR13 = Field<_IDR, 13, 1>; // Port input data (y = 0..15)
        using IDR12 = Field<_IDR, 12, 1>; // Port input data (y = 0..15)
        using IDR11 = Field<_IDR, 11, 1>; // Port input data (y = 0..15)
        using IDR10 = Field<_IDR, 10, 1>; // Port input data (y = 0..15)
        using IDR9 = Field<_IDR, 9, 1>; // Port input data (y = 0..15)
        using IDR8 = Field<_IDR, 8, 1>; // Port input data (y = 0..15)
        using IDR7 = Field<_IDR, 7, 1>; // Port input data (y = 0..15)
        using IDR6 = Field<_IDR, 6, 1>; // Port input data (y = 0..15)
        using IDR5 = Field<_IDR, 5, 1>; // Port input data (y = 0..15)
        using IDR4 = Field<_IDR, 4, 1>; // Port input data (y = 0..15)
        using IDR3 = Field<_IDR, 3, 1>; // Port input data (y = 0..15)
        using IDR2 = Field<_IDR, 2, 1>; // Port input data (y = 0..15)
        using IDR1 = Field<_IDR, 1, 1>; // Port input data (y = 0..15)
        using IDR0 = Field<_IDR, 0, 1>; // Port input data (y = 0..15)
    };

    // GPIO port output data register
    struct _ODR : Register<GPIOD_BASE + 0x14, ReadWrite, _ODR> {
        using ODR15 = Field<_ODR, 15, 1>; // Port output data (y = 0..15)
        using ODR14 = Field<_ODR, 14, 1>; // Port output data (y = 0..15)
        using ODR13 = Field<_ODR, 13, 1>; // Port output data (y = 0..15)
        using ODR12 = Field<_ODR, 12, 1>; // Port output data (y = 0..15)
        using ODR11 = Field<_ODR, 11, 1>; // Port output data (y = 0..15)
        using ODR10 = Field<_ODR, 10, 1>; // Port output data (y = 0..15)
        using ODR9 = Field<_ODR, 9, 1>; // Port output data (y = 0..15)
        using ODR8 = Field<_ODR, 8, 1>; // Port output data (y = 0..15)
        using ODR7 = Field<_ODR, 7, 1>; // Port output data (y = 0..15)
        using ODR6 = Field<_ODR, 6, 1>; // Port output data (y = 0..15)
        using ODR5 = Field<_ODR, 5, 1>; // Port output data (y = 0..15)
        using ODR4 = Field<_ODR, 4, 1>; // Port output data (y = 0..15)
        using ODR3 = Field<_ODR, 3, 1>; // Port output data (y = 0..15)
        using ODR2 = Field<_ODR, 2, 1>; // Port output data (y = 0..15)
        using ODR1 = Field<_ODR, 1, 1>; // Port output data (y = 0..15)
        using ODR0 = Field<_ODR, 0, 1>; // Port output data (y = 0..15)
    };

    // GPIO port bit set/reset register
    struct _BSRR : Register<GPIOD_BASE + 0x18, WriteOnly, _BSRR> {
        using BR15 = Field<_BSRR, 31, 1>; // Port x reset bit y (y = 0..15)
        using BR14 = Field<_BSRR, 30, 1>; // Port x reset bit y (y = 0..15)
        using BR13 = Field<_BSRR, 29, 1>; // Port x reset bit y (y = 0..15)
        using BR12 = Field<_BSRR, 28, 1>; // Port x reset bit y (y = 0..15)
        using BR11 = Field<_BSRR, 27, 1>; // Port x reset bit y (y = 0..15)
        using BR10 = Field<_BSRR, 26, 1>; // Port x reset bit y (y = 0..15)
        using BR9 = Field<_BSRR, 25, 1>; // Port x reset bit y (y = 0..15)
        using BR8 = Field<_BSRR, 24, 1>; // Port x reset bit y (y = 0..15)
        using BR7 = Field<_BSRR, 23, 1>; // Port x reset bit y (y = 0..15)
        using BR6 = Field<_BSRR, 22, 1>; // Port x reset bit y (y = 0..15)
        using BR5 = Field<_BSRR, 21, 1>; // Port x reset bit y (y = 0..15)
        using BR4 = Field<_BSRR, 20, 1>; // Port x reset bit y (y = 0..15)
        using BR3 = Field<_BSRR, 19, 1>; // Port x reset bit y (y = 0..15)
        using BR2 = Field<_BSRR, 18, 1>; // Port x reset bit y (y = 0..15)
        using BR1 = Field<_BSRR, 17, 1>; // Port x reset bit y (y = 0..15)
        using BR0 = Field<_BSRR, 16, 1>; // Port x set bit y (y= 0..15)
        using BS15 = Field<_BSRR, 15, 1>; // Port x set bit y (y= 0..15)
        using BS14 = Field<_BSRR, 14, 1>; // Port x set bit y (y= 0..15)
        using BS13 = Field<_BSRR, 13, 1>; // Port x set bit y (y= 0..15)
        using BS12 = Field<_BSRR, 12, 1>; // Port x set bit y (y= 0..15)
        using BS11 = Field<_BSRR, 11, 1>; // Port x set bit y (y= 0..15)
        using BS10 = Field<_BSRR, 10, 1>; // Port x set bit y (y= 0..15)
        using BS9 = Field<_BSRR, 9, 1>; // Port x set bit y (y= 0..15)
        using BS8 = Field<_BSRR, 8, 1>; // Port x set bit y (y= 0..15)
        using BS7 = Field<_BSRR, 7, 1>; // Port x set bit y (y= 0..15)
        using BS6 = Field<_BSRR, 6, 1>; // Port x set bit y (y= 0..15)
        using BS5 = Field<_BSRR, 5, 1>; // Port x set bit y (y= 0..15)
        using BS4 = Field<_BSRR, 4, 1>; // Port x set bit y (y= 0..15)
        using BS3 = Field<_BSRR, 3, 1>; // Port x set bit y (y= 0..15)
        using BS2 = Field<_BSRR, 2, 1>; // Port x set bit y (y= 0..15)
        using BS1 = Field<_BSRR, 1, 1>; // Port x set bit y (y= 0..15)
        using BS0 = Field<_BSRR, 0, 1>; // Port x set bit y (y= 0..15)
    };

    // GPIO port configuration lock register
    struct _LCKR : Register<GPIOD_BASE + 0x1C, ReadWrite, _LCKR> {
        using LCKK = Field<_LCKR, 16, 1>; // Port x lock bit y (y= 0..15)
        using LCK15 = Field<_LCKR, 15, 1>; // Port x lock bit y (y= 0..15)
        using LCK14 = Field<_LCKR, 14, 1>; // Port x lock bit y (y= 0..15)
        using LCK13 = Field<_LCKR, 13, 1>; // Port x lock bit y (y= 0..15)
        using LCK12 = Field<_LCKR, 12, 1>; // Port x lock bit y (y= 0..15)
        using LCK11 = Field<_LCKR, 11, 1>; // Port x lock bit y (y= 0..15)
        using LCK10 = Field<_LCKR, 10, 1>; // Port x lock bit y (y= 0..15)
        using LCK9 = Field<_LCKR, 9, 1>; // Port x lock bit y (y= 0..15)
        using LCK8 = Field<_LCKR, 8, 1>; // Port x lock bit y (y= 0..15)
        using LCK7 = Field<_LCKR, 7, 1>; // Port x lock bit y (y= 0..15)
        using LCK6 = Field<_LCKR, 6, 1>; // Port x lock bit y (y= 0..15)
        using LCK5 = Field<_LCKR, 5, 1>; // Port x lock bit y (y= 0..15)
        using LCK4 = Field<_LCKR, 4, 1>; // Port x lock bit y (y= 0..15)
        using LCK3 = Field<_LCKR, 3, 1>; // Port x lock bit y (y= 0..15)
        using LCK2 = Field<_LCKR, 2, 1>; // Port x lock bit y (y= 0..15)
        using LCK1 = Field<_LCKR, 1, 1>; // Port x lock bit y (y= 0..15)
        using LCK0 = Field<_LCKR, 0, 1>; // Port x lock bit y (y= 0..15)
    };

    // GPIO alternate function lowregister
    struct _AFRL : Register<GPIOD_BASE + 0x20, ReadWrite, _AFRL> {
        using AFRL7 = Field<_AFRL, 28, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL6 = Field<_AFRL, 24, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL5 = Field<_AFRL, 20, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL4 = Field<_AFRL, 16, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL3 = Field<_AFRL, 12, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL2 = Field<_AFRL, 8, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL1 = Field<_AFRL, 4, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL0 = Field<_AFRL, 0, 4>; // Alternate function selection for port x bit y (y = 0..7)
    };

    // GPIO alternate function high register
    struct _AFRH : Register<GPIOD_BASE + 0x24, ReadWrite, _AFRH> {
        using AFRH15 = Field<_AFRH, 28, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH14 = Field<_AFRH, 24, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH13 = Field<_AFRH, 20, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH12 = Field<_AFRH, 16, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH11 = Field<_AFRH, 12, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH10 = Field<_AFRH, 8, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH9 = Field<_AFRH, 4, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH8 = Field<_AFRH, 0, 4>; // Alternate function selection for port x bit y (y = 8..15)
    };

    // GPIO port bit reset register
    struct _BRR : Register<GPIOD_BASE + 0x28, ReadWrite, _BRR> {
        using BR0 = Field<_BRR, 0, 1>; // Port D Reset bit 0
        using BR1 = Field<_BRR, 1, 1>; // Port D Reset bit 1
        using BR2 = Field<_BRR, 2, 1>; // Port D Reset bit 2
        using BR3 = Field<_BRR, 3, 1>; // Port D Reset bit 3
        using BR4 = Field<_BRR, 4, 1>; // Port D Reset bit 4
        using BR5 = Field<_BRR, 5, 1>; // Port D Reset bit 5
        using BR6 = Field<_BRR, 6, 1>; // Port D Reset bit 6
        using BR7 = Field<_BRR, 7, 1>; // Port D Reset bit 7
        using BR8 = Field<_BRR, 8, 1>; // Port D Reset bit 8
        using BR9 = Field<_BRR, 9, 1>; // Port D Reset bit 9
        using BR10 = Field<_BRR, 10, 1>; // Port D Reset bit 10
        using BR11 = Field<_BRR, 11, 1>; // Port D Reset bit 11
        using BR12 = Field<_BRR, 12, 1>; // Port D Reset bit 12
        using BR13 = Field<_BRR, 13, 1>; // Port D Reset bit 13
        using BR14 = Field<_BRR, 14, 1>; // Port D Reset bit 14
        using BR15 = Field<_BRR, 15, 1>; // Port D Reset bit 15
    };

} // namespace GPIOD

// --------------------------------------------
// GPIOC: 
// Base address: 0x40020800
// --------------------------------------------

namespace GPIOC {
    static constexpr uint32_t GPIOC_BASE = 0x40020800;

} // namespace GPIOC

// --------------------------------------------
// GPIOK: 
// Base address: 0X40022800
// --------------------------------------------

namespace GPIOK {
    static constexpr uint32_t GPIOK_BASE = 0X40022800;

} // namespace GPIOK

// --------------------------------------------
// GPIOJ: 
// Base address: 0X40022400
// --------------------------------------------

namespace GPIOJ {
    static constexpr uint32_t GPIOJ_BASE = 0X40022400;

} // namespace GPIOJ

// --------------------------------------------
// GPIOI: 
// Base address: 0X40022000
// --------------------------------------------

namespace GPIOI {
    static constexpr uint32_t GPIOI_BASE = 0X40022000;

} // namespace GPIOI

// --------------------------------------------
// GPIOH: 
// Base address: 0X40021C00
// --------------------------------------------

namespace GPIOH {
    static constexpr uint32_t GPIOH_BASE = 0X40021C00;

} // namespace GPIOH

// --------------------------------------------
// GPIOG: 
// Base address: 0X40021800
// --------------------------------------------

namespace GPIOG {
    static constexpr uint32_t GPIOG_BASE = 0X40021800;

} // namespace GPIOG

// --------------------------------------------
// GPIOF: 
// Base address: 0X40021400
// --------------------------------------------

namespace GPIOF {
    static constexpr uint32_t GPIOF_BASE = 0X40021400;

} // namespace GPIOF

// --------------------------------------------
// GPIOE: 
// Base address: 0X40021000
// --------------------------------------------

namespace GPIOE {
    static constexpr uint32_t GPIOE_BASE = 0X40021000;

} // namespace GPIOE

// --------------------------------------------
// GPIOB: General-purpose I/Os
// Base address: 0x40020400
// --------------------------------------------

namespace GPIOB {
    static constexpr uint32_t GPIOB_BASE = 0x40020400;

    // GPIO port mode register
    struct _MODER : Register<GPIOB_BASE + 0x0, ReadWrite, _MODER> {
        using MODER15 = Field<_MODER, 30, 2>; // Port x configuration bits (y = 0..15)
        using MODER14 = Field<_MODER, 28, 2>; // Port x configuration bits (y = 0..15)
        using MODER13 = Field<_MODER, 26, 2>; // Port x configuration bits (y = 0..15)
        using MODER12 = Field<_MODER, 24, 2>; // Port x configuration bits (y = 0..15)
        using MODER11 = Field<_MODER, 22, 2>; // Port x configuration bits (y = 0..15)
        using MODER10 = Field<_MODER, 20, 2>; // Port x configuration bits (y = 0..15)
        using MODER9 = Field<_MODER, 18, 2>; // Port x configuration bits (y = 0..15)
        using MODER8 = Field<_MODER, 16, 2>; // Port x configuration bits (y = 0..15)
        using MODER7 = Field<_MODER, 14, 2>; // Port x configuration bits (y = 0..15)
        using MODER6 = Field<_MODER, 12, 2>; // Port x configuration bits (y = 0..15)
        using MODER5 = Field<_MODER, 10, 2>; // Port x configuration bits (y = 0..15)
        using MODER4 = Field<_MODER, 8, 2>; // Port x configuration bits (y = 0..15)
        using MODER3 = Field<_MODER, 6, 2>; // Port x configuration bits (y = 0..15)
        using MODER2 = Field<_MODER, 4, 2>; // Port x configuration bits (y = 0..15)
        using MODER1 = Field<_MODER, 2, 2>; // Port x configuration bits (y = 0..15)
        using MODER0 = Field<_MODER, 0, 2>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port output type register
    struct _OTYPER : Register<GPIOB_BASE + 0x4, ReadWrite, _OTYPER> {
        using OT15 = Field<_OTYPER, 15, 1>; // Port x configuration bits (y = 0..15)
        using OT14 = Field<_OTYPER, 14, 1>; // Port x configuration bits (y = 0..15)
        using OT13 = Field<_OTYPER, 13, 1>; // Port x configuration bits (y = 0..15)
        using OT12 = Field<_OTYPER, 12, 1>; // Port x configuration bits (y = 0..15)
        using OT11 = Field<_OTYPER, 11, 1>; // Port x configuration bits (y = 0..15)
        using OT10 = Field<_OTYPER, 10, 1>; // Port x configuration bits (y = 0..15)
        using OT9 = Field<_OTYPER, 9, 1>; // Port x configuration bits (y = 0..15)
        using OT8 = Field<_OTYPER, 8, 1>; // Port x configuration bits (y = 0..15)
        using OT7 = Field<_OTYPER, 7, 1>; // Port x configuration bits (y = 0..15)
        using OT6 = Field<_OTYPER, 6, 1>; // Port x configuration bits (y = 0..15)
        using OT5 = Field<_OTYPER, 5, 1>; // Port x configuration bits (y = 0..15)
        using OT4 = Field<_OTYPER, 4, 1>; // Port x configuration bits (y = 0..15)
        using OT3 = Field<_OTYPER, 3, 1>; // Port x configuration bits (y = 0..15)
        using OT2 = Field<_OTYPER, 2, 1>; // Port x configuration bits (y = 0..15)
        using OT1 = Field<_OTYPER, 1, 1>; // Port x configuration bits (y = 0..15)
        using OT0 = Field<_OTYPER, 0, 1>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port output speed register
    struct _OSPEEDR : Register<GPIOB_BASE + 0x8, ReadWrite, _OSPEEDR> {
        using OSPEEDR15 = Field<_OSPEEDR, 30, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR14 = Field<_OSPEEDR, 28, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR13 = Field<_OSPEEDR, 26, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR12 = Field<_OSPEEDR, 24, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR11 = Field<_OSPEEDR, 22, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR10 = Field<_OSPEEDR, 20, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR9 = Field<_OSPEEDR, 18, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR8 = Field<_OSPEEDR, 16, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR7 = Field<_OSPEEDR, 14, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR6 = Field<_OSPEEDR, 12, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR5 = Field<_OSPEEDR, 10, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR4 = Field<_OSPEEDR, 8, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR3 = Field<_OSPEEDR, 6, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR2 = Field<_OSPEEDR, 4, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR1 = Field<_OSPEEDR, 2, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR0 = Field<_OSPEEDR, 0, 2>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port pull-up/pull-down register
    struct _PUPDR : Register<GPIOB_BASE + 0xC, ReadWrite, _PUPDR> {
        using PUPDR15 = Field<_PUPDR, 30, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR14 = Field<_PUPDR, 28, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR13 = Field<_PUPDR, 26, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR12 = Field<_PUPDR, 24, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR11 = Field<_PUPDR, 22, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR10 = Field<_PUPDR, 20, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR9 = Field<_PUPDR, 18, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR8 = Field<_PUPDR, 16, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR7 = Field<_PUPDR, 14, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR6 = Field<_PUPDR, 12, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR5 = Field<_PUPDR, 10, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR4 = Field<_PUPDR, 8, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR3 = Field<_PUPDR, 6, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR2 = Field<_PUPDR, 4, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR1 = Field<_PUPDR, 2, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR0 = Field<_PUPDR, 0, 2>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port input data register
    struct _IDR : Register<GPIOB_BASE + 0x10, ReadOnly, _IDR> {
        using IDR15 = Field<_IDR, 15, 1>; // Port input data (y = 0..15)
        using IDR14 = Field<_IDR, 14, 1>; // Port input data (y = 0..15)
        using IDR13 = Field<_IDR, 13, 1>; // Port input data (y = 0..15)
        using IDR12 = Field<_IDR, 12, 1>; // Port input data (y = 0..15)
        using IDR11 = Field<_IDR, 11, 1>; // Port input data (y = 0..15)
        using IDR10 = Field<_IDR, 10, 1>; // Port input data (y = 0..15)
        using IDR9 = Field<_IDR, 9, 1>; // Port input data (y = 0..15)
        using IDR8 = Field<_IDR, 8, 1>; // Port input data (y = 0..15)
        using IDR7 = Field<_IDR, 7, 1>; // Port input data (y = 0..15)
        using IDR6 = Field<_IDR, 6, 1>; // Port input data (y = 0..15)
        using IDR5 = Field<_IDR, 5, 1>; // Port input data (y = 0..15)
        using IDR4 = Field<_IDR, 4, 1>; // Port input data (y = 0..15)
        using IDR3 = Field<_IDR, 3, 1>; // Port input data (y = 0..15)
        using IDR2 = Field<_IDR, 2, 1>; // Port input data (y = 0..15)
        using IDR1 = Field<_IDR, 1, 1>; // Port input data (y = 0..15)
        using IDR0 = Field<_IDR, 0, 1>; // Port input data (y = 0..15)
    };

    // GPIO port output data register
    struct _ODR : Register<GPIOB_BASE + 0x14, ReadWrite, _ODR> {
        using ODR15 = Field<_ODR, 15, 1>; // Port output data (y = 0..15)
        using ODR14 = Field<_ODR, 14, 1>; // Port output data (y = 0..15)
        using ODR13 = Field<_ODR, 13, 1>; // Port output data (y = 0..15)
        using ODR12 = Field<_ODR, 12, 1>; // Port output data (y = 0..15)
        using ODR11 = Field<_ODR, 11, 1>; // Port output data (y = 0..15)
        using ODR10 = Field<_ODR, 10, 1>; // Port output data (y = 0..15)
        using ODR9 = Field<_ODR, 9, 1>; // Port output data (y = 0..15)
        using ODR8 = Field<_ODR, 8, 1>; // Port output data (y = 0..15)
        using ODR7 = Field<_ODR, 7, 1>; // Port output data (y = 0..15)
        using ODR6 = Field<_ODR, 6, 1>; // Port output data (y = 0..15)
        using ODR5 = Field<_ODR, 5, 1>; // Port output data (y = 0..15)
        using ODR4 = Field<_ODR, 4, 1>; // Port output data (y = 0..15)
        using ODR3 = Field<_ODR, 3, 1>; // Port output data (y = 0..15)
        using ODR2 = Field<_ODR, 2, 1>; // Port output data (y = 0..15)
        using ODR1 = Field<_ODR, 1, 1>; // Port output data (y = 0..15)
        using ODR0 = Field<_ODR, 0, 1>; // Port output data (y = 0..15)
    };

    // GPIO port bit set/reset register
    struct _BSRR : Register<GPIOB_BASE + 0x18, WriteOnly, _BSRR> {
        using BR15 = Field<_BSRR, 31, 1>; // Port x reset bit y (y = 0..15)
        using BR14 = Field<_BSRR, 30, 1>; // Port x reset bit y (y = 0..15)
        using BR13 = Field<_BSRR, 29, 1>; // Port x reset bit y (y = 0..15)
        using BR12 = Field<_BSRR, 28, 1>; // Port x reset bit y (y = 0..15)
        using BR11 = Field<_BSRR, 27, 1>; // Port x reset bit y (y = 0..15)
        using BR10 = Field<_BSRR, 26, 1>; // Port x reset bit y (y = 0..15)
        using BR9 = Field<_BSRR, 25, 1>; // Port x reset bit y (y = 0..15)
        using BR8 = Field<_BSRR, 24, 1>; // Port x reset bit y (y = 0..15)
        using BR7 = Field<_BSRR, 23, 1>; // Port x reset bit y (y = 0..15)
        using BR6 = Field<_BSRR, 22, 1>; // Port x reset bit y (y = 0..15)
        using BR5 = Field<_BSRR, 21, 1>; // Port x reset bit y (y = 0..15)
        using BR4 = Field<_BSRR, 20, 1>; // Port x reset bit y (y = 0..15)
        using BR3 = Field<_BSRR, 19, 1>; // Port x reset bit y (y = 0..15)
        using BR2 = Field<_BSRR, 18, 1>; // Port x reset bit y (y = 0..15)
        using BR1 = Field<_BSRR, 17, 1>; // Port x reset bit y (y = 0..15)
        using BR0 = Field<_BSRR, 16, 1>; // Port x set bit y (y= 0..15)
        using BS15 = Field<_BSRR, 15, 1>; // Port x set bit y (y= 0..15)
        using BS14 = Field<_BSRR, 14, 1>; // Port x set bit y (y= 0..15)
        using BS13 = Field<_BSRR, 13, 1>; // Port x set bit y (y= 0..15)
        using BS12 = Field<_BSRR, 12, 1>; // Port x set bit y (y= 0..15)
        using BS11 = Field<_BSRR, 11, 1>; // Port x set bit y (y= 0..15)
        using BS10 = Field<_BSRR, 10, 1>; // Port x set bit y (y= 0..15)
        using BS9 = Field<_BSRR, 9, 1>; // Port x set bit y (y= 0..15)
        using BS8 = Field<_BSRR, 8, 1>; // Port x set bit y (y= 0..15)
        using BS7 = Field<_BSRR, 7, 1>; // Port x set bit y (y= 0..15)
        using BS6 = Field<_BSRR, 6, 1>; // Port x set bit y (y= 0..15)
        using BS5 = Field<_BSRR, 5, 1>; // Port x set bit y (y= 0..15)
        using BS4 = Field<_BSRR, 4, 1>; // Port x set bit y (y= 0..15)
        using BS3 = Field<_BSRR, 3, 1>; // Port x set bit y (y= 0..15)
        using BS2 = Field<_BSRR, 2, 1>; // Port x set bit y (y= 0..15)
        using BS1 = Field<_BSRR, 1, 1>; // Port x set bit y (y= 0..15)
        using BS0 = Field<_BSRR, 0, 1>; // Port x set bit y (y= 0..15)
    };

    // GPIO port configuration lock register
    struct _LCKR : Register<GPIOB_BASE + 0x1C, ReadWrite, _LCKR> {
        using LCKK = Field<_LCKR, 16, 1>; // Port x lock bit y (y= 0..15)
        using LCK15 = Field<_LCKR, 15, 1>; // Port x lock bit y (y= 0..15)
        using LCK14 = Field<_LCKR, 14, 1>; // Port x lock bit y (y= 0..15)
        using LCK13 = Field<_LCKR, 13, 1>; // Port x lock bit y (y= 0..15)
        using LCK12 = Field<_LCKR, 12, 1>; // Port x lock bit y (y= 0..15)
        using LCK11 = Field<_LCKR, 11, 1>; // Port x lock bit y (y= 0..15)
        using LCK10 = Field<_LCKR, 10, 1>; // Port x lock bit y (y= 0..15)
        using LCK9 = Field<_LCKR, 9, 1>; // Port x lock bit y (y= 0..15)
        using LCK8 = Field<_LCKR, 8, 1>; // Port x lock bit y (y= 0..15)
        using LCK7 = Field<_LCKR, 7, 1>; // Port x lock bit y (y= 0..15)
        using LCK6 = Field<_LCKR, 6, 1>; // Port x lock bit y (y= 0..15)
        using LCK5 = Field<_LCKR, 5, 1>; // Port x lock bit y (y= 0..15)
        using LCK4 = Field<_LCKR, 4, 1>; // Port x lock bit y (y= 0..15)
        using LCK3 = Field<_LCKR, 3, 1>; // Port x lock bit y (y= 0..15)
        using LCK2 = Field<_LCKR, 2, 1>; // Port x lock bit y (y= 0..15)
        using LCK1 = Field<_LCKR, 1, 1>; // Port x lock bit y (y= 0..15)
        using LCK0 = Field<_LCKR, 0, 1>; // Port x lock bit y (y= 0..15)
    };

    // GPIO alternate function low register
    struct _AFRL : Register<GPIOB_BASE + 0x20, ReadWrite, _AFRL> {
        using AFRL7 = Field<_AFRL, 28, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL6 = Field<_AFRL, 24, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL5 = Field<_AFRL, 20, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL4 = Field<_AFRL, 16, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL3 = Field<_AFRL, 12, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL2 = Field<_AFRL, 8, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL1 = Field<_AFRL, 4, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL0 = Field<_AFRL, 0, 4>; // Alternate function selection for port x bit y (y = 0..7)
    };

    // GPIO alternate function high register
    struct _AFRH : Register<GPIOB_BASE + 0x24, ReadWrite, _AFRH> {
        using AFRH15 = Field<_AFRH, 28, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH14 = Field<_AFRH, 24, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH13 = Field<_AFRH, 20, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH12 = Field<_AFRH, 16, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH11 = Field<_AFRH, 12, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH10 = Field<_AFRH, 8, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH9 = Field<_AFRH, 4, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH8 = Field<_AFRH, 0, 4>; // Alternate function selection for port x bit y (y = 8..15)
    };

    // GPIO port bit reset register
    struct _BRR : Register<GPIOB_BASE + 0x28, ReadWrite, _BRR> {
        using BR0 = Field<_BRR, 0, 1>; // Port B Reset bit 0
        using BR1 = Field<_BRR, 1, 1>; // Port B Reset bit 1
        using BR2 = Field<_BRR, 2, 1>; // Port B Reset bit 2
        using BR3 = Field<_BRR, 3, 1>; // Port B Reset bit 3
        using BR4 = Field<_BRR, 4, 1>; // Port B Reset bit 4
        using BR5 = Field<_BRR, 5, 1>; // Port B Reset bit 5
        using BR6 = Field<_BRR, 6, 1>; // Port B Reset bit 6
        using BR7 = Field<_BRR, 7, 1>; // Port B Reset bit 7
        using BR8 = Field<_BRR, 8, 1>; // Port B Reset bit 8
        using BR9 = Field<_BRR, 9, 1>; // Port B Reset bit 9
        using BR10 = Field<_BRR, 10, 1>; // Port B Reset bit 10
        using BR11 = Field<_BRR, 11, 1>; // Port B Reset bit 11
        using BR12 = Field<_BRR, 12, 1>; // Port B Reset bit 12
        using BR13 = Field<_BRR, 13, 1>; // Port B Reset bit 13
        using BR14 = Field<_BRR, 14, 1>; // Port B Reset bit 14
        using BR15 = Field<_BRR, 15, 1>; // Port B Reset bit 15
    };

} // namespace GPIOB

// --------------------------------------------
// GPIOA: General-purpose I/Os
// Base address: 0x40020000
// --------------------------------------------

namespace GPIOA {
    static constexpr uint32_t GPIOA_BASE = 0x40020000;

    // GPIO port mode register
    struct _MODER : Register<GPIOA_BASE + 0x0, ReadWrite, _MODER> {
        using MODER15 = Field<_MODER, 30, 2>; // Port x configuration bits (y = 0..15)
        using MODER14 = Field<_MODER, 28, 2>; // Port x configuration bits (y = 0..15)
        using MODER13 = Field<_MODER, 26, 2>; // Port x configuration bits (y = 0..15)
        using MODER12 = Field<_MODER, 24, 2>; // Port x configuration bits (y = 0..15)
        using MODER11 = Field<_MODER, 22, 2>; // Port x configuration bits (y = 0..15)
        using MODER10 = Field<_MODER, 20, 2>; // Port x configuration bits (y = 0..15)
        using MODER9 = Field<_MODER, 18, 2>; // Port x configuration bits (y = 0..15)
        using MODER8 = Field<_MODER, 16, 2>; // Port x configuration bits (y = 0..15)
        using MODER7 = Field<_MODER, 14, 2>; // Port x configuration bits (y = 0..15)
        using MODER6 = Field<_MODER, 12, 2>; // Port x configuration bits (y = 0..15)
        using MODER5 = Field<_MODER, 10, 2>; // Port x configuration bits (y = 0..15)
        using MODER4 = Field<_MODER, 8, 2>; // Port x configuration bits (y = 0..15)
        using MODER3 = Field<_MODER, 6, 2>; // Port x configuration bits (y = 0..15)
        using MODER2 = Field<_MODER, 4, 2>; // Port x configuration bits (y = 0..15)
        using MODER1 = Field<_MODER, 2, 2>; // Port x configuration bits (y = 0..15)
        using MODER0 = Field<_MODER, 0, 2>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port output type register
    struct _OTYPER : Register<GPIOA_BASE + 0x4, ReadWrite, _OTYPER> {
        using OT15 = Field<_OTYPER, 15, 1>; // Port x configuration bits (y = 0..15)
        using OT14 = Field<_OTYPER, 14, 1>; // Port x configuration bits (y = 0..15)
        using OT13 = Field<_OTYPER, 13, 1>; // Port x configuration bits (y = 0..15)
        using OT12 = Field<_OTYPER, 12, 1>; // Port x configuration bits (y = 0..15)
        using OT11 = Field<_OTYPER, 11, 1>; // Port x configuration bits (y = 0..15)
        using OT10 = Field<_OTYPER, 10, 1>; // Port x configuration bits (y = 0..15)
        using OT9 = Field<_OTYPER, 9, 1>; // Port x configuration bits (y = 0..15)
        using OT8 = Field<_OTYPER, 8, 1>; // Port x configuration bits (y = 0..15)
        using OT7 = Field<_OTYPER, 7, 1>; // Port x configuration bits (y = 0..15)
        using OT6 = Field<_OTYPER, 6, 1>; // Port x configuration bits (y = 0..15)
        using OT5 = Field<_OTYPER, 5, 1>; // Port x configuration bits (y = 0..15)
        using OT4 = Field<_OTYPER, 4, 1>; // Port x configuration bits (y = 0..15)
        using OT3 = Field<_OTYPER, 3, 1>; // Port x configuration bits (y = 0..15)
        using OT2 = Field<_OTYPER, 2, 1>; // Port x configuration bits (y = 0..15)
        using OT1 = Field<_OTYPER, 1, 1>; // Port x configuration bits (y = 0..15)
        using OT0 = Field<_OTYPER, 0, 1>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port output speed register
    struct _OSPEEDR : Register<GPIOA_BASE + 0x8, ReadWrite, _OSPEEDR> {
        using OSPEEDR15 = Field<_OSPEEDR, 30, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR14 = Field<_OSPEEDR, 28, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR13 = Field<_OSPEEDR, 26, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR12 = Field<_OSPEEDR, 24, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR11 = Field<_OSPEEDR, 22, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR10 = Field<_OSPEEDR, 20, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR9 = Field<_OSPEEDR, 18, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR8 = Field<_OSPEEDR, 16, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR7 = Field<_OSPEEDR, 14, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR6 = Field<_OSPEEDR, 12, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR5 = Field<_OSPEEDR, 10, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR4 = Field<_OSPEEDR, 8, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR3 = Field<_OSPEEDR, 6, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR2 = Field<_OSPEEDR, 4, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR1 = Field<_OSPEEDR, 2, 2>; // Port x configuration bits (y = 0..15)
        using OSPEEDR0 = Field<_OSPEEDR, 0, 2>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port pull-up/pull-down register
    struct _PUPDR : Register<GPIOA_BASE + 0xC, ReadWrite, _PUPDR> {
        using PUPDR15 = Field<_PUPDR, 30, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR14 = Field<_PUPDR, 28, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR13 = Field<_PUPDR, 26, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR12 = Field<_PUPDR, 24, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR11 = Field<_PUPDR, 22, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR10 = Field<_PUPDR, 20, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR9 = Field<_PUPDR, 18, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR8 = Field<_PUPDR, 16, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR7 = Field<_PUPDR, 14, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR6 = Field<_PUPDR, 12, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR5 = Field<_PUPDR, 10, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR4 = Field<_PUPDR, 8, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR3 = Field<_PUPDR, 6, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR2 = Field<_PUPDR, 4, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR1 = Field<_PUPDR, 2, 2>; // Port x configuration bits (y = 0..15)
        using PUPDR0 = Field<_PUPDR, 0, 2>; // Port x configuration bits (y = 0..15)
    };

    // GPIO port input data register
    struct _IDR : Register<GPIOA_BASE + 0x10, ReadOnly, _IDR> {
        using IDR15 = Field<_IDR, 15, 1>; // Port input data (y = 0..15)
        using IDR14 = Field<_IDR, 14, 1>; // Port input data (y = 0..15)
        using IDR13 = Field<_IDR, 13, 1>; // Port input data (y = 0..15)
        using IDR12 = Field<_IDR, 12, 1>; // Port input data (y = 0..15)
        using IDR11 = Field<_IDR, 11, 1>; // Port input data (y = 0..15)
        using IDR10 = Field<_IDR, 10, 1>; // Port input data (y = 0..15)
        using IDR9 = Field<_IDR, 9, 1>; // Port input data (y = 0..15)
        using IDR8 = Field<_IDR, 8, 1>; // Port input data (y = 0..15)
        using IDR7 = Field<_IDR, 7, 1>; // Port input data (y = 0..15)
        using IDR6 = Field<_IDR, 6, 1>; // Port input data (y = 0..15)
        using IDR5 = Field<_IDR, 5, 1>; // Port input data (y = 0..15)
        using IDR4 = Field<_IDR, 4, 1>; // Port input data (y = 0..15)
        using IDR3 = Field<_IDR, 3, 1>; // Port input data (y = 0..15)
        using IDR2 = Field<_IDR, 2, 1>; // Port input data (y = 0..15)
        using IDR1 = Field<_IDR, 1, 1>; // Port input data (y = 0..15)
        using IDR0 = Field<_IDR, 0, 1>; // Port input data (y = 0..15)
    };

    // GPIO port output data register
    struct _ODR : Register<GPIOA_BASE + 0x14, ReadWrite, _ODR> {
        using ODR15 = Field<_ODR, 15, 1>; // Port output data (y = 0..15)
        using ODR14 = Field<_ODR, 14, 1>; // Port output data (y = 0..15)
        using ODR13 = Field<_ODR, 13, 1>; // Port output data (y = 0..15)
        using ODR12 = Field<_ODR, 12, 1>; // Port output data (y = 0..15)
        using ODR11 = Field<_ODR, 11, 1>; // Port output data (y = 0..15)
        using ODR10 = Field<_ODR, 10, 1>; // Port output data (y = 0..15)
        using ODR9 = Field<_ODR, 9, 1>; // Port output data (y = 0..15)
        using ODR8 = Field<_ODR, 8, 1>; // Port output data (y = 0..15)
        using ODR7 = Field<_ODR, 7, 1>; // Port output data (y = 0..15)
        using ODR6 = Field<_ODR, 6, 1>; // Port output data (y = 0..15)
        using ODR5 = Field<_ODR, 5, 1>; // Port output data (y = 0..15)
        using ODR4 = Field<_ODR, 4, 1>; // Port output data (y = 0..15)
        using ODR3 = Field<_ODR, 3, 1>; // Port output data (y = 0..15)
        using ODR2 = Field<_ODR, 2, 1>; // Port output data (y = 0..15)
        using ODR1 = Field<_ODR, 1, 1>; // Port output data (y = 0..15)
        using ODR0 = Field<_ODR, 0, 1>; // Port output data (y = 0..15)
    };

    // GPIO port bit set/reset register
    struct _BSRR : Register<GPIOA_BASE + 0x18, WriteOnly, _BSRR> {
        using BR15 = Field<_BSRR, 31, 1>; // Port x reset bit y (y = 0..15)
        using BR14 = Field<_BSRR, 30, 1>; // Port x reset bit y (y = 0..15)
        using BR13 = Field<_BSRR, 29, 1>; // Port x reset bit y (y = 0..15)
        using BR12 = Field<_BSRR, 28, 1>; // Port x reset bit y (y = 0..15)
        using BR11 = Field<_BSRR, 27, 1>; // Port x reset bit y (y = 0..15)
        using BR10 = Field<_BSRR, 26, 1>; // Port x reset bit y (y = 0..15)
        using BR9 = Field<_BSRR, 25, 1>; // Port x reset bit y (y = 0..15)
        using BR8 = Field<_BSRR, 24, 1>; // Port x reset bit y (y = 0..15)
        using BR7 = Field<_BSRR, 23, 1>; // Port x reset bit y (y = 0..15)
        using BR6 = Field<_BSRR, 22, 1>; // Port x reset bit y (y = 0..15)
        using BR5 = Field<_BSRR, 21, 1>; // Port x reset bit y (y = 0..15)
        using BR4 = Field<_BSRR, 20, 1>; // Port x reset bit y (y = 0..15)
        using BR3 = Field<_BSRR, 19, 1>; // Port x reset bit y (y = 0..15)
        using BR2 = Field<_BSRR, 18, 1>; // Port x reset bit y (y = 0..15)
        using BR1 = Field<_BSRR, 17, 1>; // Port x reset bit y (y = 0..15)
        using BR0 = Field<_BSRR, 16, 1>; // Port x set bit y (y= 0..15)
        using BS15 = Field<_BSRR, 15, 1>; // Port x set bit y (y= 0..15)
        using BS14 = Field<_BSRR, 14, 1>; // Port x set bit y (y= 0..15)
        using BS13 = Field<_BSRR, 13, 1>; // Port x set bit y (y= 0..15)
        using BS12 = Field<_BSRR, 12, 1>; // Port x set bit y (y= 0..15)
        using BS11 = Field<_BSRR, 11, 1>; // Port x set bit y (y= 0..15)
        using BS10 = Field<_BSRR, 10, 1>; // Port x set bit y (y= 0..15)
        using BS9 = Field<_BSRR, 9, 1>; // Port x set bit y (y= 0..15)
        using BS8 = Field<_BSRR, 8, 1>; // Port x set bit y (y= 0..15)
        using BS7 = Field<_BSRR, 7, 1>; // Port x set bit y (y= 0..15)
        using BS6 = Field<_BSRR, 6, 1>; // Port x set bit y (y= 0..15)
        using BS5 = Field<_BSRR, 5, 1>; // Port x set bit y (y= 0..15)
        using BS4 = Field<_BSRR, 4, 1>; // Port x set bit y (y= 0..15)
        using BS3 = Field<_BSRR, 3, 1>; // Port x set bit y (y= 0..15)
        using BS2 = Field<_BSRR, 2, 1>; // Port x set bit y (y= 0..15)
        using BS1 = Field<_BSRR, 1, 1>; // Port x set bit y (y= 0..15)
        using BS0 = Field<_BSRR, 0, 1>; // Port x set bit y (y= 0..15)
    };

    // GPIO port configuration lock register
    struct _LCKR : Register<GPIOA_BASE + 0x1C, ReadWrite, _LCKR> {
        using LCKK = Field<_LCKR, 16, 1>; // Port x lock bit y (y= 0..15)
        using LCK15 = Field<_LCKR, 15, 1>; // Port x lock bit y (y= 0..15)
        using LCK14 = Field<_LCKR, 14, 1>; // Port x lock bit y (y= 0..15)
        using LCK13 = Field<_LCKR, 13, 1>; // Port x lock bit y (y= 0..15)
        using LCK12 = Field<_LCKR, 12, 1>; // Port x lock bit y (y= 0..15)
        using LCK11 = Field<_LCKR, 11, 1>; // Port x lock bit y (y= 0..15)
        using LCK10 = Field<_LCKR, 10, 1>; // Port x lock bit y (y= 0..15)
        using LCK9 = Field<_LCKR, 9, 1>; // Port x lock bit y (y= 0..15)
        using LCK8 = Field<_LCKR, 8, 1>; // Port x lock bit y (y= 0..15)
        using LCK7 = Field<_LCKR, 7, 1>; // Port x lock bit y (y= 0..15)
        using LCK6 = Field<_LCKR, 6, 1>; // Port x lock bit y (y= 0..15)
        using LCK5 = Field<_LCKR, 5, 1>; // Port x lock bit y (y= 0..15)
        using LCK4 = Field<_LCKR, 4, 1>; // Port x lock bit y (y= 0..15)
        using LCK3 = Field<_LCKR, 3, 1>; // Port x lock bit y (y= 0..15)
        using LCK2 = Field<_LCKR, 2, 1>; // Port x lock bit y (y= 0..15)
        using LCK1 = Field<_LCKR, 1, 1>; // Port x lock bit y (y= 0..15)
        using LCK0 = Field<_LCKR, 0, 1>; // Port x lock bit y (y= 0..15)
    };

    // GPIO alternate function low register
    struct _AFRL : Register<GPIOA_BASE + 0x20, ReadWrite, _AFRL> {
        using AFRL7 = Field<_AFRL, 28, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL6 = Field<_AFRL, 24, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL5 = Field<_AFRL, 20, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL4 = Field<_AFRL, 16, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL3 = Field<_AFRL, 12, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL2 = Field<_AFRL, 8, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL1 = Field<_AFRL, 4, 4>; // Alternate function selection for port x bit y (y = 0..7)
        using AFRL0 = Field<_AFRL, 0, 4>; // Alternate function selection for port x bit y (y = 0..7)
    };

    // GPIO alternate function high register
    struct _AFRH : Register<GPIOA_BASE + 0x24, ReadWrite, _AFRH> {
        using AFRH15 = Field<_AFRH, 28, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH14 = Field<_AFRH, 24, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH13 = Field<_AFRH, 20, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH12 = Field<_AFRH, 16, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH11 = Field<_AFRH, 12, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH10 = Field<_AFRH, 8, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH9 = Field<_AFRH, 4, 4>; // Alternate function selection for port x bit y (y = 8..15)
        using AFRH8 = Field<_AFRH, 0, 4>; // Alternate function selection for port x bit y (y = 8..15)
    };

    // GPIO port bit reset register
    struct _BRR : Register<GPIOA_BASE + 0x28, ReadWrite, _BRR> {
        using BR0 = Field<_BRR, 0, 1>; // Port A Reset bit 0
        using BR1 = Field<_BRR, 1, 1>; // Port A Reset bit 1
        using BR2 = Field<_BRR, 2, 1>; // Port A Reset bit 2
        using BR3 = Field<_BRR, 3, 1>; // Port A Reset bit 3
        using BR4 = Field<_BRR, 4, 1>; // Port A Reset bit 4
        using BR5 = Field<_BRR, 5, 1>; // Port A Reset bit 5
        using BR6 = Field<_BRR, 6, 1>; // Port A Reset bit 6
        using BR7 = Field<_BRR, 7, 1>; // Port A Reset bit 7
        using BR8 = Field<_BRR, 8, 1>; // Port A Reset bit 8
        using BR9 = Field<_BRR, 9, 1>; // Port A Reset bit 9
        using BR10 = Field<_BRR, 10, 1>; // Port A Reset bit 10
        using BR11 = Field<_BRR, 11, 1>; // Port A Reset bit 11
        using BR12 = Field<_BRR, 12, 1>; // Port A Reset bit 12
        using BR13 = Field<_BRR, 13, 1>; // Port A Reset bit 13
        using BR14 = Field<_BRR, 14, 1>; // Port A Reset bit 14
        using BR15 = Field<_BRR, 15, 1>; // Port A Reset bit 15
    };

} // namespace GPIOA

// --------------------------------------------
// SYSCFG: System configuration controller
// Base address: 0x40013800
// --------------------------------------------

namespace SYSCFG {
    static constexpr uint32_t SYSCFG_BASE = 0x40013800;

    // memory remap register
    struct _MEMRM : Register<SYSCFG_BASE + 0x0, ReadWrite, _MEMRM> {
        using MEM_MODE = Field<_MEMRM, 0, 3>; // Memory mapping selection
        using FB_MODE = Field<_MEMRM, 8, 1>; // Flash bank mode selection
        using SWP_FMC = Field<_MEMRM, 10, 2>; // FMC memory mapping swap
    };

    // peripheral mode configuration register
    struct _PMC : Register<SYSCFG_BASE + 0x4, ReadWrite, _PMC> {
        using MII_RMII_SEL = Field<_PMC, 23, 1>; // Ethernet PHY interface selection
        using ADC1DC2 = Field<_PMC, 16, 1>; // ADC1DC2
        using ADC2DC2 = Field<_PMC, 17, 1>; // ADC2DC2
        using ADC3DC2 = Field<_PMC, 18, 1>; // ADC3DC2
    };

    // external interrupt configuration register 1
    struct _EXTICR1 : Register<SYSCFG_BASE + 0x8, ReadWrite, _EXTICR1> {
        using EXTI3 = Field<_EXTICR1, 12, 4>; // EXTI x configuration (x = 0 to 3)
        using EXTI2 = Field<_EXTICR1, 8, 4>; // EXTI x configuration (x = 0 to 3)
        using EXTI1 = Field<_EXTICR1, 4, 4>; // EXTI x configuration (x = 0 to 3)
        using EXTI0 = Field<_EXTICR1, 0, 4>; // EXTI x configuration (x = 0 to 3)
    };

    // external interrupt configuration register 2
    struct _EXTICR2 : Register<SYSCFG_BASE + 0xC, ReadWrite, _EXTICR2> {
        using EXTI7 = Field<_EXTICR2, 12, 4>; // EXTI x configuration (x = 4 to 7)
        using EXTI6 = Field<_EXTICR2, 8, 4>; // EXTI x configuration (x = 4 to 7)
        using EXTI5 = Field<_EXTICR2, 4, 4>; // EXTI x configuration (x = 4 to 7)
        using EXTI4 = Field<_EXTICR2, 0, 4>; // EXTI x configuration (x = 4 to 7)
    };

    // external interrupt configuration register 3
    struct _EXTICR3 : Register<SYSCFG_BASE + 0x10, ReadWrite, _EXTICR3> {
        using EXTI11 = Field<_EXTICR3, 12, 4>; // EXTI x configuration (x = 8 to 11)
        using EXTI10 = Field<_EXTICR3, 8, 4>; // EXTI10
        using EXTI9 = Field<_EXTICR3, 4, 4>; // EXTI x configuration (x = 8 to 11)
        using EXTI8 = Field<_EXTICR3, 0, 4>; // EXTI x configuration (x = 8 to 11)
    };

    // external interrupt configuration register 4
    struct _EXTICR4 : Register<SYSCFG_BASE + 0x14, ReadWrite, _EXTICR4> {
        using EXTI15 = Field<_EXTICR4, 12, 4>; // EXTI x configuration (x = 12 to 15)
        using EXTI14 = Field<_EXTICR4, 8, 4>; // EXTI x configuration (x = 12 to 15)
        using EXTI13 = Field<_EXTICR4, 4, 4>; // EXTI x configuration (x = 12 to 15)
        using EXTI12 = Field<_EXTICR4, 0, 4>; // EXTI x configuration (x = 12 to 15)
    };

    // Compensation cell control register
    struct _CMPCR : Register<SYSCFG_BASE + 0x20, ReadOnly, _CMPCR> {
        using READY = Field<_CMPCR, 8, 1>; // READY
        using CMP_PD = Field<_CMPCR, 0, 1>; // Compensation cell power-down
    };

} // namespace SYSCFG

// --------------------------------------------
// SPI1: Serial peripheral interface
// Base address: 0x40013000
// --------------------------------------------

namespace SPI1 {
    static constexpr uint32_t SPI1_BASE = 0x40013000;

    // control register 1
    struct _CR1 : Register<SPI1_BASE + 0x0, ReadWrite, _CR1> {
        using BIDIMODE = Field<_CR1, 15, 1>; // Bidirectional data mode enable
        using BIDIOE = Field<_CR1, 14, 1>; // Output enable in bidirectional mode
        using CRCEN = Field<_CR1, 13, 1>; // Hardware CRC calculation enable
        using CRCNEXT = Field<_CR1, 12, 1>; // CRC transfer next
        using CRCL = Field<_CR1, 11, 1>; // CRC length
        using RXONLY = Field<_CR1, 10, 1>; // Receive only
        using SSM = Field<_CR1, 9, 1>; // Software slave management
        using SSI = Field<_CR1, 8, 1>; // Internal slave select
        using LSBFIRST = Field<_CR1, 7, 1>; // Frame format
        using SPE = Field<_CR1, 6, 1>; // SPI enable
        using BR = Field<_CR1, 3, 3>; // Baud rate control
        using MSTR = Field<_CR1, 2, 1>; // Master selection
        using CPOL = Field<_CR1, 1, 1>; // Clock polarity
        using CPHA = Field<_CR1, 0, 1>; // Clock phase
    };

    // control register 2
    struct _CR2 : Register<SPI1_BASE + 0x4, ReadWrite, _CR2> {
        using RXDMAEN = Field<_CR2, 0, 1>; // Rx buffer DMA enable
        using TXDMAEN = Field<_CR2, 1, 1>; // Tx buffer DMA enable
        using SSOE = Field<_CR2, 2, 1>; // SS output enable
        using NSSP = Field<_CR2, 3, 1>; // NSS pulse management
        using FRF = Field<_CR2, 4, 1>; // Frame format
        using ERRIE = Field<_CR2, 5, 1>; // Error interrupt enable
        using RXNEIE = Field<_CR2, 6, 1>; // RX buffer not empty interrupt enable
        using TXEIE = Field<_CR2, 7, 1>; // Tx buffer empty interrupt enable
        using DS = Field<_CR2, 8, 4>; // Data size
        using FRXTH = Field<_CR2, 12, 1>; // FIFO reception threshold
        using LDMA_RX = Field<_CR2, 13, 1>; // Last DMA transfer for reception
        using LDMA_TX = Field<_CR2, 14, 1>; // Last DMA transfer for transmission
    };

    // status register
    struct _SR : Register<SPI1_BASE + 0x8, ReadWrite, _SR> {
        using FRE = Field<_SR, 8, 1>; // Frame format error
        using BSY = Field<_SR, 7, 1>; // Busy flag
        using OVR = Field<_SR, 6, 1>; // Overrun flag
        using MODF = Field<_SR, 5, 1>; // Mode fault
        using CRCERR = Field<_SR, 4, 1>; // CRC error flag
        using UDR = Field<_SR, 3, 1>; // Underrun flag
        using CHSIDE = Field<_SR, 2, 1>; // Channel side
        using TXE = Field<_SR, 1, 1>; // Transmit buffer empty
        using RXNE = Field<_SR, 0, 1>; // Receive buffer not empty
        using FRLVL = Field<_SR, 9, 2>; // FIFO reception level
        using FTLVL = Field<_SR, 11, 2>; // FIFO Transmission Level
    };

    // data register
    struct _DR : Register<SPI1_BASE + 0xC, ReadWrite, _DR> {
        using DR = Field<_DR, 0, 16>; // Data register
    };

    // CRC polynomial register
    struct _CRCPR : Register<SPI1_BASE + 0x10, ReadWrite, _CRCPR> {
        using CRCPOLY = Field<_CRCPR, 0, 16>; // CRC polynomial register
    };

    // RX CRC register
    struct _RXCRCR : Register<SPI1_BASE + 0x14, ReadOnly, _RXCRCR> {
        using RxCRC = Field<_RXCRCR, 0, 16>; // Rx CRC register
    };

    // TX CRC register
    struct _TXCRCR : Register<SPI1_BASE + 0x18, ReadOnly, _TXCRCR> {
        using TxCRC = Field<_TXCRCR, 0, 16>; // Tx CRC register
    };

    // I2S configuration register
    struct _I2SCFGR : Register<SPI1_BASE + 0x1C, ReadWrite, _I2SCFGR> {
        using I2SMOD = Field<_I2SCFGR, 11, 1>; // I2S mode selection
        using I2SE = Field<_I2SCFGR, 10, 1>; // I2S Enable
        using I2SCFG = Field<_I2SCFGR, 8, 2>; // I2S configuration mode
        using PCMSYNC = Field<_I2SCFGR, 7, 1>; // PCM frame synchronization
        using I2SSTD = Field<_I2SCFGR, 4, 2>; // I2S standard selection
        using CKPOL = Field<_I2SCFGR, 3, 1>; // Steady state clock polarity
        using DATLEN = Field<_I2SCFGR, 1, 2>; // Data length to be transferred
        using CHLEN = Field<_I2SCFGR, 0, 1>; // Channel length (number of bits per audio channel)
        using ASTRTEN = Field<_I2SCFGR, 12, 1>; // Asynchronous start enable
    };

    // I2S prescaler register
    struct _I2SPR : Register<SPI1_BASE + 0x20, ReadWrite, _I2SPR> {
        using MCKOE = Field<_I2SPR, 9, 1>; // Master clock output enable
        using ODD = Field<_I2SPR, 8, 1>; // Odd factor for the prescaler
        using I2SDIV = Field<_I2SPR, 0, 8>; // I2S Linear prescaler
    };

} // namespace SPI1

// --------------------------------------------
// SPI2: 
// Base address: 0x40003800
// --------------------------------------------

namespace SPI2 {
    static constexpr uint32_t SPI2_BASE = 0x40003800;

} // namespace SPI2

// --------------------------------------------
// SPI4: 
// Base address: 0x40013400
// --------------------------------------------

namespace SPI4 {
    static constexpr uint32_t SPI4_BASE = 0x40013400;

} // namespace SPI4

// --------------------------------------------
// SPI5: 
// Base address: 0x40015000
// --------------------------------------------

namespace SPI5 {
    static constexpr uint32_t SPI5_BASE = 0x40015000;

} // namespace SPI5

// --------------------------------------------
// SPI3: 
// Base address: 0x40003C00
// --------------------------------------------

namespace SPI3 {
    static constexpr uint32_t SPI3_BASE = 0x40003C00;

} // namespace SPI3

// --------------------------------------------
// SPI6: 
// Base address: 0x40015400
// --------------------------------------------

namespace SPI6 {
    static constexpr uint32_t SPI6_BASE = 0x40015400;

} // namespace SPI6

// --------------------------------------------
// ADC1: Analog-to-digital converter
// Base address: 0x40012000
// --------------------------------------------

namespace ADC1 {
    static constexpr uint32_t ADC1_BASE = 0x40012000;

    // status register
    struct _SR : Register<ADC1_BASE + 0x0, ReadWrite, _SR> {
        using OVR = Field<_SR, 5, 1>; // Overrun
        using STRT = Field<_SR, 4, 1>; // Regular channel start flag
        using JSTRT = Field<_SR, 3, 1>; // Injected channel start flag
        using JEOC = Field<_SR, 2, 1>; // Injected channel end of conversion
        using EOC = Field<_SR, 1, 1>; // Regular channel end of conversion
        using AWD = Field<_SR, 0, 1>; // Analog watchdog flag
    };

    // control register 1
    struct _CR1 : Register<ADC1_BASE + 0x4, ReadWrite, _CR1> {
        using OVRIE = Field<_CR1, 26, 1>; // Overrun interrupt enable
        using RES = Field<_CR1, 24, 2>; // Resolution
        using AWDEN = Field<_CR1, 23, 1>; // Analog watchdog enable on regular channels
        using JAWDEN = Field<_CR1, 22, 1>; // Analog watchdog enable on injected channels
        using DISCNUM = Field<_CR1, 13, 3>; // Discontinuous mode channel count
        using JDISCEN = Field<_CR1, 12, 1>; // Discontinuous mode on injected channels
        using DISCEN = Field<_CR1, 11, 1>; // Discontinuous mode on regular channels
        using JAUTO = Field<_CR1, 10, 1>; // Automatic injected group conversion
        using AWDSGL = Field<_CR1, 9, 1>; // Enable the watchdog on a single channel in scan mode
        using SCAN = Field<_CR1, 8, 1>; // Scan mode
        using JEOCIE = Field<_CR1, 7, 1>; // Interrupt enable for injected channels
        using AWDIE = Field<_CR1, 6, 1>; // Analog watchdog interrupt enable
        using EOCIE = Field<_CR1, 5, 1>; // Interrupt enable for EOC
        using AWDCH = Field<_CR1, 0, 5>; // Analog watchdog channel select bits
    };

    // control register 2
    struct _CR2 : Register<ADC1_BASE + 0x8, ReadWrite, _CR2> {
        using SWSTART = Field<_CR2, 30, 1>; // Start conversion of regular channels
        using EXTEN = Field<_CR2, 28, 2>; // External trigger enable for regular channels
        using EXTSEL = Field<_CR2, 24, 4>; // External event select for regular group
        using JSWSTART = Field<_CR2, 22, 1>; // Start conversion of injected channels
        using JEXTEN = Field<_CR2, 20, 2>; // External trigger enable for injected channels
        using JEXTSEL = Field<_CR2, 16, 4>; // External event select for injected group
        using ALIGN = Field<_CR2, 11, 1>; // Data alignment
        using EOCS = Field<_CR2, 10, 1>; // End of conversion selection
        using DDS = Field<_CR2, 9, 1>; // DMA disable selection (for single ADC mode)
        using DMA = Field<_CR2, 8, 1>; // Direct memory access mode (for single ADC mode)
        using CONT = Field<_CR2, 1, 1>; // Continuous conversion
        using ADON = Field<_CR2, 0, 1>; // A/D Converter ON / OFF
    };

    // sample time register 1
    struct _SMPR1 : Register<ADC1_BASE + 0xC, ReadWrite, _SMPR1> {
        using SMPx_x = Field<_SMPR1, 0, 32>; // Sample time bits
    };

    // sample time register 2
    struct _SMPR2 : Register<ADC1_BASE + 0x10, ReadWrite, _SMPR2> {
        using SMPx_x = Field<_SMPR2, 0, 32>; // Sample time bits
    };

    // injected channel data offset register x
    struct _JOFR1 : Register<ADC1_BASE + 0x14, ReadWrite, _JOFR1> {
        using JOFFSET1 = Field<_JOFR1, 0, 12>; // Data offset for injected channel x
    };

    // injected channel data offset register x
    struct _JOFR2 : Register<ADC1_BASE + 0x18, ReadWrite, _JOFR2> {
        using JOFFSET2 = Field<_JOFR2, 0, 12>; // Data offset for injected channel x
    };

    // injected channel data offset register x
    struct _JOFR3 : Register<ADC1_BASE + 0x1C, ReadWrite, _JOFR3> {
        using JOFFSET3 = Field<_JOFR3, 0, 12>; // Data offset for injected channel x
    };

    // injected channel data offset register x
    struct _JOFR4 : Register<ADC1_BASE + 0x20, ReadWrite, _JOFR4> {
        using JOFFSET4 = Field<_JOFR4, 0, 12>; // Data offset for injected channel x
    };

    // watchdog higher threshold register
    struct _HTR : Register<ADC1_BASE + 0x24, ReadWrite, _HTR> {
        using HT = Field<_HTR, 0, 12>; // Analog watchdog higher threshold
    };

    // watchdog lower threshold register
    struct _LTR : Register<ADC1_BASE + 0x28, ReadWrite, _LTR> {
        using LT = Field<_LTR, 0, 12>; // Analog watchdog lower threshold
    };

    // regular sequence register 1
    struct _SQR1 : Register<ADC1_BASE + 0x2C, ReadWrite, _SQR1> {
        using L = Field<_SQR1, 20, 4>; // Regular channel sequence length
        using SQ16 = Field<_SQR1, 15, 5>; // 16th conversion in regular sequence
        using SQ15 = Field<_SQR1, 10, 5>; // 15th conversion in regular sequence
        using SQ14 = Field<_SQR1, 5, 5>; // 14th conversion in regular sequence
        using SQ13 = Field<_SQR1, 0, 5>; // 13th conversion in regular sequence
    };

    // regular sequence register 2
    struct _SQR2 : Register<ADC1_BASE + 0x30, ReadWrite, _SQR2> {
        using SQ12 = Field<_SQR2, 25, 5>; // 12th conversion in regular sequence
        using SQ11 = Field<_SQR2, 20, 5>; // 11th conversion in regular sequence
        using SQ10 = Field<_SQR2, 15, 5>; // 10th conversion in regular sequence
        using SQ9 = Field<_SQR2, 10, 5>; // 9th conversion in regular sequence
        using SQ8 = Field<_SQR2, 5, 5>; // 8th conversion in regular sequence
        using SQ7 = Field<_SQR2, 0, 5>; // 7th conversion in regular sequence
    };

    // regular sequence register 3
    struct _SQR3 : Register<ADC1_BASE + 0x34, ReadWrite, _SQR3> {
        using SQ6 = Field<_SQR3, 25, 5>; // 6th conversion in regular sequence
        using SQ5 = Field<_SQR3, 20, 5>; // 5th conversion in regular sequence
        using SQ4 = Field<_SQR3, 15, 5>; // 4th conversion in regular sequence
        using SQ3 = Field<_SQR3, 10, 5>; // 3rd conversion in regular sequence
        using SQ2 = Field<_SQR3, 5, 5>; // 2nd conversion in regular sequence
        using SQ1 = Field<_SQR3, 0, 5>; // 1st conversion in regular sequence
    };

    // injected sequence register
    struct _JSQR : Register<ADC1_BASE + 0x38, ReadWrite, _JSQR> {
        using JL = Field<_JSQR, 20, 2>; // Injected sequence length
        using JSQ4 = Field<_JSQR, 15, 5>; // 4th conversion in injected sequence
        using JSQ3 = Field<_JSQR, 10, 5>; // 3rd conversion in injected sequence
        using JSQ2 = Field<_JSQR, 5, 5>; // 2nd conversion in injected sequence
        using JSQ1 = Field<_JSQR, 0, 5>; // 1st conversion in injected sequence
    };

    // injected data register x
    struct _JDR1 : Register<ADC1_BASE + 0x3C, ReadOnly, _JDR1> {
        using JDATA = Field<_JDR1, 0, 16>; // Injected data
    };

    // injected data register x
    struct _JDR2 : Register<ADC1_BASE + 0x40, ReadOnly, _JDR2> {
        using JDATA = Field<_JDR2, 0, 16>; // Injected data
    };

    // injected data register x
    struct _JDR3 : Register<ADC1_BASE + 0x44, ReadOnly, _JDR3> {
        using JDATA = Field<_JDR3, 0, 16>; // Injected data
    };

    // injected data register x
    struct _JDR4 : Register<ADC1_BASE + 0x48, ReadOnly, _JDR4> {
        using JDATA = Field<_JDR4, 0, 16>; // Injected data
    };

    // regular data register
    struct _DR : Register<ADC1_BASE + 0x4C, ReadOnly, _DR> {
        using DATA = Field<_DR, 0, 16>; // Regular data
    };

} // namespace ADC1

// --------------------------------------------
// ADC2: 
// Base address: 0x40012100
// --------------------------------------------

namespace ADC2 {
    static constexpr uint32_t ADC2_BASE = 0x40012100;

} // namespace ADC2

// --------------------------------------------
// ADC3: 
// Base address: 0x40012200
// --------------------------------------------

namespace ADC3 {
    static constexpr uint32_t ADC3_BASE = 0x40012200;

} // namespace ADC3

// --------------------------------------------
// ADC_Common: Common ADC registers
// Base address: 0x40012300
// --------------------------------------------

namespace ADC_Common {
    static constexpr uint32_t ADC_Common_BASE = 0x40012300;

    // ADC Common status register
    struct _CSR : Register<ADC_Common_BASE + 0x0, ReadOnly, _CSR> {
        using AWD1 = Field<_CSR, 0, 1>; // AWD1
        using EOC1 = Field<_CSR, 1, 1>; // EOC1
        using JEOC1 = Field<_CSR, 2, 1>; // JEOC1
        using JSTRT1 = Field<_CSR, 3, 1>; // JSTRT1
        using STRT1 = Field<_CSR, 4, 1>; // STRT1
        using OVR1 = Field<_CSR, 5, 1>; // OVR1
        using AWD2 = Field<_CSR, 8, 1>; // AWD2
        using EOC2 = Field<_CSR, 9, 1>; // EOC2
        using JEOC2 = Field<_CSR, 10, 1>; // JEOC2
        using JSTRT2 = Field<_CSR, 11, 1>; // JSTRT2
        using STRT2 = Field<_CSR, 12, 1>; // STRT2
        using OVR2 = Field<_CSR, 13, 1>; // OVR2
        using AWD3 = Field<_CSR, 16, 1>; // AWD3
        using EOC3 = Field<_CSR, 17, 1>; // EOC3
        using JEOC3 = Field<_CSR, 18, 1>; // JEOC3
        using JSTRT3 = Field<_CSR, 19, 1>; // JSTRT3
        using STRT3 = Field<_CSR, 20, 1>; // STRT3
        using OVR3 = Field<_CSR, 21, 1>; // OVR3
    };

    // ADC common control register
    struct _CCR : Register<ADC_Common_BASE + 0x4, ReadWrite, _CCR> {
        using MULTI = Field<_CCR, 0, 5>; // MULTI
        using DELAY = Field<_CCR, 8, 4>; // DELAY
        using DDS = Field<_CCR, 13, 1>; // DDS
        using DMA = Field<_CCR, 14, 2>; // DMA
        using ADCPRE = Field<_CCR, 16, 2>; // ADCPRE
        using VBATE = Field<_CCR, 22, 1>; // VBATE
        using TSVREFE = Field<_CCR, 23, 1>; // TSVREFE
    };

    // ADC common regular data register for dual and triple modes
    struct _CDR : Register<ADC_Common_BASE + 0x8, ReadOnly, _CDR> {
        using DATA1 = Field<_CDR, 0, 16>; // DATA1
        using DATA2 = Field<_CDR, 16, 16>; // DATA2
    };

} // namespace ADC_Common

// --------------------------------------------
// DAC: Digital-to-analog converter
// Base address: 0x40007400
// --------------------------------------------

namespace DAC {
    static constexpr uint32_t DAC_BASE = 0x40007400;

    // control register
    struct _CR : Register<DAC_BASE + 0x0, ReadWrite, _CR> {
        using DMAUDRIE2 = Field<_CR, 29, 1>; // DAC channel2 DMA underrun interrupt enable
        using DMAEN2 = Field<_CR, 28, 1>; // DAC channel2 DMA enable
        using MAMP2 = Field<_CR, 24, 4>; // DAC channel2 mask/amplitude selector
        using WAVE2 = Field<_CR, 22, 2>; // DAC channel2 noise/triangle wave generation enable
        using TSEL2 = Field<_CR, 19, 3>; // DAC channel2 trigger selection
        using TEN2 = Field<_CR, 18, 1>; // DAC channel2 trigger enable
        using BOFF2 = Field<_CR, 17, 1>; // DAC channel2 output buffer disable
        using EN2 = Field<_CR, 16, 1>; // DAC channel2 enable
        using DMAUDRIE1 = Field<_CR, 13, 1>; // DAC channel1 DMA Underrun Interrupt enable
        using DMAEN1 = Field<_CR, 12, 1>; // DAC channel1 DMA enable
        using MAMP1 = Field<_CR, 8, 4>; // DAC channel1 mask/amplitude selector
        using WAVE1 = Field<_CR, 6, 2>; // DAC channel1 noise/triangle wave generation enable
        using TSEL1 = Field<_CR, 3, 3>; // DAC channel1 trigger selection
        using TEN1 = Field<_CR, 2, 1>; // DAC channel1 trigger enable
        using BOFF1 = Field<_CR, 1, 1>; // DAC channel1 output buffer disable
        using EN1 = Field<_CR, 0, 1>; // DAC channel1 enable
    };

    // software trigger register
    struct _SWTRIGR : Register<DAC_BASE + 0x4, WriteOnly, _SWTRIGR> {
        using SWTRIG2 = Field<_SWTRIGR, 1, 1>; // DAC channel2 software trigger
        using SWTRIG1 = Field<_SWTRIGR, 0, 1>; // DAC channel1 software trigger
    };

    // channel1 12-bit right-aligned data holding register
    struct _DHR12R1 : Register<DAC_BASE + 0x8, ReadWrite, _DHR12R1> {
        using DACC1DHR = Field<_DHR12R1, 0, 12>; // DAC channel1 12-bit right-aligned data
    };

    // channel1 12-bit left aligned data holding register
    struct _DHR12L1 : Register<DAC_BASE + 0xC, ReadWrite, _DHR12L1> {
        using DACC1DHR = Field<_DHR12L1, 4, 12>; // DAC channel1 12-bit left-aligned data
    };

    // channel1 8-bit right aligned data holding register
    struct _DHR8R1 : Register<DAC_BASE + 0x10, ReadWrite, _DHR8R1> {
        using DACC1DHR = Field<_DHR8R1, 0, 8>; // DAC channel1 8-bit right-aligned data
    };

    // channel2 12-bit right aligned data holding register
    struct _DHR12R2 : Register<DAC_BASE + 0x14, ReadWrite, _DHR12R2> {
        using DACC2DHR = Field<_DHR12R2, 0, 12>; // DAC channel2 12-bit right-aligned data
    };

    // channel2 12-bit left aligned data holding register
    struct _DHR12L2 : Register<DAC_BASE + 0x18, ReadWrite, _DHR12L2> {
        using DACC2DHR = Field<_DHR12L2, 4, 12>; // DAC channel2 12-bit left-aligned data
    };

    // channel2 8-bit right-aligned data holding register
    struct _DHR8R2 : Register<DAC_BASE + 0x1C, ReadWrite, _DHR8R2> {
        using DACC2DHR = Field<_DHR8R2, 0, 8>; // DAC channel2 8-bit right-aligned data
    };

    // Dual DAC 12-bit right-aligned data holding register
    struct _DHR12RD : Register<DAC_BASE + 0x20, ReadWrite, _DHR12RD> {
        using DACC2DHR = Field<_DHR12RD, 16, 12>; // DAC channel2 12-bit right-aligned data
        using DACC1DHR = Field<_DHR12RD, 0, 12>; // DAC channel1 12-bit right-aligned data
    };

    // DUAL DAC 12-bit left aligned data holding register
    struct _DHR12LD : Register<DAC_BASE + 0x24, ReadWrite, _DHR12LD> {
        using DACC2DHR = Field<_DHR12LD, 20, 12>; // DAC channel2 12-bit left-aligned data
        using DACC1DHR = Field<_DHR12LD, 4, 12>; // DAC channel1 12-bit left-aligned data
    };

    // DUAL DAC 8-bit right aligned data holding register
    struct _DHR8RD : Register<DAC_BASE + 0x28, ReadWrite, _DHR8RD> {
        using DACC2DHR = Field<_DHR8RD, 8, 8>; // DAC channel2 8-bit right-aligned data
        using DACC1DHR = Field<_DHR8RD, 0, 8>; // DAC channel1 8-bit right-aligned data
    };

    // channel1 data output register
    struct _DOR1 : Register<DAC_BASE + 0x2C, ReadOnly, _DOR1> {
        using DACC1DOR = Field<_DOR1, 0, 12>; // DAC channel1 data output
    };

    // channel2 data output register
    struct _DOR2 : Register<DAC_BASE + 0x30, ReadOnly, _DOR2> {
        using DACC2DOR = Field<_DOR2, 0, 12>; // DAC channel2 data output
    };

    // status register
    struct _SR : Register<DAC_BASE + 0x34, ReadWrite, _SR> {
        using DMAUDR2 = Field<_SR, 29, 1>; // DAC channel2 DMA underrun flag
        using DMAUDR1 = Field<_SR, 13, 1>; // DAC channel1 DMA underrun flag
    };

} // namespace DAC

// --------------------------------------------
// PWR: Power control
// Base address: 0x40007000
// --------------------------------------------

namespace PWR {
    static constexpr uint32_t PWR_BASE = 0x40007000;

    // power control register
    struct _CR1 : Register<PWR_BASE + 0x0, ReadWrite, _CR1> {
        using LPDS = Field<_CR1, 0, 1>; // Low-power deep sleep
        using PDDS = Field<_CR1, 1, 1>; // Power down deepsleep
        using CSBF = Field<_CR1, 3, 1>; // Clear standby flag
        using PVDE = Field<_CR1, 4, 1>; // Power voltage detector enable
        using PLS = Field<_CR1, 5, 3>; // PVD level selection
        using DBP = Field<_CR1, 8, 1>; // Disable backup domain write protection
        using FPDS = Field<_CR1, 9, 1>; // Flash power down in Stop mode
        using LPUDS = Field<_CR1, 10, 1>; // Low-power regulator in deepsleep under-drive mode
        using MRUDS = Field<_CR1, 11, 1>; // Main regulator in deepsleep under-drive mode
        using ADCDC1 = Field<_CR1, 13, 1>; // ADCDC1
        using VOS = Field<_CR1, 14, 2>; // Regulator voltage scaling output selection
        using ODEN = Field<_CR1, 16, 1>; // Over-drive enable
        using ODSWEN = Field<_CR1, 17, 1>; // Over-drive switching enabled
        using UDEN = Field<_CR1, 18, 2>; // Under-drive enable in stop mode
    };

    // power control/status register
    struct _CSR1 : Register<PWR_BASE + 0x4, ReadWrite, _CSR1> {
        using WUIF = Field<_CSR1, 0, 1>; // Wakeup internal flag
        using SBF = Field<_CSR1, 1, 1>; // Standby flag
        using PVDO = Field<_CSR1, 2, 1>; // PVD output
        using BRR = Field<_CSR1, 3, 1>; // Backup regulator ready
        using BRE = Field<_CSR1, 9, 1>; // Backup regulator enable
        using VOSRDY = Field<_CSR1, 14, 1>; // Regulator voltage scaling output selection ready bit
        using ODRDY = Field<_CSR1, 16, 1>; // Over-drive mode ready
        using ODSWRDY = Field<_CSR1, 17, 1>; // Over-drive mode switching ready
        using UDRDY = Field<_CSR1, 18, 2>; // Under-drive ready flag
    };

    // power control register
    struct _CR2 : Register<PWR_BASE + 0x8, ReadWrite, _CR2> {
        using CWUPF1 = Field<_CR2, 0, 1>; // Clear Wakeup Pin flag for PA0
        using CWUPF2 = Field<_CR2, 1, 1>; // Clear Wakeup Pin flag for PA2
        using CWUPF3 = Field<_CR2, 2, 1>; // Clear Wakeup Pin flag for PC1
        using CWUPF4 = Field<_CR2, 3, 1>; // Clear Wakeup Pin flag for PC13
        using CWUPF5 = Field<_CR2, 4, 1>; // Clear Wakeup Pin flag for PI8
        using CWUPF6 = Field<_CR2, 5, 1>; // Clear Wakeup Pin flag for PI11
        using WUPP1 = Field<_CR2, 8, 1>; // Wakeup pin polarity bit for PA0
        using WUPP2 = Field<_CR2, 9, 1>; // Wakeup pin polarity bit for PA2
        using WUPP3 = Field<_CR2, 10, 1>; // Wakeup pin polarity bit for PC1
        using WUPP4 = Field<_CR2, 11, 1>; // Wakeup pin polarity bit for PC13
        using WUPP5 = Field<_CR2, 12, 1>; // Wakeup pin polarity bit for PI8
        using WUPP6 = Field<_CR2, 13, 1>; // Wakeup pin polarity bit for PI11
    };

    // power control/status register
    struct _CSR2 : Register<PWR_BASE + 0xC, ReadWrite, _CSR2> {
        using WUPF1 = Field<_CSR2, 0, 1>; // Wakeup Pin flag for PA0
        using WUPF2 = Field<_CSR2, 1, 1>; // Wakeup Pin flag for PA2
        using WUPF3 = Field<_CSR2, 2, 1>; // Wakeup Pin flag for PC1
        using WUPF4 = Field<_CSR2, 3, 1>; // Wakeup Pin flag for PC13
        using WUPF5 = Field<_CSR2, 4, 1>; // Wakeup Pin flag for PI8
        using WUPF6 = Field<_CSR2, 5, 1>; // Wakeup Pin flag for PI11
        using EWUP1 = Field<_CSR2, 8, 1>; // Enable Wakeup pin for PA0
        using EWUP2 = Field<_CSR2, 9, 1>; // Enable Wakeup pin for PA2
        using EWUP3 = Field<_CSR2, 10, 1>; // Enable Wakeup pin for PC1
        using EWUP4 = Field<_CSR2, 11, 1>; // Enable Wakeup pin for PC13
        using EWUP5 = Field<_CSR2, 12, 1>; // Enable Wakeup pin for PI8
        using EWUP6 = Field<_CSR2, 13, 1>; // Enable Wakeup pin for PI11
    };

} // namespace PWR

// --------------------------------------------
// IWDG: Independent watchdog
// Base address: 0x40003000
// --------------------------------------------

namespace IWDG {
    static constexpr uint32_t IWDG_BASE = 0x40003000;

    // Key register
    struct _KR : Register<IWDG_BASE + 0x0, WriteOnly, _KR> {
        using KEY = Field<_KR, 0, 16>; // Key value (write only, read 0000h)
    };

    // Prescaler register
    struct _PR : Register<IWDG_BASE + 0x4, ReadWrite, _PR> {
        using PR = Field<_PR, 0, 3>; // Prescaler divider
    };

    // Reload register
    struct _RLR : Register<IWDG_BASE + 0x8, ReadWrite, _RLR> {
        using RL = Field<_RLR, 0, 12>; // Watchdog counter reload value
    };

    // Status register
    struct _SR : Register<IWDG_BASE + 0xC, ReadOnly, _SR> {
        using RVU = Field<_SR, 1, 1>; // Watchdog counter reload value update
        using PVU = Field<_SR, 0, 1>; // Watchdog prescaler value update
    };

    // Window register
    struct _WINR : Register<IWDG_BASE + 0x10, ReadWrite, _WINR> {
        using WIN = Field<_WINR, 0, 12>; // Watchdog counter window value
    };

} // namespace IWDG

// --------------------------------------------
// WWDG: Window watchdog
// Base address: 0x40002C00
// --------------------------------------------

namespace WWDG {
    static constexpr uint32_t WWDG_BASE = 0x40002C00;

    // Control register
    struct _CR : Register<WWDG_BASE + 0x0, ReadWrite, _CR> {
        using WDGA = Field<_CR, 7, 1>; // Activation bit
        using T = Field<_CR, 0, 7>; // 7-bit counter (MSB to LSB)
    };

    // Configuration register
    struct _CFR : Register<WWDG_BASE + 0x4, ReadWrite, _CFR> {
        using EWI = Field<_CFR, 9, 1>; // Early wakeup interrupt
        using WDGTB1 = Field<_CFR, 8, 1>; // Timer base
        using WDGTB0 = Field<_CFR, 7, 1>; // Timer base
        using W = Field<_CFR, 0, 7>; // 7-bit window value
    };

    // Status register
    struct _SR : Register<WWDG_BASE + 0x8, ReadWrite, _SR> {
        using EWIF = Field<_SR, 0, 1>; // Early wakeup interrupt flag
    };

} // namespace WWDG

// --------------------------------------------
// TIM1: Advanced-timers
// Base address: 0x40010000
// --------------------------------------------

namespace TIM1 {
    static constexpr uint32_t TIM1_BASE = 0x40010000;

    // control register 1
    struct _CR1 : Register<TIM1_BASE + 0x0, ReadWrite, _CR1> {
        using CKD = Field<_CR1, 8, 2>; // Clock division
        using ARPE = Field<_CR1, 7, 1>; // Auto-reload preload enable
        using CMS = Field<_CR1, 5, 2>; // Center-aligned mode selection
        using DIR = Field<_CR1, 4, 1>; // Direction
        using OPM = Field<_CR1, 3, 1>; // One-pulse mode
        using URS = Field<_CR1, 2, 1>; // Update request source
        using UDIS = Field<_CR1, 1, 1>; // Update disable
        using CEN = Field<_CR1, 0, 1>; // Counter enable
    };

    // control register 2
    struct _CR2 : Register<TIM1_BASE + 0x4, ReadWrite, _CR2> {
        using MMS2 = Field<_CR2, 20, 4>; // Master mode selection 2
        using OIS6 = Field<_CR2, 18, 1>; // Output Idle state 6
        using OIS5 = Field<_CR2, 16, 1>; // Output Idle state 5
        using OIS4 = Field<_CR2, 14, 1>; // Output Idle state 4
        using OIS3N = Field<_CR2, 13, 1>; // Output Idle state 3
        using OIS3 = Field<_CR2, 12, 1>; // Output Idle state 3
        using OIS2N = Field<_CR2, 11, 1>; // Output Idle state 2
        using OIS2 = Field<_CR2, 10, 1>; // Output Idle state 2
        using OIS1N = Field<_CR2, 9, 1>; // Output Idle state 1
        using OIS1 = Field<_CR2, 8, 1>; // Output Idle state 1
        using TI1S = Field<_CR2, 7, 1>; // TI1 selection
        using MMS = Field<_CR2, 4, 3>; // Master mode selection
        using CCDS = Field<_CR2, 3, 1>; // Capture/compare DMA selection
        using CCUS = Field<_CR2, 2, 1>; // Capture/compare control update selection
        using CCPC = Field<_CR2, 0, 1>; // Capture/compare preloaded control
    };

    // slave mode control register
    struct _SMCR : Register<TIM1_BASE + 0x8, ReadWrite, _SMCR> {
        using ETP = Field<_SMCR, 15, 1>; // External trigger polarity
        using ECE = Field<_SMCR, 14, 1>; // External clock enable
        using ETPS = Field<_SMCR, 12, 2>; // External trigger prescaler
        using ETF = Field<_SMCR, 8, 4>; // External trigger filter
        using MSM = Field<_SMCR, 7, 1>; // Master/Slave mode
        using TS = Field<_SMCR, 4, 3>; // Trigger selection
        using SMS = Field<_SMCR, 0, 3>; // Slave mode selection
    };

    // DMA/Interrupt enable register
    struct _DIER : Register<TIM1_BASE + 0xC, ReadWrite, _DIER> {
        using TDE = Field<_DIER, 14, 1>; // Trigger DMA request enable
        using COMDE = Field<_DIER, 13, 1>; // COM DMA request enable
        using CC4DE = Field<_DIER, 12, 1>; // Capture/Compare 4 DMA request enable
        using CC3DE = Field<_DIER, 11, 1>; // Capture/Compare 3 DMA request enable
        using CC2DE = Field<_DIER, 10, 1>; // Capture/Compare 2 DMA request enable
        using CC1DE = Field<_DIER, 9, 1>; // Capture/Compare 1 DMA request enable
        using UDE = Field<_DIER, 8, 1>; // Update DMA request enable
        using TIE = Field<_DIER, 6, 1>; // Trigger interrupt enable
        using CC4IE = Field<_DIER, 4, 1>; // Capture/Compare 4 interrupt enable
        using CC3IE = Field<_DIER, 3, 1>; // Capture/Compare 3 interrupt enable
        using CC2IE = Field<_DIER, 2, 1>; // Capture/Compare 2 interrupt enable
        using CC1IE = Field<_DIER, 1, 1>; // Capture/Compare 1 interrupt enable
        using UIE = Field<_DIER, 0, 1>; // Update interrupt enable
        using BIE = Field<_DIER, 7, 1>; // Break interrupt enable
        using COMIE = Field<_DIER, 5, 1>; // COM interrupt enable
    };

    // status register
    struct _SR : Register<TIM1_BASE + 0x10, ReadWrite, _SR> {
        using CC4OF = Field<_SR, 12, 1>; // Capture/Compare 4 overcapture flag
        using CC3OF = Field<_SR, 11, 1>; // Capture/Compare 3 overcapture flag
        using CC2OF = Field<_SR, 10, 1>; // Capture/compare 2 overcapture flag
        using CC1OF = Field<_SR, 9, 1>; // Capture/Compare 1 overcapture flag
        using BIF = Field<_SR, 7, 1>; // Break interrupt flag
        using TIF = Field<_SR, 6, 1>; // Trigger interrupt flag
        using COMIF = Field<_SR, 5, 1>; // COM interrupt flag
        using CC4IF = Field<_SR, 4, 1>; // Capture/Compare 4 interrupt flag
        using CC3IF = Field<_SR, 3, 1>; // Capture/Compare 3 interrupt flag
        using CC2IF = Field<_SR, 2, 1>; // Capture/Compare 2 interrupt flag
        using CC1IF = Field<_SR, 1, 1>; // Capture/compare 1 interrupt flag
        using UIF = Field<_SR, 0, 1>; // Update interrupt flag
    };

    // event generation register
    struct _EGR : Register<TIM1_BASE + 0x14, WriteOnly, _EGR> {
        using BG = Field<_EGR, 7, 1>; // Break generation
        using TG = Field<_EGR, 6, 1>; // Trigger generation
        using COMG = Field<_EGR, 5, 1>; // Capture/Compare control update generation
        using CC4G = Field<_EGR, 4, 1>; // Capture/compare 4 generation
        using CC3G = Field<_EGR, 3, 1>; // Capture/compare 3 generation
        using CC2G = Field<_EGR, 2, 1>; // Capture/compare 2 generation
        using CC1G = Field<_EGR, 1, 1>; // Capture/compare 1 generation
        using UG = Field<_EGR, 0, 1>; // Update generation
    };

    // capture/compare mode register 1 (output mode)
    struct _CCMR1_Output : Register<TIM1_BASE + 0x18, ReadWrite, _CCMR1_Output> {
        using OC2CE = Field<_CCMR1_Output, 15, 1>; // Output Compare 2 clear enable
        using OC2M = Field<_CCMR1_Output, 12, 3>; // Output Compare 2 mode
        using OC2PE = Field<_CCMR1_Output, 11, 1>; // Output Compare 2 preload enable
        using OC2FE = Field<_CCMR1_Output, 10, 1>; // Output Compare 2 fast enable
        using CC2S = Field<_CCMR1_Output, 8, 2>; // Capture/Compare 2 selection
        using OC1CE = Field<_CCMR1_Output, 7, 1>; // Output Compare 1 clear enable
        using OC1M = Field<_CCMR1_Output, 4, 3>; // Output Compare 1 mode
        using OC1PE = Field<_CCMR1_Output, 3, 1>; // Output Compare 1 preload enable
        using OC1FE = Field<_CCMR1_Output, 2, 1>; // Output Compare 1 fast enable
        using CC1S = Field<_CCMR1_Output, 0, 2>; // Capture/Compare 1 selection
    };

    // capture/compare mode register 1 (input mode)
    struct _CCMR1_Input : Register<TIM1_BASE + 0x18, ReadWrite, _CCMR1_Input> {
        using IC2F = Field<_CCMR1_Input, 12, 4>; // Input capture 2 filter
        using IC2PSC = Field<_CCMR1_Input, 10, 2>; // Input capture 2 prescaler
        using CC2S = Field<_CCMR1_Input, 8, 2>; // Capture/Compare 2 selection
        using IC1F = Field<_CCMR1_Input, 4, 4>; // Input capture 1 filter
        using IC1PSC = Field<_CCMR1_Input, 2, 2>; // Input capture 1 prescaler
        using CC1S = Field<_CCMR1_Input, 0, 2>; // Capture/Compare 1 selection
    };

    // capture/compare mode register 2 (output mode)
    struct _CCMR2_Output : Register<TIM1_BASE + 0x1C, ReadWrite, _CCMR2_Output> {
        using OC4CE = Field<_CCMR2_Output, 15, 1>; // Output compare 4 clear enable
        using OC4M = Field<_CCMR2_Output, 12, 3>; // Output compare 4 mode
        using OC4PE = Field<_CCMR2_Output, 11, 1>; // Output compare 4 preload enable
        using OC4FE = Field<_CCMR2_Output, 10, 1>; // Output compare 4 fast enable
        using CC4S = Field<_CCMR2_Output, 8, 2>; // Capture/Compare 4 selection
        using OC3CE = Field<_CCMR2_Output, 7, 1>; // Output compare 3 clear enable
        using OC3M = Field<_CCMR2_Output, 4, 3>; // Output compare 3 mode
        using OC3PE = Field<_CCMR2_Output, 3, 1>; // Output compare 3 preload enable
        using OC3FE = Field<_CCMR2_Output, 2, 1>; // Output compare 3 fast enable
        using CC3S = Field<_CCMR2_Output, 0, 2>; // Capture/Compare 3 selection
    };

    // capture/compare mode register 2 (input mode)
    struct _CCMR2_Input : Register<TIM1_BASE + 0x1C, ReadWrite, _CCMR2_Input> {
        using IC4F = Field<_CCMR2_Input, 12, 4>; // Input capture 4 filter
        using IC4PSC = Field<_CCMR2_Input, 10, 2>; // Input capture 4 prescaler
        using CC4S = Field<_CCMR2_Input, 8, 2>; // Capture/Compare 4 selection
        using IC3F = Field<_CCMR2_Input, 4, 4>; // Input capture 3 filter
        using IC3PSC = Field<_CCMR2_Input, 2, 2>; // Input capture 3 prescaler
        using CC3S = Field<_CCMR2_Input, 0, 2>; // Capture/compare 3 selection
    };

    // capture/compare enable register
    struct _CCER : Register<TIM1_BASE + 0x20, ReadWrite, _CCER> {
        using CC4P = Field<_CCER, 13, 1>; // Capture/Compare 3 output Polarity
        using CC4E = Field<_CCER, 12, 1>; // Capture/Compare 4 output enable
        using CC3NP = Field<_CCER, 11, 1>; // Capture/Compare 3 output Polarity
        using CC3NE = Field<_CCER, 10, 1>; // Capture/Compare 3 complementary output enable
        using CC3P = Field<_CCER, 9, 1>; // Capture/Compare 3 output Polarity
        using CC3E = Field<_CCER, 8, 1>; // Capture/Compare 3 output enable
        using CC2NP = Field<_CCER, 7, 1>; // Capture/Compare 2 output Polarity
        using CC2NE = Field<_CCER, 6, 1>; // Capture/Compare 2 complementary output enable
        using CC2P = Field<_CCER, 5, 1>; // Capture/Compare 2 output Polarity
        using CC2E = Field<_CCER, 4, 1>; // Capture/Compare 2 output enable
        using CC1NP = Field<_CCER, 3, 1>; // Capture/Compare 1 output Polarity
        using CC1NE = Field<_CCER, 2, 1>; // Capture/Compare 1 complementary output enable
        using CC1P = Field<_CCER, 1, 1>; // Capture/Compare 1 output Polarity
        using CC1E = Field<_CCER, 0, 1>; // Capture/Compare 1 output enable
    };

    // counter
    struct _CNT : Register<TIM1_BASE + 0x24, ReadWrite, _CNT> {
        using CNT = Field<_CNT, 0, 16>; // counter value
    };

    // prescaler
    struct _PSC : Register<TIM1_BASE + 0x28, ReadWrite, _PSC> {
        using PSC = Field<_PSC, 0, 16>; // Prescaler value
    };

    // auto-reload register
    struct _ARR : Register<TIM1_BASE + 0x2C, ReadWrite, _ARR> {
        using ARR = Field<_ARR, 0, 16>; // Auto-reload value
    };

    // capture/compare register 1
    struct _CCR1 : Register<TIM1_BASE + 0x34, ReadWrite, _CCR1> {
        using CCR1 = Field<_CCR1, 0, 16>; // Capture/Compare 1 value
    };

    // capture/compare register 2
    struct _CCR2 : Register<TIM1_BASE + 0x38, ReadWrite, _CCR2> {
        using CCR2 = Field<_CCR2, 0, 16>; // Capture/Compare 2 value
    };

    // capture/compare register 3
    struct _CCR3 : Register<TIM1_BASE + 0x3C, ReadWrite, _CCR3> {
        using CCR3 = Field<_CCR3, 0, 16>; // Capture/Compare value
    };

    // capture/compare register 4
    struct _CCR4 : Register<TIM1_BASE + 0x40, ReadWrite, _CCR4> {
        using CCR4 = Field<_CCR4, 0, 16>; // Capture/Compare value
    };

    // DMA control register
    struct _DCR : Register<TIM1_BASE + 0x48, ReadWrite, _DCR> {
        using DBL = Field<_DCR, 8, 5>; // DMA burst length
        using DBA = Field<_DCR, 0, 5>; // DMA base address
    };

    // DMA address for full transfer
    struct _DMAR : Register<TIM1_BASE + 0x4C, ReadWrite, _DMAR> {
        using DMAB = Field<_DMAR, 0, 16>; // DMA register for burst accesses
    };

    // repetition counter register
    struct _RCR : Register<TIM1_BASE + 0x30, ReadWrite, _RCR> {
        using REP = Field<_RCR, 0, 8>; // Repetition counter value
    };

    // break and dead-time register
    struct _BDTR : Register<TIM1_BASE + 0x44, ReadWrite, _BDTR> {
        using DTG = Field<_BDTR, 0, 8>; // Dead-time generator setup
        using LOCK = Field<_BDTR, 8, 2>; // Lock configuration
        using OSSI = Field<_BDTR, 10, 1>; // Off-state selection for Idle mode
        using OSSR = Field<_BDTR, 11, 1>; // Off-state selection for Run mode
        using BKE = Field<_BDTR, 12, 1>; // Break enable
        using BKP = Field<_BDTR, 13, 1>; // Break polarity
        using AOE = Field<_BDTR, 14, 1>; // Automatic output enable
        using MOE = Field<_BDTR, 15, 1>; // Main output enable
        using BKF = Field<_BDTR, 16, 4>; // Break filter
        using BK2F = Field<_BDTR, 20, 4>; // Break 2 filter
        using BK2E = Field<_BDTR, 24, 1>; // Break 2 enable
        using BK2P = Field<_BDTR, 25, 1>; // Break 2 polarity
    };

    // capture/compare mode register 3 (output mode)
    struct _CCMR3_Output : Register<TIM1_BASE + 0x54, ReadWrite, _CCMR3_Output> {
        using OC5FE = Field<_CCMR3_Output, 2, 1>; // Output compare 5 fast enable
        using OC5PE = Field<_CCMR3_Output, 3, 1>; // Output compare 5 preload enable
        using OC5M = Field<_CCMR3_Output, 4, 3>; // Output compare 5 mode
        using OC5CE = Field<_CCMR3_Output, 7, 1>; // Output compare 5 clear enable
        using OC6FE = Field<_CCMR3_Output, 10, 1>; // Output compare 6 fast enable
        using OC6PE = Field<_CCMR3_Output, 11, 1>; // Output compare 6 preload enable
        using OC6M = Field<_CCMR3_Output, 12, 3>; // Output compare 6 mode
        using OC6CE = Field<_CCMR3_Output, 15, 1>; // Output compare 6 clear enable
        using OC5M3 = Field<_CCMR3_Output, 16, 1>; // Output Compare 5 mode
        using OC6M3 = Field<_CCMR3_Output, 24, 1>; // Output Compare 6 mode
    };

    // capture/compare register 5
    struct _CCR5 : Register<TIM1_BASE + 0x58, ReadWrite, _CCR5> {
        using CCR5 = Field<_CCR5, 0, 16>; // Capture/Compare 5 value
        using GC5C1 = Field<_CCR5, 29, 1>; // Group Channel 5 and Channel 1
        using GC5C2 = Field<_CCR5, 30, 1>; // Group Channel 5 and Channel 2
        using GC5C3 = Field<_CCR5, 31, 1>; // Group Channel 5 and Channel 3
    };

    // capture/compare register 6
    struct _CRR6 : Register<TIM1_BASE + 0x5C, ReadWrite, _CRR6> {
        using CCR6 = Field<_CRR6, 0, 16>; // Capture/Compare 6 value
    };

    // alternate function option register 1
    struct _AF1 : Register<TIM1_BASE + 0x60, ReadWrite, _AF1> {
        using BKINE = Field<_AF1, 0, 1>; // BRK BKIN input enable
        using BKDFBKE = Field<_AF1, 8, 1>; // BRK DFSDM_BREAK[0] enable
        using BKINP = Field<_AF1, 9, 1>; // BRK BKIN input polarity
    };

    // alternate function option register 2
    struct _AF2 : Register<TIM1_BASE + 0x64, ReadWrite, _AF2> {
        using BK2INE = Field<_AF2, 0, 1>; // BRK2 BKIN input enable
        using BK2DFBKE = Field<_AF2, 8, 1>; // BRK2 DFSDM_BREAK enable
        using BK2INP = Field<_AF2, 9, 1>; // BRK2 BKIN2 input polarity
    };

} // namespace TIM1

// --------------------------------------------
// TIM8: 
// Base address: 0x40010400
// --------------------------------------------

namespace TIM8 {
    static constexpr uint32_t TIM8_BASE = 0x40010400;

} // namespace TIM8

// --------------------------------------------
// TIM2: General purpose timers
// Base address: 0x40000000
// --------------------------------------------

namespace TIM2 {
    static constexpr uint32_t TIM2_BASE = 0x40000000;

    // control register 1
    struct _CR1 : Register<TIM2_BASE + 0x0, ReadWrite, _CR1> {
        using CKD = Field<_CR1, 8, 2>; // Clock division
        using ARPE = Field<_CR1, 7, 1>; // Auto-reload preload enable
        using CMS = Field<_CR1, 5, 2>; // Center-aligned mode selection
        using DIR = Field<_CR1, 4, 1>; // Direction
        using OPM = Field<_CR1, 3, 1>; // One-pulse mode
        using URS = Field<_CR1, 2, 1>; // Update request source
        using UDIS = Field<_CR1, 1, 1>; // Update disable
        using CEN = Field<_CR1, 0, 1>; // Counter enable
    };

    // control register 2
    struct _CR2 : Register<TIM2_BASE + 0x4, ReadWrite, _CR2> {
        using TI1S = Field<_CR2, 7, 1>; // TI1 selection
        using MMS = Field<_CR2, 4, 3>; // Master mode selection
        using CCDS = Field<_CR2, 3, 1>; // Capture/compare DMA selection
    };

    // slave mode control register
    struct _SMCR : Register<TIM2_BASE + 0x8, ReadWrite, _SMCR> {
        using ETP = Field<_SMCR, 15, 1>; // External trigger polarity
        using ECE = Field<_SMCR, 14, 1>; // External clock enable
        using ETPS = Field<_SMCR, 12, 2>; // External trigger prescaler
        using ETF = Field<_SMCR, 8, 4>; // External trigger filter
        using MSM = Field<_SMCR, 7, 1>; // Master/Slave mode
        using TS = Field<_SMCR, 4, 3>; // Trigger selection
        using SMS = Field<_SMCR, 0, 3>; // Slave mode selection
    };

    // DMA/Interrupt enable register
    struct _DIER : Register<TIM2_BASE + 0xC, ReadWrite, _DIER> {
        using TDE = Field<_DIER, 14, 1>; // Trigger DMA request enable
        using CC4DE = Field<_DIER, 12, 1>; // Capture/Compare 4 DMA request enable
        using CC3DE = Field<_DIER, 11, 1>; // Capture/Compare 3 DMA request enable
        using CC2DE = Field<_DIER, 10, 1>; // Capture/Compare 2 DMA request enable
        using CC1DE = Field<_DIER, 9, 1>; // Capture/Compare 1 DMA request enable
        using UDE = Field<_DIER, 8, 1>; // Update DMA request enable
        using TIE = Field<_DIER, 6, 1>; // Trigger interrupt enable
        using CC4IE = Field<_DIER, 4, 1>; // Capture/Compare 4 interrupt enable
        using CC3IE = Field<_DIER, 3, 1>; // Capture/Compare 3 interrupt enable
        using CC2IE = Field<_DIER, 2, 1>; // Capture/Compare 2 interrupt enable
        using CC1IE = Field<_DIER, 1, 1>; // Capture/Compare 1 interrupt enable
        using UIE = Field<_DIER, 0, 1>; // Update interrupt enable
    };

    // status register
    struct _SR : Register<TIM2_BASE + 0x10, ReadWrite, _SR> {
        using CC4OF = Field<_SR, 12, 1>; // Capture/Compare 4 overcapture flag
        using CC3OF = Field<_SR, 11, 1>; // Capture/Compare 3 overcapture flag
        using CC2OF = Field<_SR, 10, 1>; // Capture/compare 2 overcapture flag
        using CC1OF = Field<_SR, 9, 1>; // Capture/Compare 1 overcapture flag
        using TIF = Field<_SR, 6, 1>; // Trigger interrupt flag
        using CC4IF = Field<_SR, 4, 1>; // Capture/Compare 4 interrupt flag
        using CC3IF = Field<_SR, 3, 1>; // Capture/Compare 3 interrupt flag
        using CC2IF = Field<_SR, 2, 1>; // Capture/Compare 2 interrupt flag
        using CC1IF = Field<_SR, 1, 1>; // Capture/compare 1 interrupt flag
        using UIF = Field<_SR, 0, 1>; // Update interrupt flag
    };

    // event generation register
    struct _EGR : Register<TIM2_BASE + 0x14, WriteOnly, _EGR> {
        using TG = Field<_EGR, 6, 1>; // Trigger generation
        using CC4G = Field<_EGR, 4, 1>; // Capture/compare 4 generation
        using CC3G = Field<_EGR, 3, 1>; // Capture/compare 3 generation
        using CC2G = Field<_EGR, 2, 1>; // Capture/compare 2 generation
        using CC1G = Field<_EGR, 1, 1>; // Capture/compare 1 generation
        using UG = Field<_EGR, 0, 1>; // Update generation
    };

    // capture/compare mode register 1 (output mode)
    struct _CCMR1_Output : Register<TIM2_BASE + 0x18, ReadWrite, _CCMR1_Output> {
        using OC2CE = Field<_CCMR1_Output, 15, 1>; // OC2CE
        using OC2M = Field<_CCMR1_Output, 12, 3>; // OC2M
        using OC2PE = Field<_CCMR1_Output, 11, 1>; // OC2PE
        using OC2FE = Field<_CCMR1_Output, 10, 1>; // OC2FE
        using CC2S = Field<_CCMR1_Output, 8, 2>; // CC2S
        using OC1CE = Field<_CCMR1_Output, 7, 1>; // OC1CE
        using OC1M = Field<_CCMR1_Output, 4, 3>; // OC1M
        using OC1PE = Field<_CCMR1_Output, 3, 1>; // OC1PE
        using OC1FE = Field<_CCMR1_Output, 2, 1>; // OC1FE
        using CC1S = Field<_CCMR1_Output, 0, 2>; // CC1S
    };

    // capture/compare mode register 1 (input mode)
    struct _CCMR1_Input : Register<TIM2_BASE + 0x18, ReadWrite, _CCMR1_Input> {
        using IC2F = Field<_CCMR1_Input, 12, 4>; // Input capture 2 filter
        using IC2PSC = Field<_CCMR1_Input, 10, 2>; // Input capture 2 prescaler
        using CC2S = Field<_CCMR1_Input, 8, 2>; // Capture/Compare 2 selection
        using IC1F = Field<_CCMR1_Input, 4, 4>; // Input capture 1 filter
        using IC1PSC = Field<_CCMR1_Input, 2, 2>; // Input capture 1 prescaler
        using CC1S = Field<_CCMR1_Input, 0, 2>; // Capture/Compare 1 selection
    };

    // capture/compare mode register 2 (output mode)
    struct _CCMR2_Output : Register<TIM2_BASE + 0x1C, ReadWrite, _CCMR2_Output> {
        using O24CE = Field<_CCMR2_Output, 15, 1>; // O24CE
        using OC4M = Field<_CCMR2_Output, 12, 3>; // OC4M
        using OC4PE = Field<_CCMR2_Output, 11, 1>; // OC4PE
        using OC4FE = Field<_CCMR2_Output, 10, 1>; // OC4FE
        using CC4S = Field<_CCMR2_Output, 8, 2>; // CC4S
        using OC3CE = Field<_CCMR2_Output, 7, 1>; // OC3CE
        using OC3M = Field<_CCMR2_Output, 4, 3>; // OC3M
        using OC3PE = Field<_CCMR2_Output, 3, 1>; // OC3PE
        using OC3FE = Field<_CCMR2_Output, 2, 1>; // OC3FE
        using CC3S = Field<_CCMR2_Output, 0, 2>; // CC3S
    };

    // capture/compare mode register 2 (input mode)
    struct _CCMR2_Input : Register<TIM2_BASE + 0x1C, ReadWrite, _CCMR2_Input> {
        using IC4F = Field<_CCMR2_Input, 12, 4>; // Input capture 4 filter
        using IC4PSC = Field<_CCMR2_Input, 10, 2>; // Input capture 4 prescaler
        using CC4S = Field<_CCMR2_Input, 8, 2>; // Capture/Compare 4 selection
        using IC3F = Field<_CCMR2_Input, 4, 4>; // Input capture 3 filter
        using IC3PSC = Field<_CCMR2_Input, 2, 2>; // Input capture 3 prescaler
        using CC3S = Field<_CCMR2_Input, 0, 2>; // Capture/compare 3 selection
    };

    // capture/compare enable register
    struct _CCER : Register<TIM2_BASE + 0x20, ReadWrite, _CCER> {
        using CC4NP = Field<_CCER, 15, 1>; // Capture/Compare 4 output Polarity
        using CC4P = Field<_CCER, 13, 1>; // Capture/Compare 3 output Polarity
        using CC4E = Field<_CCER, 12, 1>; // Capture/Compare 4 output enable
        using CC3NP = Field<_CCER, 11, 1>; // Capture/Compare 3 output Polarity
        using CC3P = Field<_CCER, 9, 1>; // Capture/Compare 3 output Polarity
        using CC3E = Field<_CCER, 8, 1>; // Capture/Compare 3 output enable
        using CC2NP = Field<_CCER, 7, 1>; // Capture/Compare 2 output Polarity
        using CC2P = Field<_CCER, 5, 1>; // Capture/Compare 2 output Polarity
        using CC2E = Field<_CCER, 4, 1>; // Capture/Compare 2 output enable
        using CC1NP = Field<_CCER, 3, 1>; // Capture/Compare 1 output Polarity
        using CC1P = Field<_CCER, 1, 1>; // Capture/Compare 1 output Polarity
        using CC1E = Field<_CCER, 0, 1>; // Capture/Compare 1 output enable
    };

    // counter
    struct _CNT : Register<TIM2_BASE + 0x24, ReadWrite, _CNT> {
        using CNT_H = Field<_CNT, 16, 16>; // High counter value
        using CNT_L = Field<_CNT, 0, 16>; // Low counter value
    };

    // prescaler
    struct _PSC : Register<TIM2_BASE + 0x28, ReadWrite, _PSC> {
        using PSC = Field<_PSC, 0, 16>; // Prescaler value
    };

    // auto-reload register
    struct _ARR : Register<TIM2_BASE + 0x2C, ReadWrite, _ARR> {
        using ARR_H = Field<_ARR, 16, 16>; // High Auto-reload value
        using ARR_L = Field<_ARR, 0, 16>; // Low Auto-reload value
    };

    // capture/compare register 1
    struct _CCR1 : Register<TIM2_BASE + 0x34, ReadWrite, _CCR1> {
        using CCR1_H = Field<_CCR1, 16, 16>; // High Capture/Compare 1 value
        using CCR1_L = Field<_CCR1, 0, 16>; // Low Capture/Compare 1 value
    };

    // capture/compare register 2
    struct _CCR2 : Register<TIM2_BASE + 0x38, ReadWrite, _CCR2> {
        using CCR2_H = Field<_CCR2, 16, 16>; // High Capture/Compare 2 value
        using CCR2_L = Field<_CCR2, 0, 16>; // Low Capture/Compare 2 value
    };

    // capture/compare register 3
    struct _CCR3 : Register<TIM2_BASE + 0x3C, ReadWrite, _CCR3> {
        using CCR3_H = Field<_CCR3, 16, 16>; // High Capture/Compare value
        using CCR3_L = Field<_CCR3, 0, 16>; // Low Capture/Compare value
    };

    // capture/compare register 4
    struct _CCR4 : Register<TIM2_BASE + 0x40, ReadWrite, _CCR4> {
        using CCR4_H = Field<_CCR4, 16, 16>; // High Capture/Compare value
        using CCR4_L = Field<_CCR4, 0, 16>; // Low Capture/Compare value
    };

    // DMA control register
    struct _DCR : Register<TIM2_BASE + 0x48, ReadWrite, _DCR> {
        using DBL = Field<_DCR, 8, 5>; // DMA burst length
        using DBA = Field<_DCR, 0, 5>; // DMA base address
    };

    // DMA address for full transfer
    struct _DMAR : Register<TIM2_BASE + 0x4C, ReadWrite, _DMAR> {
        using DMAB = Field<_DMAR, 0, 16>; // DMA register for burst accesses
    };

    // TIM2 option register 1
    struct _OR1 : Register<TIM2_BASE + 0x50, ReadWrite, _OR1> {
        using TI4_RMP = Field<_OR1, 2, 2>; // Input Capture 4 remap
        using ETR1_RMP = Field<_OR1, 1, 1>; // External trigger remap
        using ITR1_RMP = Field<_OR1, 0, 1>; // Internal trigger 1 remap
    };

    // TIM2 option register 2
    struct _OR2 : Register<TIM2_BASE + 0x60, ReadWrite, _OR2> {
        using ETRSEL = Field<_OR2, 14, 3>; // ETR source selection
    };

} // namespace TIM2

// --------------------------------------------
// TIM3: General purpose timers
// Base address: 0x40000400
// --------------------------------------------

namespace TIM3 {
    static constexpr uint32_t TIM3_BASE = 0x40000400;

    // control register 1
    struct _CR1 : Register<TIM3_BASE + 0x0, ReadWrite, _CR1> {
        using CKD = Field<_CR1, 8, 2>; // Clock division
        using ARPE = Field<_CR1, 7, 1>; // Auto-reload preload enable
        using CMS = Field<_CR1, 5, 2>; // Center-aligned mode selection
        using DIR = Field<_CR1, 4, 1>; // Direction
        using OPM = Field<_CR1, 3, 1>; // One-pulse mode
        using URS = Field<_CR1, 2, 1>; // Update request source
        using UDIS = Field<_CR1, 1, 1>; // Update disable
        using CEN = Field<_CR1, 0, 1>; // Counter enable
    };

    // control register 2
    struct _CR2 : Register<TIM3_BASE + 0x4, ReadWrite, _CR2> {
        using TI1S = Field<_CR2, 7, 1>; // TI1 selection
        using MMS = Field<_CR2, 4, 3>; // Master mode selection
        using CCDS = Field<_CR2, 3, 1>; // Capture/compare DMA selection
    };

    // slave mode control register
    struct _SMCR : Register<TIM3_BASE + 0x8, ReadWrite, _SMCR> {
        using ETP = Field<_SMCR, 15, 1>; // External trigger polarity
        using ECE = Field<_SMCR, 14, 1>; // External clock enable
        using ETPS = Field<_SMCR, 12, 2>; // External trigger prescaler
        using ETF = Field<_SMCR, 8, 4>; // External trigger filter
        using MSM = Field<_SMCR, 7, 1>; // Master/Slave mode
        using TS = Field<_SMCR, 4, 3>; // Trigger selection
        using SMS = Field<_SMCR, 0, 3>; // Slave mode selection
    };

    // DMA/Interrupt enable register
    struct _DIER : Register<TIM3_BASE + 0xC, ReadWrite, _DIER> {
        using TDE = Field<_DIER, 14, 1>; // Trigger DMA request enable
        using CC4DE = Field<_DIER, 12, 1>; // Capture/Compare 4 DMA request enable
        using CC3DE = Field<_DIER, 11, 1>; // Capture/Compare 3 DMA request enable
        using CC2DE = Field<_DIER, 10, 1>; // Capture/Compare 2 DMA request enable
        using CC1DE = Field<_DIER, 9, 1>; // Capture/Compare 1 DMA request enable
        using UDE = Field<_DIER, 8, 1>; // Update DMA request enable
        using TIE = Field<_DIER, 6, 1>; // Trigger interrupt enable
        using CC4IE = Field<_DIER, 4, 1>; // Capture/Compare 4 interrupt enable
        using CC3IE = Field<_DIER, 3, 1>; // Capture/Compare 3 interrupt enable
        using CC2IE = Field<_DIER, 2, 1>; // Capture/Compare 2 interrupt enable
        using CC1IE = Field<_DIER, 1, 1>; // Capture/Compare 1 interrupt enable
        using UIE = Field<_DIER, 0, 1>; // Update interrupt enable
    };

    // status register
    struct _SR : Register<TIM3_BASE + 0x10, ReadWrite, _SR> {
        using CC4OF = Field<_SR, 12, 1>; // Capture/Compare 4 overcapture flag
        using CC3OF = Field<_SR, 11, 1>; // Capture/Compare 3 overcapture flag
        using CC2OF = Field<_SR, 10, 1>; // Capture/compare 2 overcapture flag
        using CC1OF = Field<_SR, 9, 1>; // Capture/Compare 1 overcapture flag
        using TIF = Field<_SR, 6, 1>; // Trigger interrupt flag
        using CC4IF = Field<_SR, 4, 1>; // Capture/Compare 4 interrupt flag
        using CC3IF = Field<_SR, 3, 1>; // Capture/Compare 3 interrupt flag
        using CC2IF = Field<_SR, 2, 1>; // Capture/Compare 2 interrupt flag
        using CC1IF = Field<_SR, 1, 1>; // Capture/compare 1 interrupt flag
        using UIF = Field<_SR, 0, 1>; // Update interrupt flag
    };

    // event generation register
    struct _EGR : Register<TIM3_BASE + 0x14, WriteOnly, _EGR> {
        using TG = Field<_EGR, 6, 1>; // Trigger generation
        using CC4G = Field<_EGR, 4, 1>; // Capture/compare 4 generation
        using CC3G = Field<_EGR, 3, 1>; // Capture/compare 3 generation
        using CC2G = Field<_EGR, 2, 1>; // Capture/compare 2 generation
        using CC1G = Field<_EGR, 1, 1>; // Capture/compare 1 generation
        using UG = Field<_EGR, 0, 1>; // Update generation
    };

    // capture/compare mode register 1 (output mode)
    struct _CCMR1_Output : Register<TIM3_BASE + 0x18, ReadWrite, _CCMR1_Output> {
        using OC2CE = Field<_CCMR1_Output, 15, 1>; // OC2CE
        using OC2M = Field<_CCMR1_Output, 12, 3>; // OC2M
        using OC2PE = Field<_CCMR1_Output, 11, 1>; // OC2PE
        using OC2FE = Field<_CCMR1_Output, 10, 1>; // OC2FE
        using CC2S = Field<_CCMR1_Output, 8, 2>; // CC2S
        using OC1CE = Field<_CCMR1_Output, 7, 1>; // OC1CE
        using OC1M = Field<_CCMR1_Output, 4, 3>; // OC1M
        using OC1PE = Field<_CCMR1_Output, 3, 1>; // OC1PE
        using OC1FE = Field<_CCMR1_Output, 2, 1>; // OC1FE
        using CC1S = Field<_CCMR1_Output, 0, 2>; // CC1S
    };

    // capture/compare mode register 1 (input mode)
    struct _CCMR1_Input : Register<TIM3_BASE + 0x18, ReadWrite, _CCMR1_Input> {
        using IC2F = Field<_CCMR1_Input, 12, 4>; // Input capture 2 filter
        using IC2PSC = Field<_CCMR1_Input, 10, 2>; // Input capture 2 prescaler
        using CC2S = Field<_CCMR1_Input, 8, 2>; // Capture/Compare 2 selection
        using IC1F = Field<_CCMR1_Input, 4, 4>; // Input capture 1 filter
        using IC1PSC = Field<_CCMR1_Input, 2, 2>; // Input capture 1 prescaler
        using CC1S = Field<_CCMR1_Input, 0, 2>; // Capture/Compare 1 selection
    };

    // capture/compare mode register 2 (output mode)
    struct _CCMR2_Output : Register<TIM3_BASE + 0x1C, ReadWrite, _CCMR2_Output> {
        using O24CE = Field<_CCMR2_Output, 15, 1>; // O24CE
        using OC4M = Field<_CCMR2_Output, 12, 3>; // OC4M
        using OC4PE = Field<_CCMR2_Output, 11, 1>; // OC4PE
        using OC4FE = Field<_CCMR2_Output, 10, 1>; // OC4FE
        using CC4S = Field<_CCMR2_Output, 8, 2>; // CC4S
        using OC3CE = Field<_CCMR2_Output, 7, 1>; // OC3CE
        using OC3M = Field<_CCMR2_Output, 4, 3>; // OC3M
        using OC3PE = Field<_CCMR2_Output, 3, 1>; // OC3PE
        using OC3FE = Field<_CCMR2_Output, 2, 1>; // OC3FE
        using CC3S = Field<_CCMR2_Output, 0, 2>; // CC3S
    };

    // capture/compare mode register 2 (input mode)
    struct _CCMR2_Input : Register<TIM3_BASE + 0x1C, ReadWrite, _CCMR2_Input> {
        using IC4F = Field<_CCMR2_Input, 12, 4>; // Input capture 4 filter
        using IC4PSC = Field<_CCMR2_Input, 10, 2>; // Input capture 4 prescaler
        using CC4S = Field<_CCMR2_Input, 8, 2>; // Capture/Compare 4 selection
        using IC3F = Field<_CCMR2_Input, 4, 4>; // Input capture 3 filter
        using IC3PSC = Field<_CCMR2_Input, 2, 2>; // Input capture 3 prescaler
        using CC3S = Field<_CCMR2_Input, 0, 2>; // Capture/compare 3 selection
    };

    // capture/compare enable register
    struct _CCER : Register<TIM3_BASE + 0x20, ReadWrite, _CCER> {
        using CC4NP = Field<_CCER, 15, 1>; // Capture/Compare 4 output Polarity
        using CC4P = Field<_CCER, 13, 1>; // Capture/Compare 3 output Polarity
        using CC4E = Field<_CCER, 12, 1>; // Capture/Compare 4 output enable
        using CC3NP = Field<_CCER, 11, 1>; // Capture/Compare 3 output Polarity
        using CC3P = Field<_CCER, 9, 1>; // Capture/Compare 3 output Polarity
        using CC3E = Field<_CCER, 8, 1>; // Capture/Compare 3 output enable
        using CC2NP = Field<_CCER, 7, 1>; // Capture/Compare 2 output Polarity
        using CC2P = Field<_CCER, 5, 1>; // Capture/Compare 2 output Polarity
        using CC2E = Field<_CCER, 4, 1>; // Capture/Compare 2 output enable
        using CC1NP = Field<_CCER, 3, 1>; // Capture/Compare 1 output Polarity
        using CC1P = Field<_CCER, 1, 1>; // Capture/Compare 1 output Polarity
        using CC1E = Field<_CCER, 0, 1>; // Capture/Compare 1 output enable
    };

    // counter
    struct _CNT : Register<TIM3_BASE + 0x24, ReadWrite, _CNT> {
        using CNT_H = Field<_CNT, 16, 16>; // High counter value
        using CNT_L = Field<_CNT, 0, 16>; // Low counter value
    };

    // prescaler
    struct _PSC : Register<TIM3_BASE + 0x28, ReadWrite, _PSC> {
        using PSC = Field<_PSC, 0, 16>; // Prescaler value
    };

    // auto-reload register
    struct _ARR : Register<TIM3_BASE + 0x2C, ReadWrite, _ARR> {
        using ARR_H = Field<_ARR, 16, 16>; // High Auto-reload value
        using ARR_L = Field<_ARR, 0, 16>; // Low Auto-reload value
    };

    // capture/compare register 1
    struct _CCR1 : Register<TIM3_BASE + 0x34, ReadWrite, _CCR1> {
        using CCR1_H = Field<_CCR1, 16, 16>; // High Capture/Compare 1 value
        using CCR1_L = Field<_CCR1, 0, 16>; // Low Capture/Compare 1 value
    };

    // capture/compare register 2
    struct _CCR2 : Register<TIM3_BASE + 0x38, ReadWrite, _CCR2> {
        using CCR2_H = Field<_CCR2, 16, 16>; // High Capture/Compare 2 value
        using CCR2_L = Field<_CCR2, 0, 16>; // Low Capture/Compare 2 value
    };

    // capture/compare register 3
    struct _CCR3 : Register<TIM3_BASE + 0x3C, ReadWrite, _CCR3> {
        using CCR3_H = Field<_CCR3, 16, 16>; // High Capture/Compare value
        using CCR3_L = Field<_CCR3, 0, 16>; // Low Capture/Compare value
    };

    // capture/compare register 4
    struct _CCR4 : Register<TIM3_BASE + 0x40, ReadWrite, _CCR4> {
        using CCR4_H = Field<_CCR4, 16, 16>; // High Capture/Compare value
        using CCR4_L = Field<_CCR4, 0, 16>; // Low Capture/Compare value
    };

    // DMA control register
    struct _DCR : Register<TIM3_BASE + 0x48, ReadWrite, _DCR> {
        using DBL = Field<_DCR, 8, 5>; // DMA burst length
        using DBA = Field<_DCR, 0, 5>; // DMA base address
    };

    // DMA address for full transfer
    struct _DMAR : Register<TIM3_BASE + 0x4C, ReadWrite, _DMAR> {
        using DMAB = Field<_DMAR, 0, 16>; // DMA register for burst accesses
    };

    // TIM3 option register 1
    struct _OR1 : Register<TIM3_BASE + 0x50, ReadWrite, _OR1> {
        using TI1_RMP = Field<_OR1, 0, 2>; // Input Capture 1 remap
    };

    // TIM3 option register 2
    struct _OR2 : Register<TIM3_BASE + 0x60, ReadWrite, _OR2> {
        using ETRSEL = Field<_OR2, 14, 3>; // ETR source selection
    };

} // namespace TIM3

// --------------------------------------------
// TIM4: General purpose timers
// Base address: 0x40000800
// --------------------------------------------

namespace TIM4 {
    static constexpr uint32_t TIM4_BASE = 0x40000800;

    // control register 1
    struct _CR1 : Register<TIM4_BASE + 0x0, ReadWrite, _CR1> {
        using CKD = Field<_CR1, 8, 2>; // Clock division
        using ARPE = Field<_CR1, 7, 1>; // Auto-reload preload enable
        using CMS = Field<_CR1, 5, 2>; // Center-aligned mode selection
        using DIR = Field<_CR1, 4, 1>; // Direction
        using OPM = Field<_CR1, 3, 1>; // One-pulse mode
        using URS = Field<_CR1, 2, 1>; // Update request source
        using UDIS = Field<_CR1, 1, 1>; // Update disable
        using CEN = Field<_CR1, 0, 1>; // Counter enable
    };

    // control register 2
    struct _CR2 : Register<TIM4_BASE + 0x4, ReadWrite, _CR2> {
        using TI1S = Field<_CR2, 7, 1>; // TI1 selection
        using MMS = Field<_CR2, 4, 3>; // Master mode selection
        using CCDS = Field<_CR2, 3, 1>; // Capture/compare DMA selection
    };

    // slave mode control register
    struct _SMCR : Register<TIM4_BASE + 0x8, ReadWrite, _SMCR> {
        using ETP = Field<_SMCR, 15, 1>; // External trigger polarity
        using ECE = Field<_SMCR, 14, 1>; // External clock enable
        using ETPS = Field<_SMCR, 12, 2>; // External trigger prescaler
        using ETF = Field<_SMCR, 8, 4>; // External trigger filter
        using MSM = Field<_SMCR, 7, 1>; // Master/Slave mode
        using TS = Field<_SMCR, 4, 3>; // Trigger selection
        using SMS = Field<_SMCR, 0, 3>; // Slave mode selection
    };

    // DMA/Interrupt enable register
    struct _DIER : Register<TIM4_BASE + 0xC, ReadWrite, _DIER> {
        using TDE = Field<_DIER, 14, 1>; // Trigger DMA request enable
        using CC4DE = Field<_DIER, 12, 1>; // Capture/Compare 4 DMA request enable
        using CC3DE = Field<_DIER, 11, 1>; // Capture/Compare 3 DMA request enable
        using CC2DE = Field<_DIER, 10, 1>; // Capture/Compare 2 DMA request enable
        using CC1DE = Field<_DIER, 9, 1>; // Capture/Compare 1 DMA request enable
        using UDE = Field<_DIER, 8, 1>; // Update DMA request enable
        using TIE = Field<_DIER, 6, 1>; // Trigger interrupt enable
        using CC4IE = Field<_DIER, 4, 1>; // Capture/Compare 4 interrupt enable
        using CC3IE = Field<_DIER, 3, 1>; // Capture/Compare 3 interrupt enable
        using CC2IE = Field<_DIER, 2, 1>; // Capture/Compare 2 interrupt enable
        using CC1IE = Field<_DIER, 1, 1>; // Capture/Compare 1 interrupt enable
        using UIE = Field<_DIER, 0, 1>; // Update interrupt enable
    };

    // status register
    struct _SR : Register<TIM4_BASE + 0x10, ReadWrite, _SR> {
        using CC4OF = Field<_SR, 12, 1>; // Capture/Compare 4 overcapture flag
        using CC3OF = Field<_SR, 11, 1>; // Capture/Compare 3 overcapture flag
        using CC2OF = Field<_SR, 10, 1>; // Capture/compare 2 overcapture flag
        using CC1OF = Field<_SR, 9, 1>; // Capture/Compare 1 overcapture flag
        using TIF = Field<_SR, 6, 1>; // Trigger interrupt flag
        using CC4IF = Field<_SR, 4, 1>; // Capture/Compare 4 interrupt flag
        using CC3IF = Field<_SR, 3, 1>; // Capture/Compare 3 interrupt flag
        using CC2IF = Field<_SR, 2, 1>; // Capture/Compare 2 interrupt flag
        using CC1IF = Field<_SR, 1, 1>; // Capture/compare 1 interrupt flag
        using UIF = Field<_SR, 0, 1>; // Update interrupt flag
    };

    // event generation register
    struct _EGR : Register<TIM4_BASE + 0x14, WriteOnly, _EGR> {
        using TG = Field<_EGR, 6, 1>; // Trigger generation
        using CC4G = Field<_EGR, 4, 1>; // Capture/compare 4 generation
        using CC3G = Field<_EGR, 3, 1>; // Capture/compare 3 generation
        using CC2G = Field<_EGR, 2, 1>; // Capture/compare 2 generation
        using CC1G = Field<_EGR, 1, 1>; // Capture/compare 1 generation
        using UG = Field<_EGR, 0, 1>; // Update generation
    };

    // capture/compare mode register 1 (output mode)
    struct _CCMR1_Output : Register<TIM4_BASE + 0x18, ReadWrite, _CCMR1_Output> {
        using OC2CE = Field<_CCMR1_Output, 15, 1>; // OC2CE
        using OC2M = Field<_CCMR1_Output, 12, 3>; // OC2M
        using OC2PE = Field<_CCMR1_Output, 11, 1>; // OC2PE
        using OC2FE = Field<_CCMR1_Output, 10, 1>; // OC2FE
        using CC2S = Field<_CCMR1_Output, 8, 2>; // CC2S
        using OC1CE = Field<_CCMR1_Output, 7, 1>; // OC1CE
        using OC1M = Field<_CCMR1_Output, 4, 3>; // OC1M
        using OC1PE = Field<_CCMR1_Output, 3, 1>; // OC1PE
        using OC1FE = Field<_CCMR1_Output, 2, 1>; // OC1FE
        using CC1S = Field<_CCMR1_Output, 0, 2>; // CC1S
    };

    // capture/compare mode register 1 (input mode)
    struct _CCMR1_Input : Register<TIM4_BASE + 0x18, ReadWrite, _CCMR1_Input> {
        using IC2F = Field<_CCMR1_Input, 12, 4>; // Input capture 2 filter
        using IC2PSC = Field<_CCMR1_Input, 10, 2>; // Input capture 2 prescaler
        using CC2S = Field<_CCMR1_Input, 8, 2>; // Capture/Compare 2 selection
        using IC1F = Field<_CCMR1_Input, 4, 4>; // Input capture 1 filter
        using IC1PSC = Field<_CCMR1_Input, 2, 2>; // Input capture 1 prescaler
        using CC1S = Field<_CCMR1_Input, 0, 2>; // Capture/Compare 1 selection
    };

    // capture/compare mode register 2 (output mode)
    struct _CCMR2_Output : Register<TIM4_BASE + 0x1C, ReadWrite, _CCMR2_Output> {
        using O24CE = Field<_CCMR2_Output, 15, 1>; // O24CE
        using OC4M = Field<_CCMR2_Output, 12, 3>; // OC4M
        using OC4PE = Field<_CCMR2_Output, 11, 1>; // OC4PE
        using OC4FE = Field<_CCMR2_Output, 10, 1>; // OC4FE
        using CC4S = Field<_CCMR2_Output, 8, 2>; // CC4S
        using OC3CE = Field<_CCMR2_Output, 7, 1>; // OC3CE
        using OC3M = Field<_CCMR2_Output, 4, 3>; // OC3M
        using OC3PE = Field<_CCMR2_Output, 3, 1>; // OC3PE
        using OC3FE = Field<_CCMR2_Output, 2, 1>; // OC3FE
        using CC3S = Field<_CCMR2_Output, 0, 2>; // CC3S
    };

    // capture/compare mode register 2 (input mode)
    struct _CCMR2_Input : Register<TIM4_BASE + 0x1C, ReadWrite, _CCMR2_Input> {
        using IC4F = Field<_CCMR2_Input, 12, 4>; // Input capture 4 filter
        using IC4PSC = Field<_CCMR2_Input, 10, 2>; // Input capture 4 prescaler
        using CC4S = Field<_CCMR2_Input, 8, 2>; // Capture/Compare 4 selection
        using IC3F = Field<_CCMR2_Input, 4, 4>; // Input capture 3 filter
        using IC3PSC = Field<_CCMR2_Input, 2, 2>; // Input capture 3 prescaler
        using CC3S = Field<_CCMR2_Input, 0, 2>; // Capture/compare 3 selection
    };

    // capture/compare enable register
    struct _CCER : Register<TIM4_BASE + 0x20, ReadWrite, _CCER> {
        using CC4NP = Field<_CCER, 15, 1>; // Capture/Compare 4 output Polarity
        using CC4P = Field<_CCER, 13, 1>; // Capture/Compare 3 output Polarity
        using CC4E = Field<_CCER, 12, 1>; // Capture/Compare 4 output enable
        using CC3NP = Field<_CCER, 11, 1>; // Capture/Compare 3 output Polarity
        using CC3P = Field<_CCER, 9, 1>; // Capture/Compare 3 output Polarity
        using CC3E = Field<_CCER, 8, 1>; // Capture/Compare 3 output enable
        using CC2NP = Field<_CCER, 7, 1>; // Capture/Compare 2 output Polarity
        using CC2P = Field<_CCER, 5, 1>; // Capture/Compare 2 output Polarity
        using CC2E = Field<_CCER, 4, 1>; // Capture/Compare 2 output enable
        using CC1NP = Field<_CCER, 3, 1>; // Capture/Compare 1 output Polarity
        using CC1P = Field<_CCER, 1, 1>; // Capture/Compare 1 output Polarity
        using CC1E = Field<_CCER, 0, 1>; // Capture/Compare 1 output enable
    };

    // counter
    struct _CNT : Register<TIM4_BASE + 0x24, ReadWrite, _CNT> {
        using CNT_H = Field<_CNT, 16, 16>; // High counter value
        using CNT_L = Field<_CNT, 0, 16>; // Low counter value
    };

    // prescaler
    struct _PSC : Register<TIM4_BASE + 0x28, ReadWrite, _PSC> {
        using PSC = Field<_PSC, 0, 16>; // Prescaler value
    };

    // auto-reload register
    struct _ARR : Register<TIM4_BASE + 0x2C, ReadWrite, _ARR> {
        using ARR_H = Field<_ARR, 16, 16>; // High Auto-reload value
        using ARR_L = Field<_ARR, 0, 16>; // Low Auto-reload value
    };

    // capture/compare register 1
    struct _CCR1 : Register<TIM4_BASE + 0x34, ReadWrite, _CCR1> {
        using CCR1_H = Field<_CCR1, 16, 16>; // High Capture/Compare 1 value
        using CCR1_L = Field<_CCR1, 0, 16>; // Low Capture/Compare 1 value
    };

    // capture/compare register 2
    struct _CCR2 : Register<TIM4_BASE + 0x38, ReadWrite, _CCR2> {
        using CCR2_H = Field<_CCR2, 16, 16>; // High Capture/Compare 2 value
        using CCR2_L = Field<_CCR2, 0, 16>; // Low Capture/Compare 2 value
    };

    // capture/compare register 3
    struct _CCR3 : Register<TIM4_BASE + 0x3C, ReadWrite, _CCR3> {
        using CCR3_H = Field<_CCR3, 16, 16>; // High Capture/Compare value
        using CCR3_L = Field<_CCR3, 0, 16>; // Low Capture/Compare value
    };

    // capture/compare register 4
    struct _CCR4 : Register<TIM4_BASE + 0x40, ReadWrite, _CCR4> {
        using CCR4_H = Field<_CCR4, 16, 16>; // High Capture/Compare value
        using CCR4_L = Field<_CCR4, 0, 16>; // Low Capture/Compare value
    };

    // DMA control register
    struct _DCR : Register<TIM4_BASE + 0x48, ReadWrite, _DCR> {
        using DBL = Field<_DCR, 8, 5>; // DMA burst length
        using DBA = Field<_DCR, 0, 5>; // DMA base address
    };

    // DMA address for full transfer
    struct _DMAR : Register<TIM4_BASE + 0x4C, ReadWrite, _DMAR> {
        using DMAB = Field<_DMAR, 0, 16>; // DMA register for burst accesses
    };

} // namespace TIM4

// --------------------------------------------
// TIM5: 
// Base address: 0x40000C00
// --------------------------------------------

namespace TIM5 {
    static constexpr uint32_t TIM5_BASE = 0x40000C00;

} // namespace TIM5

// --------------------------------------------
// TIM9: General purpose timers
// Base address: 0x40014000
// --------------------------------------------

namespace TIM9 {
    static constexpr uint32_t TIM9_BASE = 0x40014000;

    // control register 1
    struct _CR1 : Register<TIM9_BASE + 0x0, ReadWrite, _CR1> {
        using CKD = Field<_CR1, 8, 2>; // Clock division
        using ARPE = Field<_CR1, 7, 1>; // Auto-reload preload enable
        using OPM = Field<_CR1, 3, 1>; // One-pulse mode
        using URS = Field<_CR1, 2, 1>; // Update request source
        using UDIS = Field<_CR1, 1, 1>; // Update disable
        using CEN = Field<_CR1, 0, 1>; // Counter enable
    };

    // slave mode control register
    struct _SMCR : Register<TIM9_BASE + 0x8, ReadWrite, _SMCR> {
        using MSM = Field<_SMCR, 7, 1>; // Master/Slave mode
        using TS = Field<_SMCR, 4, 3>; // Trigger selection
        using SMS = Field<_SMCR, 0, 3>; // Slave mode selection
    };

    // DMA/Interrupt enable register
    struct _DIER : Register<TIM9_BASE + 0xC, ReadWrite, _DIER> {
        using TIE = Field<_DIER, 6, 1>; // Trigger interrupt enable
        using CC2IE = Field<_DIER, 2, 1>; // Capture/Compare 2 interrupt enable
        using CC1IE = Field<_DIER, 1, 1>; // Capture/Compare 1 interrupt enable
        using UIE = Field<_DIER, 0, 1>; // Update interrupt enable
    };

    // status register
    struct _SR : Register<TIM9_BASE + 0x10, ReadWrite, _SR> {
        using CC2OF = Field<_SR, 10, 1>; // Capture/compare 2 overcapture flag
        using CC1OF = Field<_SR, 9, 1>; // Capture/Compare 1 overcapture flag
        using TIF = Field<_SR, 6, 1>; // Trigger interrupt flag
        using CC2IF = Field<_SR, 2, 1>; // Capture/Compare 2 interrupt flag
        using CC1IF = Field<_SR, 1, 1>; // Capture/compare 1 interrupt flag
        using UIF = Field<_SR, 0, 1>; // Update interrupt flag
    };

    // event generation register
    struct _EGR : Register<TIM9_BASE + 0x14, WriteOnly, _EGR> {
        using TG = Field<_EGR, 6, 1>; // Trigger generation
        using CC2G = Field<_EGR, 2, 1>; // Capture/compare 2 generation
        using CC1G = Field<_EGR, 1, 1>; // Capture/compare 1 generation
        using UG = Field<_EGR, 0, 1>; // Update generation
    };

    // capture/compare mode register 1 (output mode)
    struct _CCMR1_Output : Register<TIM9_BASE + 0x18, ReadWrite, _CCMR1_Output> {
        using OC2M = Field<_CCMR1_Output, 12, 3>; // Output Compare 2 mode
        using OC2PE = Field<_CCMR1_Output, 11, 1>; // Output Compare 2 preload enable
        using OC2FE = Field<_CCMR1_Output, 10, 1>; // Output Compare 2 fast enable
        using CC2S = Field<_CCMR1_Output, 8, 2>; // Capture/Compare 2 selection
        using OC1M = Field<_CCMR1_Output, 4, 3>; // Output Compare 1 mode
        using OC1PE = Field<_CCMR1_Output, 3, 1>; // Output Compare 1 preload enable
        using OC1FE = Field<_CCMR1_Output, 2, 1>; // Output Compare 1 fast enable
        using CC1S = Field<_CCMR1_Output, 0, 2>; // Capture/Compare 1 selection
    };

    // capture/compare mode register 1 (input mode)
    struct _CCMR1_Input : Register<TIM9_BASE + 0x18, ReadWrite, _CCMR1_Input> {
        using IC2F = Field<_CCMR1_Input, 12, 3>; // Input capture 2 filter
        using IC2PSC = Field<_CCMR1_Input, 10, 2>; // Input capture 2 prescaler
        using CC2S = Field<_CCMR1_Input, 8, 2>; // Capture/Compare 2 selection
        using IC1F = Field<_CCMR1_Input, 4, 3>; // Input capture 1 filter
        using IC1PSC = Field<_CCMR1_Input, 2, 2>; // Input capture 1 prescaler
        using CC1S = Field<_CCMR1_Input, 0, 2>; // Capture/Compare 1 selection
    };

    // capture/compare enable register
    struct _CCER : Register<TIM9_BASE + 0x20, ReadWrite, _CCER> {
        using CC2NP = Field<_CCER, 7, 1>; // Capture/Compare 2 output Polarity
        using CC2P = Field<_CCER, 5, 1>; // Capture/Compare 2 output Polarity
        using CC2E = Field<_CCER, 4, 1>; // Capture/Compare 2 output enable
        using CC1NP = Field<_CCER, 3, 1>; // Capture/Compare 1 output Polarity
        using CC1P = Field<_CCER, 1, 1>; // Capture/Compare 1 output Polarity
        using CC1E = Field<_CCER, 0, 1>; // Capture/Compare 1 output enable
    };

    // counter
    struct _CNT : Register<TIM9_BASE + 0x24, ReadWrite, _CNT> {
        using CNT = Field<_CNT, 0, 16>; // counter value
    };

    // prescaler
    struct _PSC : Register<TIM9_BASE + 0x28, ReadWrite, _PSC> {
        using PSC = Field<_PSC, 0, 16>; // Prescaler value
    };

    // auto-reload register
    struct _ARR : Register<TIM9_BASE + 0x2C, ReadWrite, _ARR> {
        using ARR = Field<_ARR, 0, 16>; // Auto-reload value
    };

    // capture/compare register 1
    struct _CCR1 : Register<TIM9_BASE + 0x34, ReadWrite, _CCR1> {
        using CCR1 = Field<_CCR1, 0, 16>; // Capture/Compare 1 value
    };

    // capture/compare register 2
    struct _CCR2 : Register<TIM9_BASE + 0x38, ReadWrite, _CCR2> {
        using CCR2 = Field<_CCR2, 0, 16>; // Capture/Compare 2 value
    };

} // namespace TIM9

// --------------------------------------------
// TIM12: 
// Base address: 0x40001800
// --------------------------------------------

namespace TIM12 {
    static constexpr uint32_t TIM12_BASE = 0x40001800;

} // namespace TIM12

// --------------------------------------------
// TIM10: General-purpose-timers
// Base address: 0x40014400
// --------------------------------------------

namespace TIM10 {
    static constexpr uint32_t TIM10_BASE = 0x40014400;

    // control register 1
    struct _CR1 : Register<TIM10_BASE + 0x0, ReadWrite, _CR1> {
        using CKD = Field<_CR1, 8, 2>; // Clock division
        using ARPE = Field<_CR1, 7, 1>; // Auto-reload preload enable
        using URS = Field<_CR1, 2, 1>; // Update request source
        using UDIS = Field<_CR1, 1, 1>; // Update disable
        using CEN = Field<_CR1, 0, 1>; // Counter enable
    };

    // DMA/Interrupt enable register
    struct _DIER : Register<TIM10_BASE + 0xC, ReadWrite, _DIER> {
        using CC1IE = Field<_DIER, 1, 1>; // Capture/Compare 1 interrupt enable
        using UIE = Field<_DIER, 0, 1>; // Update interrupt enable
    };

    // status register
    struct _SR : Register<TIM10_BASE + 0x10, ReadWrite, _SR> {
        using CC1OF = Field<_SR, 9, 1>; // Capture/Compare 1 overcapture flag
        using CC1IF = Field<_SR, 1, 1>; // Capture/compare 1 interrupt flag
        using UIF = Field<_SR, 0, 1>; // Update interrupt flag
    };

    // event generation register
    struct _EGR : Register<TIM10_BASE + 0x14, WriteOnly, _EGR> {
        using CC1G = Field<_EGR, 1, 1>; // Capture/compare 1 generation
        using UG = Field<_EGR, 0, 1>; // Update generation
    };

    // capture/compare mode register 1 (output mode)
    struct _CCMR1_Output : Register<TIM10_BASE + 0x18, ReadWrite, _CCMR1_Output> {
        using OC1M = Field<_CCMR1_Output, 4, 3>; // Output Compare 1 mode
        using OC1PE = Field<_CCMR1_Output, 3, 1>; // Output Compare 1 preload enable
        using OC1FE = Field<_CCMR1_Output, 2, 1>; // Output Compare 1 fast enable
        using CC1S = Field<_CCMR1_Output, 0, 2>; // Capture/Compare 1 selection
    };

    // capture/compare mode register 1 (input mode)
    struct _CCMR1_Input : Register<TIM10_BASE + 0x18, ReadWrite, _CCMR1_Input> {
        using IC1F = Field<_CCMR1_Input, 4, 4>; // Input capture 1 filter
        using IC1PSC = Field<_CCMR1_Input, 2, 2>; // Input capture 1 prescaler
        using CC1S = Field<_CCMR1_Input, 0, 2>; // Capture/Compare 1 selection
    };

    // capture/compare enable register
    struct _CCER : Register<TIM10_BASE + 0x20, ReadWrite, _CCER> {
        using CC1NP = Field<_CCER, 3, 1>; // Capture/Compare 1 output Polarity
        using CC1P = Field<_CCER, 1, 1>; // Capture/Compare 1 output Polarity
        using CC1E = Field<_CCER, 0, 1>; // Capture/Compare 1 output enable
    };

    // counter
    struct _CNT : Register<TIM10_BASE + 0x24, ReadWrite, _CNT> {
        using CNT = Field<_CNT, 0, 16>; // counter value
    };

    // prescaler
    struct _PSC : Register<TIM10_BASE + 0x28, ReadWrite, _PSC> {
        using PSC = Field<_PSC, 0, 16>; // Prescaler value
    };

    // auto-reload register
    struct _ARR : Register<TIM10_BASE + 0x2C, ReadWrite, _ARR> {
        using ARR = Field<_ARR, 0, 16>; // Auto-reload value
    };

    // capture/compare register 1
    struct _CCR1 : Register<TIM10_BASE + 0x34, ReadWrite, _CCR1> {
        using CCR1 = Field<_CCR1, 0, 16>; // Capture/Compare 1 value
    };

    // slave mode control register
    struct _SMCR : Register<TIM10_BASE + 0x8, ReadWrite, _SMCR> {
        using SMS3 = Field<_SMCR, 16, 1>; // Slave mode selection
        using ETP = Field<_SMCR, 15, 1>; // External trigger polarity
        using ECE = Field<_SMCR, 14, 1>; // External clock enable
        using ETPS = Field<_SMCR, 12, 2>; // External trigger prescaler
        using ETF = Field<_SMCR, 8, 4>; // External trigger filter
        using MSM = Field<_SMCR, 7, 1>; // Master/slave mode
        using TS = Field<_SMCR, 4, 3>; // Trigger selection
        using SMS = Field<_SMCR, 0, 3>; // Slave mode selection
    };

    // option register
    struct _OR : Register<TIM10_BASE + 0x50, ReadWrite, _OR> {
        using TI1_RMP = Field<_OR, 0, 2>; // TIM11 Input 1 remapping capability
    };

} // namespace TIM10

// --------------------------------------------
// TIM11: 
// Base address: 0x40014800
// --------------------------------------------

namespace TIM11 {
    static constexpr uint32_t TIM11_BASE = 0x40014800;

} // namespace TIM11

// --------------------------------------------
// TIM13: 
// Base address: 0x40001C00
// --------------------------------------------

namespace TIM13 {
    static constexpr uint32_t TIM13_BASE = 0x40001C00;

} // namespace TIM13

// --------------------------------------------
// TIM14: 
// Base address: 0x40002000
// --------------------------------------------

namespace TIM14 {
    static constexpr uint32_t TIM14_BASE = 0x40002000;

} // namespace TIM14

// --------------------------------------------
// TIM6: Basic timers
// Base address: 0x40001000
// --------------------------------------------

namespace TIM6 {
    static constexpr uint32_t TIM6_BASE = 0x40001000;

    // control register 1
    struct _CR1 : Register<TIM6_BASE + 0x0, ReadWrite, _CR1> {
        using ARPE = Field<_CR1, 7, 1>; // Auto-reload preload enable
        using OPM = Field<_CR1, 3, 1>; // One-pulse mode
        using URS = Field<_CR1, 2, 1>; // Update request source
        using UDIS = Field<_CR1, 1, 1>; // Update disable
        using CEN = Field<_CR1, 0, 1>; // Counter enable
    };

    // control register 2
    struct _CR2 : Register<TIM6_BASE + 0x4, ReadWrite, _CR2> {
        using MMS = Field<_CR2, 4, 3>; // Master mode selection
    };

    // DMA/Interrupt enable register
    struct _DIER : Register<TIM6_BASE + 0xC, ReadWrite, _DIER> {
        using UDE = Field<_DIER, 8, 1>; // Update DMA request enable
        using UIE = Field<_DIER, 0, 1>; // Update interrupt enable
    };

    // status register
    struct _SR : Register<TIM6_BASE + 0x10, ReadWrite, _SR> {
        using UIF = Field<_SR, 0, 1>; // Update interrupt flag
    };

    // event generation register
    struct _EGR : Register<TIM6_BASE + 0x14, WriteOnly, _EGR> {
        using UG = Field<_EGR, 0, 1>; // Update generation
    };

    // counter
    struct _CNT : Register<TIM6_BASE + 0x24, ReadWrite, _CNT> {
        using CNT = Field<_CNT, 0, 16>; // Low counter value
    };

    // prescaler
    struct _PSC : Register<TIM6_BASE + 0x28, ReadWrite, _PSC> {
        using PSC = Field<_PSC, 0, 16>; // Prescaler value
    };

    // auto-reload register
    struct _ARR : Register<TIM6_BASE + 0x2C, ReadWrite, _ARR> {
        using ARR = Field<_ARR, 0, 16>; // Low Auto-reload value
    };

} // namespace TIM6

// --------------------------------------------
// TIM7: 
// Base address: 0x40001400
// --------------------------------------------

namespace TIM7 {
    static constexpr uint32_t TIM7_BASE = 0x40001400;

} // namespace TIM7

// --------------------------------------------
// Ethernet_MAC: Ethernet: media access control (MAC)
// Base address: 0x40028000
// --------------------------------------------

namespace Ethernet_MAC {
    static constexpr uint32_t Ethernet_MAC_BASE = 0x40028000;

    // Ethernet MAC configuration register
    struct _MACCR : Register<Ethernet_MAC_BASE + 0x0, ReadWrite, _MACCR> {
        using RE = Field<_MACCR, 2, 1>; // RE
        using TE = Field<_MACCR, 3, 1>; // TE
        using DC = Field<_MACCR, 4, 1>; // DC
        using BL = Field<_MACCR, 5, 2>; // BL
        using APCS = Field<_MACCR, 7, 1>; // APCS
        using RD = Field<_MACCR, 9, 1>; // RD
        using IPCO = Field<_MACCR, 10, 1>; // IPCO
        using DM = Field<_MACCR, 11, 1>; // DM
        using LM = Field<_MACCR, 12, 1>; // LM
        using ROD = Field<_MACCR, 13, 1>; // ROD
        using FES = Field<_MACCR, 14, 1>; // FES
        using CSD = Field<_MACCR, 16, 1>; // CSD
        using IFG = Field<_MACCR, 17, 3>; // IFG
        using JD = Field<_MACCR, 22, 1>; // JD
        using WD = Field<_MACCR, 23, 1>; // WD
        using CSTF = Field<_MACCR, 25, 1>; // CSTF
    };

    // Ethernet MAC frame filter register
    struct _MACFFR : Register<Ethernet_MAC_BASE + 0x4, ReadWrite, _MACFFR> {
        using PM = Field<_MACFFR, 0, 1>; // PM
        using HU = Field<_MACFFR, 1, 1>; // HU
        using HM = Field<_MACFFR, 2, 1>; // HM
        using DAIF = Field<_MACFFR, 3, 1>; // DAIF
        using RAM = Field<_MACFFR, 4, 1>; // RAM
        using BFD = Field<_MACFFR, 5, 1>; // BFD
        using PCF = Field<_MACFFR, 6, 1>; // PCF
        using SAIF = Field<_MACFFR, 7, 1>; // SAIF
        using SAF = Field<_MACFFR, 8, 1>; // SAF
        using HPF = Field<_MACFFR, 9, 1>; // HPF
        using RA = Field<_MACFFR, 31, 1>; // RA
    };

    // Ethernet MAC hash table high register
    struct _MACHTHR : Register<Ethernet_MAC_BASE + 0x8, ReadWrite, _MACHTHR> {
        using HTH = Field<_MACHTHR, 0, 32>; // HTH
    };

    // Ethernet MAC hash table low register
    struct _MACHTLR : Register<Ethernet_MAC_BASE + 0xC, ReadWrite, _MACHTLR> {
        using HTL = Field<_MACHTLR, 0, 32>; // HTL
    };

    // Ethernet MAC MII address register
    struct _MACMIIAR : Register<Ethernet_MAC_BASE + 0x10, ReadWrite, _MACMIIAR> {
        using MB = Field<_MACMIIAR, 0, 1>; // MB
        using MW = Field<_MACMIIAR, 1, 1>; // MW
        using CR = Field<_MACMIIAR, 2, 3>; // CR
        using MR = Field<_MACMIIAR, 6, 5>; // MR
        using PA = Field<_MACMIIAR, 11, 5>; // PA
    };

    // Ethernet MAC MII data register
    struct _MACMIIDR : Register<Ethernet_MAC_BASE + 0x14, ReadWrite, _MACMIIDR> {
        using TD = Field<_MACMIIDR, 0, 16>; // TD
    };

    // Ethernet MAC flow control register
    struct _MACFCR : Register<Ethernet_MAC_BASE + 0x18, ReadWrite, _MACFCR> {
        using FCB = Field<_MACFCR, 0, 1>; // FCB
        using TFCE = Field<_MACFCR, 1, 1>; // TFCE
        using RFCE = Field<_MACFCR, 2, 1>; // RFCE
        using UPFD = Field<_MACFCR, 3, 1>; // UPFD
        using PLT = Field<_MACFCR, 4, 2>; // PLT
        using ZQPD = Field<_MACFCR, 7, 1>; // ZQPD
        using PT = Field<_MACFCR, 16, 16>; // PT
    };

    // Ethernet MAC VLAN tag register
    struct _MACVLANTR : Register<Ethernet_MAC_BASE + 0x1C, ReadWrite, _MACVLANTR> {
        using VLANTI = Field<_MACVLANTR, 0, 16>; // VLANTI
        using VLANTC = Field<_MACVLANTR, 16, 1>; // VLANTC
    };

    // Ethernet MAC PMT control and status register
    struct _MACPMTCSR : Register<Ethernet_MAC_BASE + 0x2C, ReadWrite, _MACPMTCSR> {
        using PD = Field<_MACPMTCSR, 0, 1>; // PD
        using MPE = Field<_MACPMTCSR, 1, 1>; // MPE
        using WFE = Field<_MACPMTCSR, 2, 1>; // WFE
        using MPR = Field<_MACPMTCSR, 5, 1>; // MPR
        using WFR = Field<_MACPMTCSR, 6, 1>; // WFR
        using GU = Field<_MACPMTCSR, 9, 1>; // GU
        using WFFRPR = Field<_MACPMTCSR, 31, 1>; // WFFRPR
    };

    // Ethernet MAC debug register
    struct _MACDBGR : Register<Ethernet_MAC_BASE + 0x34, ReadOnly, _MACDBGR> {
        using CR = Field<_MACDBGR, 0, 1>; // CR
        using CSR = Field<_MACDBGR, 1, 1>; // CSR
        using ROR = Field<_MACDBGR, 2, 1>; // ROR
        using MCF = Field<_MACDBGR, 3, 1>; // MCF
        using MCP = Field<_MACDBGR, 4, 1>; // MCP
        using MCFHP = Field<_MACDBGR, 5, 1>; // MCFHP
    };

    // Ethernet MAC interrupt status register
    struct _MACSR : Register<Ethernet_MAC_BASE + 0x38, ReadWrite, _MACSR> {
        using PMTS = Field<_MACSR, 3, 1>; // PMTS
        using MMCS = Field<_MACSR, 4, 1>; // MMCS
        using MMCRS = Field<_MACSR, 5, 1>; // MMCRS
        using MMCTS = Field<_MACSR, 6, 1>; // MMCTS
        using TSTS = Field<_MACSR, 9, 1>; // TSTS
    };

    // Ethernet MAC interrupt mask register
    struct _MACIMR : Register<Ethernet_MAC_BASE + 0x3C, ReadWrite, _MACIMR> {
        using PMTIM = Field<_MACIMR, 3, 1>; // PMTIM
        using TSTIM = Field<_MACIMR, 9, 1>; // TSTIM
    };

    // Ethernet MAC address 0 high register
    struct _MACA0HR : Register<Ethernet_MAC_BASE + 0x40, ReadWrite, _MACA0HR> {
        using MACA0H = Field<_MACA0HR, 0, 16>; // MAC address0 high
        using MO = Field<_MACA0HR, 31, 1>; // Always 1
    };

    // Ethernet MAC address 0 low register
    struct _MACA0LR : Register<Ethernet_MAC_BASE + 0x44, ReadWrite, _MACA0LR> {
        using MACA0L = Field<_MACA0LR, 0, 32>; // 0
    };

    // Ethernet MAC address 1 high register
    struct _MACA1HR : Register<Ethernet_MAC_BASE + 0x48, ReadWrite, _MACA1HR> {
        using MACA1H = Field<_MACA1HR, 0, 16>; // MACA1H
        using MBC = Field<_MACA1HR, 24, 6>; // MBC
        using SA = Field<_MACA1HR, 30, 1>; // SA
        using AE = Field<_MACA1HR, 31, 1>; // AE
    };

    // Ethernet MAC address1 low register
    struct _MACA1LR : Register<Ethernet_MAC_BASE + 0x4C, ReadWrite, _MACA1LR> {
        using MACA1LR = Field<_MACA1LR, 0, 32>; // MACA1LR
    };

    // Ethernet MAC address 2 high register
    struct _MACA2HR : Register<Ethernet_MAC_BASE + 0x50, ReadWrite, _MACA2HR> {
        using MAC2AH = Field<_MACA2HR, 0, 16>; // MAC2AH
        using MBC = Field<_MACA2HR, 24, 6>; // MBC
        using SA = Field<_MACA2HR, 30, 1>; // SA
        using AE = Field<_MACA2HR, 31, 1>; // AE
    };

    // Ethernet MAC address 2 low register
    struct _MACA2LR : Register<Ethernet_MAC_BASE + 0x54, ReadWrite, _MACA2LR> {
        using MACA2L = Field<_MACA2LR, 0, 31>; // MACA2L
    };

    // Ethernet MAC address 3 high register
    struct _MACA3HR : Register<Ethernet_MAC_BASE + 0x58, ReadWrite, _MACA3HR> {
        using MACA3H = Field<_MACA3HR, 0, 16>; // MACA3H
        using MBC = Field<_MACA3HR, 24, 6>; // MBC
        using SA = Field<_MACA3HR, 30, 1>; // SA
        using AE = Field<_MACA3HR, 31, 1>; // AE
    };

    // Ethernet MAC address 3 low register
    struct _MACA3LR : Register<Ethernet_MAC_BASE + 0x5C, ReadWrite, _MACA3LR> {
        using MBCA3L = Field<_MACA3LR, 0, 32>; // MBCA3L
    };

    // Ethernet MAC remote wakeup frame filter register

} // namespace Ethernet_MAC

// --------------------------------------------
// CRC: Cryptographic processor
// Base address: 0x40023000
// --------------------------------------------

namespace CRC {
    static constexpr uint32_t CRC_BASE = 0x40023000;

    // Data register
    struct _DR : Register<CRC_BASE + 0x0, ReadWrite, _DR> {
        using DR = Field<_DR, 0, 32>; // Data Register
    };

    // Independent Data register
    struct _IDR : Register<CRC_BASE + 0x4, ReadWrite, _IDR> {
        using IDR = Field<_IDR, 0, 8>; // Independent Data register
    };

    // Control register
    struct _CR : Register<CRC_BASE + 0x8, WriteOnly, _CR> {
        using CR = Field<_CR, 0, 1>; // Control regidter
    };

    // Initial CRC value
    struct _INIT : Register<CRC_BASE + 0x10, ReadWrite, _INIT> {
        using CRC_INIT = Field<_INIT, 0, 32>; // Programmable initial CRC value
    };

    // CRC polynomial
    struct _POL : Register<CRC_BASE + 0x14, ReadWrite, _POL> {
        using POL = Field<_POL, 0, 32>; // Programmable polynomial
    };

} // namespace CRC

// --------------------------------------------
// CAN1: Controller area network
// Base address: 0x40006400
// --------------------------------------------

namespace CAN1 {
    static constexpr uint32_t CAN1_BASE = 0x40006400;

    // master control register
    struct _MCR : Register<CAN1_BASE + 0x0, ReadWrite, _MCR> {
        using DBF = Field<_MCR, 16, 1>; // DBF
        using RESET = Field<_MCR, 15, 1>; // RESET
        using TTCM = Field<_MCR, 7, 1>; // TTCM
        using ABOM = Field<_MCR, 6, 1>; // ABOM
        using AWUM = Field<_MCR, 5, 1>; // AWUM
        using NART = Field<_MCR, 4, 1>; // NART
        using RFLM = Field<_MCR, 3, 1>; // RFLM
        using TXFP = Field<_MCR, 2, 1>; // TXFP
        using SLEEP = Field<_MCR, 1, 1>; // SLEEP
        using INRQ = Field<_MCR, 0, 1>; // INRQ
    };

    // master status register
    struct _MSR : Register<CAN1_BASE + 0x4, ReadWrite, _MSR> {
        using RX = Field<_MSR, 11, 1>; // RX
        using SAMP = Field<_MSR, 10, 1>; // SAMP
        using RXM = Field<_MSR, 9, 1>; // RXM
        using TXM = Field<_MSR, 8, 1>; // TXM
        using SLAKI = Field<_MSR, 4, 1>; // SLAKI
        using WKUI = Field<_MSR, 3, 1>; // WKUI
        using ERRI = Field<_MSR, 2, 1>; // ERRI
        using SLAK = Field<_MSR, 1, 1>; // SLAK
        using INAK = Field<_MSR, 0, 1>; // INAK
    };

    // transmit status register
    struct _TSR : Register<CAN1_BASE + 0x8, ReadWrite, _TSR> {
        using LOW2 = Field<_TSR, 31, 1>; // Lowest priority flag for mailbox 2
        using LOW1 = Field<_TSR, 30, 1>; // Lowest priority flag for mailbox 1
        using LOW0 = Field<_TSR, 29, 1>; // Lowest priority flag for mailbox 0
        using TME2 = Field<_TSR, 28, 1>; // Lowest priority flag for mailbox 2
        using TME1 = Field<_TSR, 27, 1>; // Lowest priority flag for mailbox 1
        using TME0 = Field<_TSR, 26, 1>; // Lowest priority flag for mailbox 0
        using CODE = Field<_TSR, 24, 2>; // CODE
        using ABRQ2 = Field<_TSR, 23, 1>; // ABRQ2
        using TERR2 = Field<_TSR, 19, 1>; // TERR2
        using ALST2 = Field<_TSR, 18, 1>; // ALST2
        using TXOK2 = Field<_TSR, 17, 1>; // TXOK2
        using RQCP2 = Field<_TSR, 16, 1>; // RQCP2
        using ABRQ1 = Field<_TSR, 15, 1>; // ABRQ1
        using TERR1 = Field<_TSR, 11, 1>; // TERR1
        using ALST1 = Field<_TSR, 10, 1>; // ALST1
        using TXOK1 = Field<_TSR, 9, 1>; // TXOK1
        using RQCP1 = Field<_TSR, 8, 1>; // RQCP1
        using ABRQ0 = Field<_TSR, 7, 1>; // ABRQ0
        using TERR0 = Field<_TSR, 3, 1>; // TERR0
        using ALST0 = Field<_TSR, 2, 1>; // ALST0
        using TXOK0 = Field<_TSR, 1, 1>; // TXOK0
        using RQCP0 = Field<_TSR, 0, 1>; // RQCP0
    };

    // receive FIFO 0 register
    struct _RF0R : Register<CAN1_BASE + 0xC, ReadWrite, _RF0R> {
        using RFOM0 = Field<_RF0R, 5, 1>; // RFOM0
        using FOVR0 = Field<_RF0R, 4, 1>; // FOVR0
        using FULL0 = Field<_RF0R, 3, 1>; // FULL0
        using FMP0 = Field<_RF0R, 0, 2>; // FMP0
    };

    // receive FIFO 1 register
    struct _RF1R : Register<CAN1_BASE + 0x10, ReadWrite, _RF1R> {
        using RFOM1 = Field<_RF1R, 5, 1>; // RFOM1
        using FOVR1 = Field<_RF1R, 4, 1>; // FOVR1
        using FULL1 = Field<_RF1R, 3, 1>; // FULL1
        using FMP1 = Field<_RF1R, 0, 2>; // FMP1
    };

    // interrupt enable register
    struct _IER : Register<CAN1_BASE + 0x14, ReadWrite, _IER> {
        using SLKIE = Field<_IER, 17, 1>; // SLKIE
        using WKUIE = Field<_IER, 16, 1>; // WKUIE
        using ERRIE = Field<_IER, 15, 1>; // ERRIE
        using LECIE = Field<_IER, 11, 1>; // LECIE
        using BOFIE = Field<_IER, 10, 1>; // BOFIE
        using EPVIE = Field<_IER, 9, 1>; // EPVIE
        using EWGIE = Field<_IER, 8, 1>; // EWGIE
        using FOVIE1 = Field<_IER, 6, 1>; // FOVIE1
        using FFIE1 = Field<_IER, 5, 1>; // FFIE1
        using FMPIE1 = Field<_IER, 4, 1>; // FMPIE1
        using FOVIE0 = Field<_IER, 3, 1>; // FOVIE0
        using FFIE0 = Field<_IER, 2, 1>; // FFIE0
        using FMPIE0 = Field<_IER, 1, 1>; // FMPIE0
        using TMEIE = Field<_IER, 0, 1>; // TMEIE
    };

    // interrupt enable register
    struct _ESR : Register<CAN1_BASE + 0x18, ReadWrite, _ESR> {
        using REC = Field<_ESR, 24, 8>; // REC
        using TEC = Field<_ESR, 16, 8>; // TEC
        using LEC = Field<_ESR, 4, 3>; // LEC
        using BOFF = Field<_ESR, 2, 1>; // BOFF
        using EPVF = Field<_ESR, 1, 1>; // EPVF
        using EWGF = Field<_ESR, 0, 1>; // EWGF
    };

    // bit timing register
    struct _BTR : Register<CAN1_BASE + 0x1C, ReadWrite, _BTR> {
        using SILM = Field<_BTR, 31, 1>; // SILM
        using LBKM = Field<_BTR, 30, 1>; // LBKM
        using SJW = Field<_BTR, 24, 2>; // SJW
        using TS2 = Field<_BTR, 20, 3>; // TS2
        using TS1 = Field<_BTR, 16, 4>; // TS1
        using BRP = Field<_BTR, 0, 10>; // BRP
    };

    // TX mailbox identifier register
    struct _TI0R : Register<CAN1_BASE + 0x180, ReadWrite, _TI0R> {
        using STID = Field<_TI0R, 21, 11>; // STID
        using EXID = Field<_TI0R, 3, 18>; // EXID
        using IDE = Field<_TI0R, 2, 1>; // IDE
        using RTR = Field<_TI0R, 1, 1>; // RTR
        using TXRQ = Field<_TI0R, 0, 1>; // TXRQ
    };

    // mailbox data length control and time stamp register
    struct _TDT0R : Register<CAN1_BASE + 0x184, ReadWrite, _TDT0R> {
        using TIME = Field<_TDT0R, 16, 16>; // TIME
        using TGT = Field<_TDT0R, 8, 1>; // TGT
        using DLC = Field<_TDT0R, 0, 4>; // DLC
    };

    // mailbox data low register
    struct _TDL0R : Register<CAN1_BASE + 0x188, ReadWrite, _TDL0R> {
        using DATA3 = Field<_TDL0R, 24, 8>; // DATA3
        using DATA2 = Field<_TDL0R, 16, 8>; // DATA2
        using DATA1 = Field<_TDL0R, 8, 8>; // DATA1
        using DATA0 = Field<_TDL0R, 0, 8>; // DATA0
    };

    // mailbox data high register
    struct _TDH0R : Register<CAN1_BASE + 0x18C, ReadWrite, _TDH0R> {
        using DATA7 = Field<_TDH0R, 24, 8>; // DATA7
        using DATA6 = Field<_TDH0R, 16, 8>; // DATA6
        using DATA5 = Field<_TDH0R, 8, 8>; // DATA5
        using DATA4 = Field<_TDH0R, 0, 8>; // DATA4
    };

    // mailbox identifier register
    struct _TI1R : Register<CAN1_BASE + 0x190, ReadWrite, _TI1R> {
        using STID = Field<_TI1R, 21, 11>; // STID
        using EXID = Field<_TI1R, 3, 18>; // EXID
        using IDE = Field<_TI1R, 2, 1>; // IDE
        using RTR = Field<_TI1R, 1, 1>; // RTR
        using TXRQ = Field<_TI1R, 0, 1>; // TXRQ
    };

    // mailbox data length control and time stamp register
    struct _TDT1R : Register<CAN1_BASE + 0x194, ReadWrite, _TDT1R> {
        using TIME = Field<_TDT1R, 16, 16>; // TIME
        using TGT = Field<_TDT1R, 8, 1>; // TGT
        using DLC = Field<_TDT1R, 0, 4>; // DLC
    };

    // mailbox data low register
    struct _TDL1R : Register<CAN1_BASE + 0x198, ReadWrite, _TDL1R> {
        using DATA3 = Field<_TDL1R, 24, 8>; // DATA3
        using DATA2 = Field<_TDL1R, 16, 8>; // DATA2
        using DATA1 = Field<_TDL1R, 8, 8>; // DATA1
        using DATA0 = Field<_TDL1R, 0, 8>; // DATA0
    };

    // mailbox data high register
    struct _TDH1R : Register<CAN1_BASE + 0x19C, ReadWrite, _TDH1R> {
        using DATA7 = Field<_TDH1R, 24, 8>; // DATA7
        using DATA6 = Field<_TDH1R, 16, 8>; // DATA6
        using DATA5 = Field<_TDH1R, 8, 8>; // DATA5
        using DATA4 = Field<_TDH1R, 0, 8>; // DATA4
    };

    // mailbox identifier register
    struct _TI2R : Register<CAN1_BASE + 0x1A0, ReadWrite, _TI2R> {
        using STID = Field<_TI2R, 21, 11>; // STID
        using EXID = Field<_TI2R, 3, 18>; // EXID
        using IDE = Field<_TI2R, 2, 1>; // IDE
        using RTR = Field<_TI2R, 1, 1>; // RTR
        using TXRQ = Field<_TI2R, 0, 1>; // TXRQ
    };

    // mailbox data length control and time stamp register
    struct _TDT2R : Register<CAN1_BASE + 0x1A4, ReadWrite, _TDT2R> {
        using TIME = Field<_TDT2R, 16, 16>; // TIME
        using TGT = Field<_TDT2R, 8, 1>; // TGT
        using DLC = Field<_TDT2R, 0, 4>; // DLC
    };

    // mailbox data low register
    struct _TDL2R : Register<CAN1_BASE + 0x1A8, ReadWrite, _TDL2R> {
        using DATA3 = Field<_TDL2R, 24, 8>; // DATA3
        using DATA2 = Field<_TDL2R, 16, 8>; // DATA2
        using DATA1 = Field<_TDL2R, 8, 8>; // DATA1
        using DATA0 = Field<_TDL2R, 0, 8>; // DATA0
    };

    // mailbox data high register
    struct _TDH2R : Register<CAN1_BASE + 0x1AC, ReadWrite, _TDH2R> {
        using DATA7 = Field<_TDH2R, 24, 8>; // DATA7
        using DATA6 = Field<_TDH2R, 16, 8>; // DATA6
        using DATA5 = Field<_TDH2R, 8, 8>; // DATA5
        using DATA4 = Field<_TDH2R, 0, 8>; // DATA4
    };

    // receive FIFO mailbox identifier register
    struct _RI0R : Register<CAN1_BASE + 0x1B0, ReadOnly, _RI0R> {
        using STID = Field<_RI0R, 21, 11>; // STID
        using EXID = Field<_RI0R, 3, 18>; // EXID
        using IDE = Field<_RI0R, 2, 1>; // IDE
        using RTR = Field<_RI0R, 1, 1>; // RTR
    };

    // mailbox data high register
    struct _RDT0R : Register<CAN1_BASE + 0x1B4, ReadOnly, _RDT0R> {
        using TIME = Field<_RDT0R, 16, 16>; // TIME
        using FMI = Field<_RDT0R, 8, 8>; // FMI
        using DLC = Field<_RDT0R, 0, 4>; // DLC
    };

    // mailbox data high register
    struct _RDL0R : Register<CAN1_BASE + 0x1B8, ReadOnly, _RDL0R> {
        using DATA3 = Field<_RDL0R, 24, 8>; // DATA3
        using DATA2 = Field<_RDL0R, 16, 8>; // DATA2
        using DATA1 = Field<_RDL0R, 8, 8>; // DATA1
        using DATA0 = Field<_RDL0R, 0, 8>; // DATA0
    };

    // receive FIFO mailbox data high register
    struct _RDH0R : Register<CAN1_BASE + 0x1BC, ReadOnly, _RDH0R> {
        using DATA7 = Field<_RDH0R, 24, 8>; // DATA7
        using DATA6 = Field<_RDH0R, 16, 8>; // DATA6
        using DATA5 = Field<_RDH0R, 8, 8>; // DATA5
        using DATA4 = Field<_RDH0R, 0, 8>; // DATA4
    };

    // mailbox data high register
    struct _RI1R : Register<CAN1_BASE + 0x1C0, ReadOnly, _RI1R> {
        using STID = Field<_RI1R, 21, 11>; // STID
        using EXID = Field<_RI1R, 3, 18>; // EXID
        using IDE = Field<_RI1R, 2, 1>; // IDE
        using RTR = Field<_RI1R, 1, 1>; // RTR
    };

    // mailbox data high register
    struct _RDT1R : Register<CAN1_BASE + 0x1C4, ReadOnly, _RDT1R> {
        using TIME = Field<_RDT1R, 16, 16>; // TIME
        using FMI = Field<_RDT1R, 8, 8>; // FMI
        using DLC = Field<_RDT1R, 0, 4>; // DLC
    };

    // mailbox data high register
    struct _RDL1R : Register<CAN1_BASE + 0x1C8, ReadOnly, _RDL1R> {
        using DATA3 = Field<_RDL1R, 24, 8>; // DATA3
        using DATA2 = Field<_RDL1R, 16, 8>; // DATA2
        using DATA1 = Field<_RDL1R, 8, 8>; // DATA1
        using DATA0 = Field<_RDL1R, 0, 8>; // DATA0
    };

    // mailbox data high register
    struct _RDH1R : Register<CAN1_BASE + 0x1CC, ReadOnly, _RDH1R> {
        using DATA7 = Field<_RDH1R, 24, 8>; // DATA7
        using DATA6 = Field<_RDH1R, 16, 8>; // DATA6
        using DATA5 = Field<_RDH1R, 8, 8>; // DATA5
        using DATA4 = Field<_RDH1R, 0, 8>; // DATA4
    };

    // filter master register
    struct _FMR : Register<CAN1_BASE + 0x200, ReadWrite, _FMR> {
        using CAN2SB = Field<_FMR, 8, 6>; // CAN2SB
        using FINIT = Field<_FMR, 0, 1>; // FINIT
    };

    // filter mode register
    struct _FM1R : Register<CAN1_BASE + 0x204, ReadWrite, _FM1R> {
        using FBM0 = Field<_FM1R, 0, 1>; // Filter mode
        using FBM1 = Field<_FM1R, 1, 1>; // Filter mode
        using FBM2 = Field<_FM1R, 2, 1>; // Filter mode
        using FBM3 = Field<_FM1R, 3, 1>; // Filter mode
        using FBM4 = Field<_FM1R, 4, 1>; // Filter mode
        using FBM5 = Field<_FM1R, 5, 1>; // Filter mode
        using FBM6 = Field<_FM1R, 6, 1>; // Filter mode
        using FBM7 = Field<_FM1R, 7, 1>; // Filter mode
        using FBM8 = Field<_FM1R, 8, 1>; // Filter mode
        using FBM9 = Field<_FM1R, 9, 1>; // Filter mode
        using FBM10 = Field<_FM1R, 10, 1>; // Filter mode
        using FBM11 = Field<_FM1R, 11, 1>; // Filter mode
        using FBM12 = Field<_FM1R, 12, 1>; // Filter mode
        using FBM13 = Field<_FM1R, 13, 1>; // Filter mode
        using FBM14 = Field<_FM1R, 14, 1>; // Filter mode
        using FBM15 = Field<_FM1R, 15, 1>; // Filter mode
        using FBM16 = Field<_FM1R, 16, 1>; // Filter mode
        using FBM17 = Field<_FM1R, 17, 1>; // Filter mode
        using FBM18 = Field<_FM1R, 18, 1>; // Filter mode
        using FBM19 = Field<_FM1R, 19, 1>; // Filter mode
        using FBM20 = Field<_FM1R, 20, 1>; // Filter mode
        using FBM21 = Field<_FM1R, 21, 1>; // Filter mode
        using FBM22 = Field<_FM1R, 22, 1>; // Filter mode
        using FBM23 = Field<_FM1R, 23, 1>; // Filter mode
        using FBM24 = Field<_FM1R, 24, 1>; // Filter mode
        using FBM25 = Field<_FM1R, 25, 1>; // Filter mode
        using FBM26 = Field<_FM1R, 26, 1>; // Filter mode
        using FBM27 = Field<_FM1R, 27, 1>; // Filter mode
    };

    // filter scale register
    struct _FS1R : Register<CAN1_BASE + 0x20C, ReadWrite, _FS1R> {
        using FSC0 = Field<_FS1R, 0, 1>; // Filter scale configuration
        using FSC1 = Field<_FS1R, 1, 1>; // Filter scale configuration
        using FSC2 = Field<_FS1R, 2, 1>; // Filter scale configuration
        using FSC3 = Field<_FS1R, 3, 1>; // Filter scale configuration
        using FSC4 = Field<_FS1R, 4, 1>; // Filter scale configuration
        using FSC5 = Field<_FS1R, 5, 1>; // Filter scale configuration
        using FSC6 = Field<_FS1R, 6, 1>; // Filter scale configuration
        using FSC7 = Field<_FS1R, 7, 1>; // Filter scale configuration
        using FSC8 = Field<_FS1R, 8, 1>; // Filter scale configuration
        using FSC9 = Field<_FS1R, 9, 1>; // Filter scale configuration
        using FSC10 = Field<_FS1R, 10, 1>; // Filter scale configuration
        using FSC11 = Field<_FS1R, 11, 1>; // Filter scale configuration
        using FSC12 = Field<_FS1R, 12, 1>; // Filter scale configuration
        using FSC13 = Field<_FS1R, 13, 1>; // Filter scale configuration
        using FSC14 = Field<_FS1R, 14, 1>; // Filter scale configuration
        using FSC15 = Field<_FS1R, 15, 1>; // Filter scale configuration
        using FSC16 = Field<_FS1R, 16, 1>; // Filter scale configuration
        using FSC17 = Field<_FS1R, 17, 1>; // Filter scale configuration
        using FSC18 = Field<_FS1R, 18, 1>; // Filter scale configuration
        using FSC19 = Field<_FS1R, 19, 1>; // Filter scale configuration
        using FSC20 = Field<_FS1R, 20, 1>; // Filter scale configuration
        using FSC21 = Field<_FS1R, 21, 1>; // Filter scale configuration
        using FSC22 = Field<_FS1R, 22, 1>; // Filter scale configuration
        using FSC23 = Field<_FS1R, 23, 1>; // Filter scale configuration
        using FSC24 = Field<_FS1R, 24, 1>; // Filter scale configuration
        using FSC25 = Field<_FS1R, 25, 1>; // Filter scale configuration
        using FSC26 = Field<_FS1R, 26, 1>; // Filter scale configuration
        using FSC27 = Field<_FS1R, 27, 1>; // Filter scale configuration
    };

    // filter FIFO assignment register
    struct _FFA1R : Register<CAN1_BASE + 0x214, ReadWrite, _FFA1R> {
        using FFA0 = Field<_FFA1R, 0, 1>; // Filter FIFO assignment for filter 0
        using FFA1 = Field<_FFA1R, 1, 1>; // Filter FIFO assignment for filter 1
        using FFA2 = Field<_FFA1R, 2, 1>; // Filter FIFO assignment for filter 2
        using FFA3 = Field<_FFA1R, 3, 1>; // Filter FIFO assignment for filter 3
        using FFA4 = Field<_FFA1R, 4, 1>; // Filter FIFO assignment for filter 4
        using FFA5 = Field<_FFA1R, 5, 1>; // Filter FIFO assignment for filter 5
        using FFA6 = Field<_FFA1R, 6, 1>; // Filter FIFO assignment for filter 6
        using FFA7 = Field<_FFA1R, 7, 1>; // Filter FIFO assignment for filter 7
        using FFA8 = Field<_FFA1R, 8, 1>; // Filter FIFO assignment for filter 8
        using FFA9 = Field<_FFA1R, 9, 1>; // Filter FIFO assignment for filter 9
        using FFA10 = Field<_FFA1R, 10, 1>; // Filter FIFO assignment for filter 10
        using FFA11 = Field<_FFA1R, 11, 1>; // Filter FIFO assignment for filter 11
        using FFA12 = Field<_FFA1R, 12, 1>; // Filter FIFO assignment for filter 12
        using FFA13 = Field<_FFA1R, 13, 1>; // Filter FIFO assignment for filter 13
        using FFA14 = Field<_FFA1R, 14, 1>; // Filter FIFO assignment for filter 14
        using FFA15 = Field<_FFA1R, 15, 1>; // Filter FIFO assignment for filter 15
        using FFA16 = Field<_FFA1R, 16, 1>; // Filter FIFO assignment for filter 16
        using FFA17 = Field<_FFA1R, 17, 1>; // Filter FIFO assignment for filter 17
        using FFA18 = Field<_FFA1R, 18, 1>; // Filter FIFO assignment for filter 18
        using FFA19 = Field<_FFA1R, 19, 1>; // Filter FIFO assignment for filter 19
        using FFA20 = Field<_FFA1R, 20, 1>; // Filter FIFO assignment for filter 20
        using FFA21 = Field<_FFA1R, 21, 1>; // Filter FIFO assignment for filter 21
        using FFA22 = Field<_FFA1R, 22, 1>; // Filter FIFO assignment for filter 22
        using FFA23 = Field<_FFA1R, 23, 1>; // Filter FIFO assignment for filter 23
        using FFA24 = Field<_FFA1R, 24, 1>; // Filter FIFO assignment for filter 24
        using FFA25 = Field<_FFA1R, 25, 1>; // Filter FIFO assignment for filter 25
        using FFA26 = Field<_FFA1R, 26, 1>; // Filter FIFO assignment for filter 26
        using FFA27 = Field<_FFA1R, 27, 1>; // Filter FIFO assignment for filter 27
    };

    // filter activation register
    struct _FA1R : Register<CAN1_BASE + 0x21C, ReadWrite, _FA1R> {
        using FACT0 = Field<_FA1R, 0, 1>; // Filter active
        using FACT1 = Field<_FA1R, 1, 1>; // Filter active
        using FACT2 = Field<_FA1R, 2, 1>; // Filter active
        using FACT3 = Field<_FA1R, 3, 1>; // Filter active
        using FACT4 = Field<_FA1R, 4, 1>; // Filter active
        using FACT5 = Field<_FA1R, 5, 1>; // Filter active
        using FACT6 = Field<_FA1R, 6, 1>; // Filter active
        using FACT7 = Field<_FA1R, 7, 1>; // Filter active
        using FACT8 = Field<_FA1R, 8, 1>; // Filter active
        using FACT9 = Field<_FA1R, 9, 1>; // Filter active
        using FACT10 = Field<_FA1R, 10, 1>; // Filter active
        using FACT11 = Field<_FA1R, 11, 1>; // Filter active
        using FACT12 = Field<_FA1R, 12, 1>; // Filter active
        using FACT13 = Field<_FA1R, 13, 1>; // Filter active
        using FACT14 = Field<_FA1R, 14, 1>; // Filter active
        using FACT15 = Field<_FA1R, 15, 1>; // Filter active
        using FACT16 = Field<_FA1R, 16, 1>; // Filter active
        using FACT17 = Field<_FA1R, 17, 1>; // Filter active
        using FACT18 = Field<_FA1R, 18, 1>; // Filter active
        using FACT19 = Field<_FA1R, 19, 1>; // Filter active
        using FACT20 = Field<_FA1R, 20, 1>; // Filter active
        using FACT21 = Field<_FA1R, 21, 1>; // Filter active
        using FACT22 = Field<_FA1R, 22, 1>; // Filter active
        using FACT23 = Field<_FA1R, 23, 1>; // Filter active
        using FACT24 = Field<_FA1R, 24, 1>; // Filter active
        using FACT25 = Field<_FA1R, 25, 1>; // Filter active
        using FACT26 = Field<_FA1R, 26, 1>; // Filter active
        using FACT27 = Field<_FA1R, 27, 1>; // Filter active
    };

    // Filter bank 0 register 1
    struct _F0R1 : Register<CAN1_BASE + 0x240, ReadWrite, _F0R1> {
        using FB0 = Field<_F0R1, 0, 1>; // Filter bits
        using FB1 = Field<_F0R1, 1, 1>; // Filter bits
        using FB2 = Field<_F0R1, 2, 1>; // Filter bits
        using FB3 = Field<_F0R1, 3, 1>; // Filter bits
        using FB4 = Field<_F0R1, 4, 1>; // Filter bits
        using FB5 = Field<_F0R1, 5, 1>; // Filter bits
        using FB6 = Field<_F0R1, 6, 1>; // Filter bits
        using FB7 = Field<_F0R1, 7, 1>; // Filter bits
        using FB8 = Field<_F0R1, 8, 1>; // Filter bits
        using FB9 = Field<_F0R1, 9, 1>; // Filter bits
        using FB10 = Field<_F0R1, 10, 1>; // Filter bits
        using FB11 = Field<_F0R1, 11, 1>; // Filter bits
        using FB12 = Field<_F0R1, 12, 1>; // Filter bits
        using FB13 = Field<_F0R1, 13, 1>; // Filter bits
        using FB14 = Field<_F0R1, 14, 1>; // Filter bits
        using FB15 = Field<_F0R1, 15, 1>; // Filter bits
        using FB16 = Field<_F0R1, 16, 1>; // Filter bits
        using FB17 = Field<_F0R1, 17, 1>; // Filter bits
        using FB18 = Field<_F0R1, 18, 1>; // Filter bits
        using FB19 = Field<_F0R1, 19, 1>; // Filter bits
        using FB20 = Field<_F0R1, 20, 1>; // Filter bits
        using FB21 = Field<_F0R1, 21, 1>; // Filter bits
        using FB22 = Field<_F0R1, 22, 1>; // Filter bits
        using FB23 = Field<_F0R1, 23, 1>; // Filter bits
        using FB24 = Field<_F0R1, 24, 1>; // Filter bits
        using FB25 = Field<_F0R1, 25, 1>; // Filter bits
        using FB26 = Field<_F0R1, 26, 1>; // Filter bits
        using FB27 = Field<_F0R1, 27, 1>; // Filter bits
        using FB28 = Field<_F0R1, 28, 1>; // Filter bits
        using FB29 = Field<_F0R1, 29, 1>; // Filter bits
        using FB30 = Field<_F0R1, 30, 1>; // Filter bits
        using FB31 = Field<_F0R1, 31, 1>; // Filter bits
    };

    // Filter bank 0 register 2
    struct _F0R2 : Register<CAN1_BASE + 0x244, ReadWrite, _F0R2> {
        using FB0 = Field<_F0R2, 0, 1>; // Filter bits
        using FB1 = Field<_F0R2, 1, 1>; // Filter bits
        using FB2 = Field<_F0R2, 2, 1>; // Filter bits
        using FB3 = Field<_F0R2, 3, 1>; // Filter bits
        using FB4 = Field<_F0R2, 4, 1>; // Filter bits
        using FB5 = Field<_F0R2, 5, 1>; // Filter bits
        using FB6 = Field<_F0R2, 6, 1>; // Filter bits
        using FB7 = Field<_F0R2, 7, 1>; // Filter bits
        using FB8 = Field<_F0R2, 8, 1>; // Filter bits
        using FB9 = Field<_F0R2, 9, 1>; // Filter bits
        using FB10 = Field<_F0R2, 10, 1>; // Filter bits
        using FB11 = Field<_F0R2, 11, 1>; // Filter bits
        using FB12 = Field<_F0R2, 12, 1>; // Filter bits
        using FB13 = Field<_F0R2, 13, 1>; // Filter bits
        using FB14 = Field<_F0R2, 14, 1>; // Filter bits
        using FB15 = Field<_F0R2, 15, 1>; // Filter bits
        using FB16 = Field<_F0R2, 16, 1>; // Filter bits
        using FB17 = Field<_F0R2, 17, 1>; // Filter bits
        using FB18 = Field<_F0R2, 18, 1>; // Filter bits
        using FB19 = Field<_F0R2, 19, 1>; // Filter bits
        using FB20 = Field<_F0R2, 20, 1>; // Filter bits
        using FB21 = Field<_F0R2, 21, 1>; // Filter bits
        using FB22 = Field<_F0R2, 22, 1>; // Filter bits
        using FB23 = Field<_F0R2, 23, 1>; // Filter bits
        using FB24 = Field<_F0R2, 24, 1>; // Filter bits
        using FB25 = Field<_F0R2, 25, 1>; // Filter bits
        using FB26 = Field<_F0R2, 26, 1>; // Filter bits
        using FB27 = Field<_F0R2, 27, 1>; // Filter bits
        using FB28 = Field<_F0R2, 28, 1>; // Filter bits
        using FB29 = Field<_F0R2, 29, 1>; // Filter bits
        using FB30 = Field<_F0R2, 30, 1>; // Filter bits
        using FB31 = Field<_F0R2, 31, 1>; // Filter bits
    };

    // Filter bank 1 register 1
    struct _F1R1 : Register<CAN1_BASE + 0x248, ReadWrite, _F1R1> {
        using FB0 = Field<_F1R1, 0, 1>; // Filter bits
        using FB1 = Field<_F1R1, 1, 1>; // Filter bits
        using FB2 = Field<_F1R1, 2, 1>; // Filter bits
        using FB3 = Field<_F1R1, 3, 1>; // Filter bits
        using FB4 = Field<_F1R1, 4, 1>; // Filter bits
        using FB5 = Field<_F1R1, 5, 1>; // Filter bits
        using FB6 = Field<_F1R1, 6, 1>; // Filter bits
        using FB7 = Field<_F1R1, 7, 1>; // Filter bits
        using FB8 = Field<_F1R1, 8, 1>; // Filter bits
        using FB9 = Field<_F1R1, 9, 1>; // Filter bits
        using FB10 = Field<_F1R1, 10, 1>; // Filter bits
        using FB11 = Field<_F1R1, 11, 1>; // Filter bits
        using FB12 = Field<_F1R1, 12, 1>; // Filter bits
        using FB13 = Field<_F1R1, 13, 1>; // Filter bits
        using FB14 = Field<_F1R1, 14, 1>; // Filter bits
        using FB15 = Field<_F1R1, 15, 1>; // Filter bits
        using FB16 = Field<_F1R1, 16, 1>; // Filter bits
        using FB17 = Field<_F1R1, 17, 1>; // Filter bits
        using FB18 = Field<_F1R1, 18, 1>; // Filter bits
        using FB19 = Field<_F1R1, 19, 1>; // Filter bits
        using FB20 = Field<_F1R1, 20, 1>; // Filter bits
        using FB21 = Field<_F1R1, 21, 1>; // Filter bits
        using FB22 = Field<_F1R1, 22, 1>; // Filter bits
        using FB23 = Field<_F1R1, 23, 1>; // Filter bits
        using FB24 = Field<_F1R1, 24, 1>; // Filter bits
        using FB25 = Field<_F1R1, 25, 1>; // Filter bits
        using FB26 = Field<_F1R1, 26, 1>; // Filter bits
        using FB27 = Field<_F1R1, 27, 1>; // Filter bits
        using FB28 = Field<_F1R1, 28, 1>; // Filter bits
        using FB29 = Field<_F1R1, 29, 1>; // Filter bits
        using FB30 = Field<_F1R1, 30, 1>; // Filter bits
        using FB31 = Field<_F1R1, 31, 1>; // Filter bits
    };

    // Filter bank 1 register 2
    struct _F1R2 : Register<CAN1_BASE + 0x24C, ReadWrite, _F1R2> {
        using FB0 = Field<_F1R2, 0, 1>; // Filter bits
        using FB1 = Field<_F1R2, 1, 1>; // Filter bits
        using FB2 = Field<_F1R2, 2, 1>; // Filter bits
        using FB3 = Field<_F1R2, 3, 1>; // Filter bits
        using FB4 = Field<_F1R2, 4, 1>; // Filter bits
        using FB5 = Field<_F1R2, 5, 1>; // Filter bits
        using FB6 = Field<_F1R2, 6, 1>; // Filter bits
        using FB7 = Field<_F1R2, 7, 1>; // Filter bits
        using FB8 = Field<_F1R2, 8, 1>; // Filter bits
        using FB9 = Field<_F1R2, 9, 1>; // Filter bits
        using FB10 = Field<_F1R2, 10, 1>; // Filter bits
        using FB11 = Field<_F1R2, 11, 1>; // Filter bits
        using FB12 = Field<_F1R2, 12, 1>; // Filter bits
        using FB13 = Field<_F1R2, 13, 1>; // Filter bits
        using FB14 = Field<_F1R2, 14, 1>; // Filter bits
        using FB15 = Field<_F1R2, 15, 1>; // Filter bits
        using FB16 = Field<_F1R2, 16, 1>; // Filter bits
        using FB17 = Field<_F1R2, 17, 1>; // Filter bits
        using FB18 = Field<_F1R2, 18, 1>; // Filter bits
        using FB19 = Field<_F1R2, 19, 1>; // Filter bits
        using FB20 = Field<_F1R2, 20, 1>; // Filter bits
        using FB21 = Field<_F1R2, 21, 1>; // Filter bits
        using FB22 = Field<_F1R2, 22, 1>; // Filter bits
        using FB23 = Field<_F1R2, 23, 1>; // Filter bits
        using FB24 = Field<_F1R2, 24, 1>; // Filter bits
        using FB25 = Field<_F1R2, 25, 1>; // Filter bits
        using FB26 = Field<_F1R2, 26, 1>; // Filter bits
        using FB27 = Field<_F1R2, 27, 1>; // Filter bits
        using FB28 = Field<_F1R2, 28, 1>; // Filter bits
        using FB29 = Field<_F1R2, 29, 1>; // Filter bits
        using FB30 = Field<_F1R2, 30, 1>; // Filter bits
        using FB31 = Field<_F1R2, 31, 1>; // Filter bits
    };

    // Filter bank 2 register 1
    struct _F2R1 : Register<CAN1_BASE + 0x250, ReadWrite, _F2R1> {
        using FB0 = Field<_F2R1, 0, 1>; // Filter bits
        using FB1 = Field<_F2R1, 1, 1>; // Filter bits
        using FB2 = Field<_F2R1, 2, 1>; // Filter bits
        using FB3 = Field<_F2R1, 3, 1>; // Filter bits
        using FB4 = Field<_F2R1, 4, 1>; // Filter bits
        using FB5 = Field<_F2R1, 5, 1>; // Filter bits
        using FB6 = Field<_F2R1, 6, 1>; // Filter bits
        using FB7 = Field<_F2R1, 7, 1>; // Filter bits
        using FB8 = Field<_F2R1, 8, 1>; // Filter bits
        using FB9 = Field<_F2R1, 9, 1>; // Filter bits
        using FB10 = Field<_F2R1, 10, 1>; // Filter bits
        using FB11 = Field<_F2R1, 11, 1>; // Filter bits
        using FB12 = Field<_F2R1, 12, 1>; // Filter bits
        using FB13 = Field<_F2R1, 13, 1>; // Filter bits
        using FB14 = Field<_F2R1, 14, 1>; // Filter bits
        using FB15 = Field<_F2R1, 15, 1>; // Filter bits
        using FB16 = Field<_F2R1, 16, 1>; // Filter bits
        using FB17 = Field<_F2R1, 17, 1>; // Filter bits
        using FB18 = Field<_F2R1, 18, 1>; // Filter bits
        using FB19 = Field<_F2R1, 19, 1>; // Filter bits
        using FB20 = Field<_F2R1, 20, 1>; // Filter bits
        using FB21 = Field<_F2R1, 21, 1>; // Filter bits
        using FB22 = Field<_F2R1, 22, 1>; // Filter bits
        using FB23 = Field<_F2R1, 23, 1>; // Filter bits
        using FB24 = Field<_F2R1, 24, 1>; // Filter bits
        using FB25 = Field<_F2R1, 25, 1>; // Filter bits
        using FB26 = Field<_F2R1, 26, 1>; // Filter bits
        using FB27 = Field<_F2R1, 27, 1>; // Filter bits
        using FB28 = Field<_F2R1, 28, 1>; // Filter bits
        using FB29 = Field<_F2R1, 29, 1>; // Filter bits
        using FB30 = Field<_F2R1, 30, 1>; // Filter bits
        using FB31 = Field<_F2R1, 31, 1>; // Filter bits
    };

    // Filter bank 2 register 2
    struct _F2R2 : Register<CAN1_BASE + 0x254, ReadWrite, _F2R2> {
        using FB0 = Field<_F2R2, 0, 1>; // Filter bits
        using FB1 = Field<_F2R2, 1, 1>; // Filter bits
        using FB2 = Field<_F2R2, 2, 1>; // Filter bits
        using FB3 = Field<_F2R2, 3, 1>; // Filter bits
        using FB4 = Field<_F2R2, 4, 1>; // Filter bits
        using FB5 = Field<_F2R2, 5, 1>; // Filter bits
        using FB6 = Field<_F2R2, 6, 1>; // Filter bits
        using FB7 = Field<_F2R2, 7, 1>; // Filter bits
        using FB8 = Field<_F2R2, 8, 1>; // Filter bits
        using FB9 = Field<_F2R2, 9, 1>; // Filter bits
        using FB10 = Field<_F2R2, 10, 1>; // Filter bits
        using FB11 = Field<_F2R2, 11, 1>; // Filter bits
        using FB12 = Field<_F2R2, 12, 1>; // Filter bits
        using FB13 = Field<_F2R2, 13, 1>; // Filter bits
        using FB14 = Field<_F2R2, 14, 1>; // Filter bits
        using FB15 = Field<_F2R2, 15, 1>; // Filter bits
        using FB16 = Field<_F2R2, 16, 1>; // Filter bits
        using FB17 = Field<_F2R2, 17, 1>; // Filter bits
        using FB18 = Field<_F2R2, 18, 1>; // Filter bits
        using FB19 = Field<_F2R2, 19, 1>; // Filter bits
        using FB20 = Field<_F2R2, 20, 1>; // Filter bits
        using FB21 = Field<_F2R2, 21, 1>; // Filter bits
        using FB22 = Field<_F2R2, 22, 1>; // Filter bits
        using FB23 = Field<_F2R2, 23, 1>; // Filter bits
        using FB24 = Field<_F2R2, 24, 1>; // Filter bits
        using FB25 = Field<_F2R2, 25, 1>; // Filter bits
        using FB26 = Field<_F2R2, 26, 1>; // Filter bits
        using FB27 = Field<_F2R2, 27, 1>; // Filter bits
        using FB28 = Field<_F2R2, 28, 1>; // Filter bits
        using FB29 = Field<_F2R2, 29, 1>; // Filter bits
        using FB30 = Field<_F2R2, 30, 1>; // Filter bits
        using FB31 = Field<_F2R2, 31, 1>; // Filter bits
    };

    // Filter bank 3 register 1
    struct _F3R1 : Register<CAN1_BASE + 0x258, ReadWrite, _F3R1> {
        using FB0 = Field<_F3R1, 0, 1>; // Filter bits
        using FB1 = Field<_F3R1, 1, 1>; // Filter bits
        using FB2 = Field<_F3R1, 2, 1>; // Filter bits
        using FB3 = Field<_F3R1, 3, 1>; // Filter bits
        using FB4 = Field<_F3R1, 4, 1>; // Filter bits
        using FB5 = Field<_F3R1, 5, 1>; // Filter bits
        using FB6 = Field<_F3R1, 6, 1>; // Filter bits
        using FB7 = Field<_F3R1, 7, 1>; // Filter bits
        using FB8 = Field<_F3R1, 8, 1>; // Filter bits
        using FB9 = Field<_F3R1, 9, 1>; // Filter bits
        using FB10 = Field<_F3R1, 10, 1>; // Filter bits
        using FB11 = Field<_F3R1, 11, 1>; // Filter bits
        using FB12 = Field<_F3R1, 12, 1>; // Filter bits
        using FB13 = Field<_F3R1, 13, 1>; // Filter bits
        using FB14 = Field<_F3R1, 14, 1>; // Filter bits
        using FB15 = Field<_F3R1, 15, 1>; // Filter bits
        using FB16 = Field<_F3R1, 16, 1>; // Filter bits
        using FB17 = Field<_F3R1, 17, 1>; // Filter bits
        using FB18 = Field<_F3R1, 18, 1>; // Filter bits
        using FB19 = Field<_F3R1, 19, 1>; // Filter bits
        using FB20 = Field<_F3R1, 20, 1>; // Filter bits
        using FB21 = Field<_F3R1, 21, 1>; // Filter bits
        using FB22 = Field<_F3R1, 22, 1>; // Filter bits
        using FB23 = Field<_F3R1, 23, 1>; // Filter bits
        using FB24 = Field<_F3R1, 24, 1>; // Filter bits
        using FB25 = Field<_F3R1, 25, 1>; // Filter bits
        using FB26 = Field<_F3R1, 26, 1>; // Filter bits
        using FB27 = Field<_F3R1, 27, 1>; // Filter bits
        using FB28 = Field<_F3R1, 28, 1>; // Filter bits
        using FB29 = Field<_F3R1, 29, 1>; // Filter bits
        using FB30 = Field<_F3R1, 30, 1>; // Filter bits
        using FB31 = Field<_F3R1, 31, 1>; // Filter bits
    };

    // Filter bank 3 register 2
    struct _F3R2 : Register<CAN1_BASE + 0x25C, ReadWrite, _F3R2> {
        using FB0 = Field<_F3R2, 0, 1>; // Filter bits
        using FB1 = Field<_F3R2, 1, 1>; // Filter bits
        using FB2 = Field<_F3R2, 2, 1>; // Filter bits
        using FB3 = Field<_F3R2, 3, 1>; // Filter bits
        using FB4 = Field<_F3R2, 4, 1>; // Filter bits
        using FB5 = Field<_F3R2, 5, 1>; // Filter bits
        using FB6 = Field<_F3R2, 6, 1>; // Filter bits
        using FB7 = Field<_F3R2, 7, 1>; // Filter bits
        using FB8 = Field<_F3R2, 8, 1>; // Filter bits
        using FB9 = Field<_F3R2, 9, 1>; // Filter bits
        using FB10 = Field<_F3R2, 10, 1>; // Filter bits
        using FB11 = Field<_F3R2, 11, 1>; // Filter bits
        using FB12 = Field<_F3R2, 12, 1>; // Filter bits
        using FB13 = Field<_F3R2, 13, 1>; // Filter bits
        using FB14 = Field<_F3R2, 14, 1>; // Filter bits
        using FB15 = Field<_F3R2, 15, 1>; // Filter bits
        using FB16 = Field<_F3R2, 16, 1>; // Filter bits
        using FB17 = Field<_F3R2, 17, 1>; // Filter bits
        using FB18 = Field<_F3R2, 18, 1>; // Filter bits
        using FB19 = Field<_F3R2, 19, 1>; // Filter bits
        using FB20 = Field<_F3R2, 20, 1>; // Filter bits
        using FB21 = Field<_F3R2, 21, 1>; // Filter bits
        using FB22 = Field<_F3R2, 22, 1>; // Filter bits
        using FB23 = Field<_F3R2, 23, 1>; // Filter bits
        using FB24 = Field<_F3R2, 24, 1>; // Filter bits
        using FB25 = Field<_F3R2, 25, 1>; // Filter bits
        using FB26 = Field<_F3R2, 26, 1>; // Filter bits
        using FB27 = Field<_F3R2, 27, 1>; // Filter bits
        using FB28 = Field<_F3R2, 28, 1>; // Filter bits
        using FB29 = Field<_F3R2, 29, 1>; // Filter bits
        using FB30 = Field<_F3R2, 30, 1>; // Filter bits
        using FB31 = Field<_F3R2, 31, 1>; // Filter bits
    };

    // Filter bank 4 register 1
    struct _F4R1 : Register<CAN1_BASE + 0x260, ReadWrite, _F4R1> {
        using FB0 = Field<_F4R1, 0, 1>; // Filter bits
        using FB1 = Field<_F4R1, 1, 1>; // Filter bits
        using FB2 = Field<_F4R1, 2, 1>; // Filter bits
        using FB3 = Field<_F4R1, 3, 1>; // Filter bits
        using FB4 = Field<_F4R1, 4, 1>; // Filter bits
        using FB5 = Field<_F4R1, 5, 1>; // Filter bits
        using FB6 = Field<_F4R1, 6, 1>; // Filter bits
        using FB7 = Field<_F4R1, 7, 1>; // Filter bits
        using FB8 = Field<_F4R1, 8, 1>; // Filter bits
        using FB9 = Field<_F4R1, 9, 1>; // Filter bits
        using FB10 = Field<_F4R1, 10, 1>; // Filter bits
        using FB11 = Field<_F4R1, 11, 1>; // Filter bits
        using FB12 = Field<_F4R1, 12, 1>; // Filter bits
        using FB13 = Field<_F4R1, 13, 1>; // Filter bits
        using FB14 = Field<_F4R1, 14, 1>; // Filter bits
        using FB15 = Field<_F4R1, 15, 1>; // Filter bits
        using FB16 = Field<_F4R1, 16, 1>; // Filter bits
        using FB17 = Field<_F4R1, 17, 1>; // Filter bits
        using FB18 = Field<_F4R1, 18, 1>; // Filter bits
        using FB19 = Field<_F4R1, 19, 1>; // Filter bits
        using FB20 = Field<_F4R1, 20, 1>; // Filter bits
        using FB21 = Field<_F4R1, 21, 1>; // Filter bits
        using FB22 = Field<_F4R1, 22, 1>; // Filter bits
        using FB23 = Field<_F4R1, 23, 1>; // Filter bits
        using FB24 = Field<_F4R1, 24, 1>; // Filter bits
        using FB25 = Field<_F4R1, 25, 1>; // Filter bits
        using FB26 = Field<_F4R1, 26, 1>; // Filter bits
        using FB27 = Field<_F4R1, 27, 1>; // Filter bits
        using FB28 = Field<_F4R1, 28, 1>; // Filter bits
        using FB29 = Field<_F4R1, 29, 1>; // Filter bits
        using FB30 = Field<_F4R1, 30, 1>; // Filter bits
        using FB31 = Field<_F4R1, 31, 1>; // Filter bits
    };

    // Filter bank 4 register 2
    struct _F4R2 : Register<CAN1_BASE + 0x264, ReadWrite, _F4R2> {
        using FB0 = Field<_F4R2, 0, 1>; // Filter bits
        using FB1 = Field<_F4R2, 1, 1>; // Filter bits
        using FB2 = Field<_F4R2, 2, 1>; // Filter bits
        using FB3 = Field<_F4R2, 3, 1>; // Filter bits
        using FB4 = Field<_F4R2, 4, 1>; // Filter bits
        using FB5 = Field<_F4R2, 5, 1>; // Filter bits
        using FB6 = Field<_F4R2, 6, 1>; // Filter bits
        using FB7 = Field<_F4R2, 7, 1>; // Filter bits
        using FB8 = Field<_F4R2, 8, 1>; // Filter bits
        using FB9 = Field<_F4R2, 9, 1>; // Filter bits
        using FB10 = Field<_F4R2, 10, 1>; // Filter bits
        using FB11 = Field<_F4R2, 11, 1>; // Filter bits
        using FB12 = Field<_F4R2, 12, 1>; // Filter bits
        using FB13 = Field<_F4R2, 13, 1>; // Filter bits
        using FB14 = Field<_F4R2, 14, 1>; // Filter bits
        using FB15 = Field<_F4R2, 15, 1>; // Filter bits
        using FB16 = Field<_F4R2, 16, 1>; // Filter bits
        using FB17 = Field<_F4R2, 17, 1>; // Filter bits
        using FB18 = Field<_F4R2, 18, 1>; // Filter bits
        using FB19 = Field<_F4R2, 19, 1>; // Filter bits
        using FB20 = Field<_F4R2, 20, 1>; // Filter bits
        using FB21 = Field<_F4R2, 21, 1>; // Filter bits
        using FB22 = Field<_F4R2, 22, 1>; // Filter bits
        using FB23 = Field<_F4R2, 23, 1>; // Filter bits
        using FB24 = Field<_F4R2, 24, 1>; // Filter bits
        using FB25 = Field<_F4R2, 25, 1>; // Filter bits
        using FB26 = Field<_F4R2, 26, 1>; // Filter bits
        using FB27 = Field<_F4R2, 27, 1>; // Filter bits
        using FB28 = Field<_F4R2, 28, 1>; // Filter bits
        using FB29 = Field<_F4R2, 29, 1>; // Filter bits
        using FB30 = Field<_F4R2, 30, 1>; // Filter bits
        using FB31 = Field<_F4R2, 31, 1>; // Filter bits
    };

    // Filter bank 5 register 1
    struct _F5R1 : Register<CAN1_BASE + 0x268, ReadWrite, _F5R1> {
        using FB0 = Field<_F5R1, 0, 1>; // Filter bits
        using FB1 = Field<_F5R1, 1, 1>; // Filter bits
        using FB2 = Field<_F5R1, 2, 1>; // Filter bits
        using FB3 = Field<_F5R1, 3, 1>; // Filter bits
        using FB4 = Field<_F5R1, 4, 1>; // Filter bits
        using FB5 = Field<_F5R1, 5, 1>; // Filter bits
        using FB6 = Field<_F5R1, 6, 1>; // Filter bits
        using FB7 = Field<_F5R1, 7, 1>; // Filter bits
        using FB8 = Field<_F5R1, 8, 1>; // Filter bits
        using FB9 = Field<_F5R1, 9, 1>; // Filter bits
        using FB10 = Field<_F5R1, 10, 1>; // Filter bits
        using FB11 = Field<_F5R1, 11, 1>; // Filter bits
        using FB12 = Field<_F5R1, 12, 1>; // Filter bits
        using FB13 = Field<_F5R1, 13, 1>; // Filter bits
        using FB14 = Field<_F5R1, 14, 1>; // Filter bits
        using FB15 = Field<_F5R1, 15, 1>; // Filter bits
        using FB16 = Field<_F5R1, 16, 1>; // Filter bits
        using FB17 = Field<_F5R1, 17, 1>; // Filter bits
        using FB18 = Field<_F5R1, 18, 1>; // Filter bits
        using FB19 = Field<_F5R1, 19, 1>; // Filter bits
        using FB20 = Field<_F5R1, 20, 1>; // Filter bits
        using FB21 = Field<_F5R1, 21, 1>; // Filter bits
        using FB22 = Field<_F5R1, 22, 1>; // Filter bits
        using FB23 = Field<_F5R1, 23, 1>; // Filter bits
        using FB24 = Field<_F5R1, 24, 1>; // Filter bits
        using FB25 = Field<_F5R1, 25, 1>; // Filter bits
        using FB26 = Field<_F5R1, 26, 1>; // Filter bits
        using FB27 = Field<_F5R1, 27, 1>; // Filter bits
        using FB28 = Field<_F5R1, 28, 1>; // Filter bits
        using FB29 = Field<_F5R1, 29, 1>; // Filter bits
        using FB30 = Field<_F5R1, 30, 1>; // Filter bits
        using FB31 = Field<_F5R1, 31, 1>; // Filter bits
    };

    // Filter bank 5 register 2
    struct _F5R2 : Register<CAN1_BASE + 0x26C, ReadWrite, _F5R2> {
        using FB0 = Field<_F5R2, 0, 1>; // Filter bits
        using FB1 = Field<_F5R2, 1, 1>; // Filter bits
        using FB2 = Field<_F5R2, 2, 1>; // Filter bits
        using FB3 = Field<_F5R2, 3, 1>; // Filter bits
        using FB4 = Field<_F5R2, 4, 1>; // Filter bits
        using FB5 = Field<_F5R2, 5, 1>; // Filter bits
        using FB6 = Field<_F5R2, 6, 1>; // Filter bits
        using FB7 = Field<_F5R2, 7, 1>; // Filter bits
        using FB8 = Field<_F5R2, 8, 1>; // Filter bits
        using FB9 = Field<_F5R2, 9, 1>; // Filter bits
        using FB10 = Field<_F5R2, 10, 1>; // Filter bits
        using FB11 = Field<_F5R2, 11, 1>; // Filter bits
        using FB12 = Field<_F5R2, 12, 1>; // Filter bits
        using FB13 = Field<_F5R2, 13, 1>; // Filter bits
        using FB14 = Field<_F5R2, 14, 1>; // Filter bits
        using FB15 = Field<_F5R2, 15, 1>; // Filter bits
        using FB16 = Field<_F5R2, 16, 1>; // Filter bits
        using FB17 = Field<_F5R2, 17, 1>; // Filter bits
        using FB18 = Field<_F5R2, 18, 1>; // Filter bits
        using FB19 = Field<_F5R2, 19, 1>; // Filter bits
        using FB20 = Field<_F5R2, 20, 1>; // Filter bits
        using FB21 = Field<_F5R2, 21, 1>; // Filter bits
        using FB22 = Field<_F5R2, 22, 1>; // Filter bits
        using FB23 = Field<_F5R2, 23, 1>; // Filter bits
        using FB24 = Field<_F5R2, 24, 1>; // Filter bits
        using FB25 = Field<_F5R2, 25, 1>; // Filter bits
        using FB26 = Field<_F5R2, 26, 1>; // Filter bits
        using FB27 = Field<_F5R2, 27, 1>; // Filter bits
        using FB28 = Field<_F5R2, 28, 1>; // Filter bits
        using FB29 = Field<_F5R2, 29, 1>; // Filter bits
        using FB30 = Field<_F5R2, 30, 1>; // Filter bits
        using FB31 = Field<_F5R2, 31, 1>; // Filter bits
    };

    // Filter bank 6 register 1
    struct _F6R1 : Register<CAN1_BASE + 0x270, ReadWrite, _F6R1> {
        using FB0 = Field<_F6R1, 0, 1>; // Filter bits
        using FB1 = Field<_F6R1, 1, 1>; // Filter bits
        using FB2 = Field<_F6R1, 2, 1>; // Filter bits
        using FB3 = Field<_F6R1, 3, 1>; // Filter bits
        using FB4 = Field<_F6R1, 4, 1>; // Filter bits
        using FB5 = Field<_F6R1, 5, 1>; // Filter bits
        using FB6 = Field<_F6R1, 6, 1>; // Filter bits
        using FB7 = Field<_F6R1, 7, 1>; // Filter bits
        using FB8 = Field<_F6R1, 8, 1>; // Filter bits
        using FB9 = Field<_F6R1, 9, 1>; // Filter bits
        using FB10 = Field<_F6R1, 10, 1>; // Filter bits
        using FB11 = Field<_F6R1, 11, 1>; // Filter bits
        using FB12 = Field<_F6R1, 12, 1>; // Filter bits
        using FB13 = Field<_F6R1, 13, 1>; // Filter bits
        using FB14 = Field<_F6R1, 14, 1>; // Filter bits
        using FB15 = Field<_F6R1, 15, 1>; // Filter bits
        using FB16 = Field<_F6R1, 16, 1>; // Filter bits
        using FB17 = Field<_F6R1, 17, 1>; // Filter bits
        using FB18 = Field<_F6R1, 18, 1>; // Filter bits
        using FB19 = Field<_F6R1, 19, 1>; // Filter bits
        using FB20 = Field<_F6R1, 20, 1>; // Filter bits
        using FB21 = Field<_F6R1, 21, 1>; // Filter bits
        using FB22 = Field<_F6R1, 22, 1>; // Filter bits
        using FB23 = Field<_F6R1, 23, 1>; // Filter bits
        using FB24 = Field<_F6R1, 24, 1>; // Filter bits
        using FB25 = Field<_F6R1, 25, 1>; // Filter bits
        using FB26 = Field<_F6R1, 26, 1>; // Filter bits
        using FB27 = Field<_F6R1, 27, 1>; // Filter bits
        using FB28 = Field<_F6R1, 28, 1>; // Filter bits
        using FB29 = Field<_F6R1, 29, 1>; // Filter bits
        using FB30 = Field<_F6R1, 30, 1>; // Filter bits
        using FB31 = Field<_F6R1, 31, 1>; // Filter bits
    };

    // Filter bank 6 register 2
    struct _F6R2 : Register<CAN1_BASE + 0x274, ReadWrite, _F6R2> {
        using FB0 = Field<_F6R2, 0, 1>; // Filter bits
        using FB1 = Field<_F6R2, 1, 1>; // Filter bits
        using FB2 = Field<_F6R2, 2, 1>; // Filter bits
        using FB3 = Field<_F6R2, 3, 1>; // Filter bits
        using FB4 = Field<_F6R2, 4, 1>; // Filter bits
        using FB5 = Field<_F6R2, 5, 1>; // Filter bits
        using FB6 = Field<_F6R2, 6, 1>; // Filter bits
        using FB7 = Field<_F6R2, 7, 1>; // Filter bits
        using FB8 = Field<_F6R2, 8, 1>; // Filter bits
        using FB9 = Field<_F6R2, 9, 1>; // Filter bits
        using FB10 = Field<_F6R2, 10, 1>; // Filter bits
        using FB11 = Field<_F6R2, 11, 1>; // Filter bits
        using FB12 = Field<_F6R2, 12, 1>; // Filter bits
        using FB13 = Field<_F6R2, 13, 1>; // Filter bits
        using FB14 = Field<_F6R2, 14, 1>; // Filter bits
        using FB15 = Field<_F6R2, 15, 1>; // Filter bits
        using FB16 = Field<_F6R2, 16, 1>; // Filter bits
        using FB17 = Field<_F6R2, 17, 1>; // Filter bits
        using FB18 = Field<_F6R2, 18, 1>; // Filter bits
        using FB19 = Field<_F6R2, 19, 1>; // Filter bits
        using FB20 = Field<_F6R2, 20, 1>; // Filter bits
        using FB21 = Field<_F6R2, 21, 1>; // Filter bits
        using FB22 = Field<_F6R2, 22, 1>; // Filter bits
        using FB23 = Field<_F6R2, 23, 1>; // Filter bits
        using FB24 = Field<_F6R2, 24, 1>; // Filter bits
        using FB25 = Field<_F6R2, 25, 1>; // Filter bits
        using FB26 = Field<_F6R2, 26, 1>; // Filter bits
        using FB27 = Field<_F6R2, 27, 1>; // Filter bits
        using FB28 = Field<_F6R2, 28, 1>; // Filter bits
        using FB29 = Field<_F6R2, 29, 1>; // Filter bits
        using FB30 = Field<_F6R2, 30, 1>; // Filter bits
        using FB31 = Field<_F6R2, 31, 1>; // Filter bits
    };

    // Filter bank 7 register 1
    struct _F7R1 : Register<CAN1_BASE + 0x278, ReadWrite, _F7R1> {
        using FB0 = Field<_F7R1, 0, 1>; // Filter bits
        using FB1 = Field<_F7R1, 1, 1>; // Filter bits
        using FB2 = Field<_F7R1, 2, 1>; // Filter bits
        using FB3 = Field<_F7R1, 3, 1>; // Filter bits
        using FB4 = Field<_F7R1, 4, 1>; // Filter bits
        using FB5 = Field<_F7R1, 5, 1>; // Filter bits
        using FB6 = Field<_F7R1, 6, 1>; // Filter bits
        using FB7 = Field<_F7R1, 7, 1>; // Filter bits
        using FB8 = Field<_F7R1, 8, 1>; // Filter bits
        using FB9 = Field<_F7R1, 9, 1>; // Filter bits
        using FB10 = Field<_F7R1, 10, 1>; // Filter bits
        using FB11 = Field<_F7R1, 11, 1>; // Filter bits
        using FB12 = Field<_F7R1, 12, 1>; // Filter bits
        using FB13 = Field<_F7R1, 13, 1>; // Filter bits
        using FB14 = Field<_F7R1, 14, 1>; // Filter bits
        using FB15 = Field<_F7R1, 15, 1>; // Filter bits
        using FB16 = Field<_F7R1, 16, 1>; // Filter bits
        using FB17 = Field<_F7R1, 17, 1>; // Filter bits
        using FB18 = Field<_F7R1, 18, 1>; // Filter bits
        using FB19 = Field<_F7R1, 19, 1>; // Filter bits
        using FB20 = Field<_F7R1, 20, 1>; // Filter bits
        using FB21 = Field<_F7R1, 21, 1>; // Filter bits
        using FB22 = Field<_F7R1, 22, 1>; // Filter bits
        using FB23 = Field<_F7R1, 23, 1>; // Filter bits
        using FB24 = Field<_F7R1, 24, 1>; // Filter bits
        using FB25 = Field<_F7R1, 25, 1>; // Filter bits
        using FB26 = Field<_F7R1, 26, 1>; // Filter bits
        using FB27 = Field<_F7R1, 27, 1>; // Filter bits
        using FB28 = Field<_F7R1, 28, 1>; // Filter bits
        using FB29 = Field<_F7R1, 29, 1>; // Filter bits
        using FB30 = Field<_F7R1, 30, 1>; // Filter bits
        using FB31 = Field<_F7R1, 31, 1>; // Filter bits
    };

    // Filter bank 7 register 2
    struct _F7R2 : Register<CAN1_BASE + 0x27C, ReadWrite, _F7R2> {
        using FB0 = Field<_F7R2, 0, 1>; // Filter bits
        using FB1 = Field<_F7R2, 1, 1>; // Filter bits
        using FB2 = Field<_F7R2, 2, 1>; // Filter bits
        using FB3 = Field<_F7R2, 3, 1>; // Filter bits
        using FB4 = Field<_F7R2, 4, 1>; // Filter bits
        using FB5 = Field<_F7R2, 5, 1>; // Filter bits
        using FB6 = Field<_F7R2, 6, 1>; // Filter bits
        using FB7 = Field<_F7R2, 7, 1>; // Filter bits
        using FB8 = Field<_F7R2, 8, 1>; // Filter bits
        using FB9 = Field<_F7R2, 9, 1>; // Filter bits
        using FB10 = Field<_F7R2, 10, 1>; // Filter bits
        using FB11 = Field<_F7R2, 11, 1>; // Filter bits
        using FB12 = Field<_F7R2, 12, 1>; // Filter bits
        using FB13 = Field<_F7R2, 13, 1>; // Filter bits
        using FB14 = Field<_F7R2, 14, 1>; // Filter bits
        using FB15 = Field<_F7R2, 15, 1>; // Filter bits
        using FB16 = Field<_F7R2, 16, 1>; // Filter bits
        using FB17 = Field<_F7R2, 17, 1>; // Filter bits
        using FB18 = Field<_F7R2, 18, 1>; // Filter bits
        using FB19 = Field<_F7R2, 19, 1>; // Filter bits
        using FB20 = Field<_F7R2, 20, 1>; // Filter bits
        using FB21 = Field<_F7R2, 21, 1>; // Filter bits
        using FB22 = Field<_F7R2, 22, 1>; // Filter bits
        using FB23 = Field<_F7R2, 23, 1>; // Filter bits
        using FB24 = Field<_F7R2, 24, 1>; // Filter bits
        using FB25 = Field<_F7R2, 25, 1>; // Filter bits
        using FB26 = Field<_F7R2, 26, 1>; // Filter bits
        using FB27 = Field<_F7R2, 27, 1>; // Filter bits
        using FB28 = Field<_F7R2, 28, 1>; // Filter bits
        using FB29 = Field<_F7R2, 29, 1>; // Filter bits
        using FB30 = Field<_F7R2, 30, 1>; // Filter bits
        using FB31 = Field<_F7R2, 31, 1>; // Filter bits
    };

    // Filter bank 8 register 1
    struct _F8R1 : Register<CAN1_BASE + 0x280, ReadWrite, _F8R1> {
        using FB0 = Field<_F8R1, 0, 1>; // Filter bits
        using FB1 = Field<_F8R1, 1, 1>; // Filter bits
        using FB2 = Field<_F8R1, 2, 1>; // Filter bits
        using FB3 = Field<_F8R1, 3, 1>; // Filter bits
        using FB4 = Field<_F8R1, 4, 1>; // Filter bits
        using FB5 = Field<_F8R1, 5, 1>; // Filter bits
        using FB6 = Field<_F8R1, 6, 1>; // Filter bits
        using FB7 = Field<_F8R1, 7, 1>; // Filter bits
        using FB8 = Field<_F8R1, 8, 1>; // Filter bits
        using FB9 = Field<_F8R1, 9, 1>; // Filter bits
        using FB10 = Field<_F8R1, 10, 1>; // Filter bits
        using FB11 = Field<_F8R1, 11, 1>; // Filter bits
        using FB12 = Field<_F8R1, 12, 1>; // Filter bits
        using FB13 = Field<_F8R1, 13, 1>; // Filter bits
        using FB14 = Field<_F8R1, 14, 1>; // Filter bits
        using FB15 = Field<_F8R1, 15, 1>; // Filter bits
        using FB16 = Field<_F8R1, 16, 1>; // Filter bits
        using FB17 = Field<_F8R1, 17, 1>; // Filter bits
        using FB18 = Field<_F8R1, 18, 1>; // Filter bits
        using FB19 = Field<_F8R1, 19, 1>; // Filter bits
        using FB20 = Field<_F8R1, 20, 1>; // Filter bits
        using FB21 = Field<_F8R1, 21, 1>; // Filter bits
        using FB22 = Field<_F8R1, 22, 1>; // Filter bits
        using FB23 = Field<_F8R1, 23, 1>; // Filter bits
        using FB24 = Field<_F8R1, 24, 1>; // Filter bits
        using FB25 = Field<_F8R1, 25, 1>; // Filter bits
        using FB26 = Field<_F8R1, 26, 1>; // Filter bits
        using FB27 = Field<_F8R1, 27, 1>; // Filter bits
        using FB28 = Field<_F8R1, 28, 1>; // Filter bits
        using FB29 = Field<_F8R1, 29, 1>; // Filter bits
        using FB30 = Field<_F8R1, 30, 1>; // Filter bits
        using FB31 = Field<_F8R1, 31, 1>; // Filter bits
    };

    // Filter bank 8 register 2
    struct _F8R2 : Register<CAN1_BASE + 0x284, ReadWrite, _F8R2> {
        using FB0 = Field<_F8R2, 0, 1>; // Filter bits
        using FB1 = Field<_F8R2, 1, 1>; // Filter bits
        using FB2 = Field<_F8R2, 2, 1>; // Filter bits
        using FB3 = Field<_F8R2, 3, 1>; // Filter bits
        using FB4 = Field<_F8R2, 4, 1>; // Filter bits
        using FB5 = Field<_F8R2, 5, 1>; // Filter bits
        using FB6 = Field<_F8R2, 6, 1>; // Filter bits
        using FB7 = Field<_F8R2, 7, 1>; // Filter bits
        using FB8 = Field<_F8R2, 8, 1>; // Filter bits
        using FB9 = Field<_F8R2, 9, 1>; // Filter bits
        using FB10 = Field<_F8R2, 10, 1>; // Filter bits
        using FB11 = Field<_F8R2, 11, 1>; // Filter bits
        using FB12 = Field<_F8R2, 12, 1>; // Filter bits
        using FB13 = Field<_F8R2, 13, 1>; // Filter bits
        using FB14 = Field<_F8R2, 14, 1>; // Filter bits
        using FB15 = Field<_F8R2, 15, 1>; // Filter bits
        using FB16 = Field<_F8R2, 16, 1>; // Filter bits
        using FB17 = Field<_F8R2, 17, 1>; // Filter bits
        using FB18 = Field<_F8R2, 18, 1>; // Filter bits
        using FB19 = Field<_F8R2, 19, 1>; // Filter bits
        using FB20 = Field<_F8R2, 20, 1>; // Filter bits
        using FB21 = Field<_F8R2, 21, 1>; // Filter bits
        using FB22 = Field<_F8R2, 22, 1>; // Filter bits
        using FB23 = Field<_F8R2, 23, 1>; // Filter bits
        using FB24 = Field<_F8R2, 24, 1>; // Filter bits
        using FB25 = Field<_F8R2, 25, 1>; // Filter bits
        using FB26 = Field<_F8R2, 26, 1>; // Filter bits
        using FB27 = Field<_F8R2, 27, 1>; // Filter bits
        using FB28 = Field<_F8R2, 28, 1>; // Filter bits
        using FB29 = Field<_F8R2, 29, 1>; // Filter bits
        using FB30 = Field<_F8R2, 30, 1>; // Filter bits
        using FB31 = Field<_F8R2, 31, 1>; // Filter bits
    };

    // Filter bank 9 register 1
    struct _F9R1 : Register<CAN1_BASE + 0x288, ReadWrite, _F9R1> {
        using FB0 = Field<_F9R1, 0, 1>; // Filter bits
        using FB1 = Field<_F9R1, 1, 1>; // Filter bits
        using FB2 = Field<_F9R1, 2, 1>; // Filter bits
        using FB3 = Field<_F9R1, 3, 1>; // Filter bits
        using FB4 = Field<_F9R1, 4, 1>; // Filter bits
        using FB5 = Field<_F9R1, 5, 1>; // Filter bits
        using FB6 = Field<_F9R1, 6, 1>; // Filter bits
        using FB7 = Field<_F9R1, 7, 1>; // Filter bits
        using FB8 = Field<_F9R1, 8, 1>; // Filter bits
        using FB9 = Field<_F9R1, 9, 1>; // Filter bits
        using FB10 = Field<_F9R1, 10, 1>; // Filter bits
        using FB11 = Field<_F9R1, 11, 1>; // Filter bits
        using FB12 = Field<_F9R1, 12, 1>; // Filter bits
        using FB13 = Field<_F9R1, 13, 1>; // Filter bits
        using FB14 = Field<_F9R1, 14, 1>; // Filter bits
        using FB15 = Field<_F9R1, 15, 1>; // Filter bits
        using FB16 = Field<_F9R1, 16, 1>; // Filter bits
        using FB17 = Field<_F9R1, 17, 1>; // Filter bits
        using FB18 = Field<_F9R1, 18, 1>; // Filter bits
        using FB19 = Field<_F9R1, 19, 1>; // Filter bits
        using FB20 = Field<_F9R1, 20, 1>; // Filter bits
        using FB21 = Field<_F9R1, 21, 1>; // Filter bits
        using FB22 = Field<_F9R1, 22, 1>; // Filter bits
        using FB23 = Field<_F9R1, 23, 1>; // Filter bits
        using FB24 = Field<_F9R1, 24, 1>; // Filter bits
        using FB25 = Field<_F9R1, 25, 1>; // Filter bits
        using FB26 = Field<_F9R1, 26, 1>; // Filter bits
        using FB27 = Field<_F9R1, 27, 1>; // Filter bits
        using FB28 = Field<_F9R1, 28, 1>; // Filter bits
        using FB29 = Field<_F9R1, 29, 1>; // Filter bits
        using FB30 = Field<_F9R1, 30, 1>; // Filter bits
        using FB31 = Field<_F9R1, 31, 1>; // Filter bits
    };

    // Filter bank 9 register 2
    struct _F9R2 : Register<CAN1_BASE + 0x28C, ReadWrite, _F9R2> {
        using FB0 = Field<_F9R2, 0, 1>; // Filter bits
        using FB1 = Field<_F9R2, 1, 1>; // Filter bits
        using FB2 = Field<_F9R2, 2, 1>; // Filter bits
        using FB3 = Field<_F9R2, 3, 1>; // Filter bits
        using FB4 = Field<_F9R2, 4, 1>; // Filter bits
        using FB5 = Field<_F9R2, 5, 1>; // Filter bits
        using FB6 = Field<_F9R2, 6, 1>; // Filter bits
        using FB7 = Field<_F9R2, 7, 1>; // Filter bits
        using FB8 = Field<_F9R2, 8, 1>; // Filter bits
        using FB9 = Field<_F9R2, 9, 1>; // Filter bits
        using FB10 = Field<_F9R2, 10, 1>; // Filter bits
        using FB11 = Field<_F9R2, 11, 1>; // Filter bits
        using FB12 = Field<_F9R2, 12, 1>; // Filter bits
        using FB13 = Field<_F9R2, 13, 1>; // Filter bits
        using FB14 = Field<_F9R2, 14, 1>; // Filter bits
        using FB15 = Field<_F9R2, 15, 1>; // Filter bits
        using FB16 = Field<_F9R2, 16, 1>; // Filter bits
        using FB17 = Field<_F9R2, 17, 1>; // Filter bits
        using FB18 = Field<_F9R2, 18, 1>; // Filter bits
        using FB19 = Field<_F9R2, 19, 1>; // Filter bits
        using FB20 = Field<_F9R2, 20, 1>; // Filter bits
        using FB21 = Field<_F9R2, 21, 1>; // Filter bits
        using FB22 = Field<_F9R2, 22, 1>; // Filter bits
        using FB23 = Field<_F9R2, 23, 1>; // Filter bits
        using FB24 = Field<_F9R2, 24, 1>; // Filter bits
        using FB25 = Field<_F9R2, 25, 1>; // Filter bits
        using FB26 = Field<_F9R2, 26, 1>; // Filter bits
        using FB27 = Field<_F9R2, 27, 1>; // Filter bits
        using FB28 = Field<_F9R2, 28, 1>; // Filter bits
        using FB29 = Field<_F9R2, 29, 1>; // Filter bits
        using FB30 = Field<_F9R2, 30, 1>; // Filter bits
        using FB31 = Field<_F9R2, 31, 1>; // Filter bits
    };

    // Filter bank 10 register 1
    struct _F10R1 : Register<CAN1_BASE + 0x290, ReadWrite, _F10R1> {
        using FB0 = Field<_F10R1, 0, 1>; // Filter bits
        using FB1 = Field<_F10R1, 1, 1>; // Filter bits
        using FB2 = Field<_F10R1, 2, 1>; // Filter bits
        using FB3 = Field<_F10R1, 3, 1>; // Filter bits
        using FB4 = Field<_F10R1, 4, 1>; // Filter bits
        using FB5 = Field<_F10R1, 5, 1>; // Filter bits
        using FB6 = Field<_F10R1, 6, 1>; // Filter bits
        using FB7 = Field<_F10R1, 7, 1>; // Filter bits
        using FB8 = Field<_F10R1, 8, 1>; // Filter bits
        using FB9 = Field<_F10R1, 9, 1>; // Filter bits
        using FB10 = Field<_F10R1, 10, 1>; // Filter bits
        using FB11 = Field<_F10R1, 11, 1>; // Filter bits
        using FB12 = Field<_F10R1, 12, 1>; // Filter bits
        using FB13 = Field<_F10R1, 13, 1>; // Filter bits
        using FB14 = Field<_F10R1, 14, 1>; // Filter bits
        using FB15 = Field<_F10R1, 15, 1>; // Filter bits
        using FB16 = Field<_F10R1, 16, 1>; // Filter bits
        using FB17 = Field<_F10R1, 17, 1>; // Filter bits
        using FB18 = Field<_F10R1, 18, 1>; // Filter bits
        using FB19 = Field<_F10R1, 19, 1>; // Filter bits
        using FB20 = Field<_F10R1, 20, 1>; // Filter bits
        using FB21 = Field<_F10R1, 21, 1>; // Filter bits
        using FB22 = Field<_F10R1, 22, 1>; // Filter bits
        using FB23 = Field<_F10R1, 23, 1>; // Filter bits
        using FB24 = Field<_F10R1, 24, 1>; // Filter bits
        using FB25 = Field<_F10R1, 25, 1>; // Filter bits
        using FB26 = Field<_F10R1, 26, 1>; // Filter bits
        using FB27 = Field<_F10R1, 27, 1>; // Filter bits
        using FB28 = Field<_F10R1, 28, 1>; // Filter bits
        using FB29 = Field<_F10R1, 29, 1>; // Filter bits
        using FB30 = Field<_F10R1, 30, 1>; // Filter bits
        using FB31 = Field<_F10R1, 31, 1>; // Filter bits
    };

    // Filter bank 10 register 2
    struct _F10R2 : Register<CAN1_BASE + 0x294, ReadWrite, _F10R2> {
        using FB0 = Field<_F10R2, 0, 1>; // Filter bits
        using FB1 = Field<_F10R2, 1, 1>; // Filter bits
        using FB2 = Field<_F10R2, 2, 1>; // Filter bits
        using FB3 = Field<_F10R2, 3, 1>; // Filter bits
        using FB4 = Field<_F10R2, 4, 1>; // Filter bits
        using FB5 = Field<_F10R2, 5, 1>; // Filter bits
        using FB6 = Field<_F10R2, 6, 1>; // Filter bits
        using FB7 = Field<_F10R2, 7, 1>; // Filter bits
        using FB8 = Field<_F10R2, 8, 1>; // Filter bits
        using FB9 = Field<_F10R2, 9, 1>; // Filter bits
        using FB10 = Field<_F10R2, 10, 1>; // Filter bits
        using FB11 = Field<_F10R2, 11, 1>; // Filter bits
        using FB12 = Field<_F10R2, 12, 1>; // Filter bits
        using FB13 = Field<_F10R2, 13, 1>; // Filter bits
        using FB14 = Field<_F10R2, 14, 1>; // Filter bits
        using FB15 = Field<_F10R2, 15, 1>; // Filter bits
        using FB16 = Field<_F10R2, 16, 1>; // Filter bits
        using FB17 = Field<_F10R2, 17, 1>; // Filter bits
        using FB18 = Field<_F10R2, 18, 1>; // Filter bits
        using FB19 = Field<_F10R2, 19, 1>; // Filter bits
        using FB20 = Field<_F10R2, 20, 1>; // Filter bits
        using FB21 = Field<_F10R2, 21, 1>; // Filter bits
        using FB22 = Field<_F10R2, 22, 1>; // Filter bits
        using FB23 = Field<_F10R2, 23, 1>; // Filter bits
        using FB24 = Field<_F10R2, 24, 1>; // Filter bits
        using FB25 = Field<_F10R2, 25, 1>; // Filter bits
        using FB26 = Field<_F10R2, 26, 1>; // Filter bits
        using FB27 = Field<_F10R2, 27, 1>; // Filter bits
        using FB28 = Field<_F10R2, 28, 1>; // Filter bits
        using FB29 = Field<_F10R2, 29, 1>; // Filter bits
        using FB30 = Field<_F10R2, 30, 1>; // Filter bits
        using FB31 = Field<_F10R2, 31, 1>; // Filter bits
    };

    // Filter bank 11 register 1
    struct _F11R1 : Register<CAN1_BASE + 0x298, ReadWrite, _F11R1> {
        using FB0 = Field<_F11R1, 0, 1>; // Filter bits
        using FB1 = Field<_F11R1, 1, 1>; // Filter bits
        using FB2 = Field<_F11R1, 2, 1>; // Filter bits
        using FB3 = Field<_F11R1, 3, 1>; // Filter bits
        using FB4 = Field<_F11R1, 4, 1>; // Filter bits
        using FB5 = Field<_F11R1, 5, 1>; // Filter bits
        using FB6 = Field<_F11R1, 6, 1>; // Filter bits
        using FB7 = Field<_F11R1, 7, 1>; // Filter bits
        using FB8 = Field<_F11R1, 8, 1>; // Filter bits
        using FB9 = Field<_F11R1, 9, 1>; // Filter bits
        using FB10 = Field<_F11R1, 10, 1>; // Filter bits
        using FB11 = Field<_F11R1, 11, 1>; // Filter bits
        using FB12 = Field<_F11R1, 12, 1>; // Filter bits
        using FB13 = Field<_F11R1, 13, 1>; // Filter bits
        using FB14 = Field<_F11R1, 14, 1>; // Filter bits
        using FB15 = Field<_F11R1, 15, 1>; // Filter bits
        using FB16 = Field<_F11R1, 16, 1>; // Filter bits
        using FB17 = Field<_F11R1, 17, 1>; // Filter bits
        using FB18 = Field<_F11R1, 18, 1>; // Filter bits
        using FB19 = Field<_F11R1, 19, 1>; // Filter bits
        using FB20 = Field<_F11R1, 20, 1>; // Filter bits
        using FB21 = Field<_F11R1, 21, 1>; // Filter bits
        using FB22 = Field<_F11R1, 22, 1>; // Filter bits
        using FB23 = Field<_F11R1, 23, 1>; // Filter bits
        using FB24 = Field<_F11R1, 24, 1>; // Filter bits
        using FB25 = Field<_F11R1, 25, 1>; // Filter bits
        using FB26 = Field<_F11R1, 26, 1>; // Filter bits
        using FB27 = Field<_F11R1, 27, 1>; // Filter bits
        using FB28 = Field<_F11R1, 28, 1>; // Filter bits
        using FB29 = Field<_F11R1, 29, 1>; // Filter bits
        using FB30 = Field<_F11R1, 30, 1>; // Filter bits
        using FB31 = Field<_F11R1, 31, 1>; // Filter bits
    };

    // Filter bank 11 register 2
    struct _F11R2 : Register<CAN1_BASE + 0x29C, ReadWrite, _F11R2> {
        using FB0 = Field<_F11R2, 0, 1>; // Filter bits
        using FB1 = Field<_F11R2, 1, 1>; // Filter bits
        using FB2 = Field<_F11R2, 2, 1>; // Filter bits
        using FB3 = Field<_F11R2, 3, 1>; // Filter bits
        using FB4 = Field<_F11R2, 4, 1>; // Filter bits
        using FB5 = Field<_F11R2, 5, 1>; // Filter bits
        using FB6 = Field<_F11R2, 6, 1>; // Filter bits
        using FB7 = Field<_F11R2, 7, 1>; // Filter bits
        using FB8 = Field<_F11R2, 8, 1>; // Filter bits
        using FB9 = Field<_F11R2, 9, 1>; // Filter bits
        using FB10 = Field<_F11R2, 10, 1>; // Filter bits
        using FB11 = Field<_F11R2, 11, 1>; // Filter bits
        using FB12 = Field<_F11R2, 12, 1>; // Filter bits
        using FB13 = Field<_F11R2, 13, 1>; // Filter bits
        using FB14 = Field<_F11R2, 14, 1>; // Filter bits
        using FB15 = Field<_F11R2, 15, 1>; // Filter bits
        using FB16 = Field<_F11R2, 16, 1>; // Filter bits
        using FB17 = Field<_F11R2, 17, 1>; // Filter bits
        using FB18 = Field<_F11R2, 18, 1>; // Filter bits
        using FB19 = Field<_F11R2, 19, 1>; // Filter bits
        using FB20 = Field<_F11R2, 20, 1>; // Filter bits
        using FB21 = Field<_F11R2, 21, 1>; // Filter bits
        using FB22 = Field<_F11R2, 22, 1>; // Filter bits
        using FB23 = Field<_F11R2, 23, 1>; // Filter bits
        using FB24 = Field<_F11R2, 24, 1>; // Filter bits
        using FB25 = Field<_F11R2, 25, 1>; // Filter bits
        using FB26 = Field<_F11R2, 26, 1>; // Filter bits
        using FB27 = Field<_F11R2, 27, 1>; // Filter bits
        using FB28 = Field<_F11R2, 28, 1>; // Filter bits
        using FB29 = Field<_F11R2, 29, 1>; // Filter bits
        using FB30 = Field<_F11R2, 30, 1>; // Filter bits
        using FB31 = Field<_F11R2, 31, 1>; // Filter bits
    };

    // Filter bank 4 register 1
    struct _F12R1 : Register<CAN1_BASE + 0x2A0, ReadWrite, _F12R1> {
        using FB0 = Field<_F12R1, 0, 1>; // Filter bits
        using FB1 = Field<_F12R1, 1, 1>; // Filter bits
        using FB2 = Field<_F12R1, 2, 1>; // Filter bits
        using FB3 = Field<_F12R1, 3, 1>; // Filter bits
        using FB4 = Field<_F12R1, 4, 1>; // Filter bits
        using FB5 = Field<_F12R1, 5, 1>; // Filter bits
        using FB6 = Field<_F12R1, 6, 1>; // Filter bits
        using FB7 = Field<_F12R1, 7, 1>; // Filter bits
        using FB8 = Field<_F12R1, 8, 1>; // Filter bits
        using FB9 = Field<_F12R1, 9, 1>; // Filter bits
        using FB10 = Field<_F12R1, 10, 1>; // Filter bits
        using FB11 = Field<_F12R1, 11, 1>; // Filter bits
        using FB12 = Field<_F12R1, 12, 1>; // Filter bits
        using FB13 = Field<_F12R1, 13, 1>; // Filter bits
        using FB14 = Field<_F12R1, 14, 1>; // Filter bits
        using FB15 = Field<_F12R1, 15, 1>; // Filter bits
        using FB16 = Field<_F12R1, 16, 1>; // Filter bits
        using FB17 = Field<_F12R1, 17, 1>; // Filter bits
        using FB18 = Field<_F12R1, 18, 1>; // Filter bits
        using FB19 = Field<_F12R1, 19, 1>; // Filter bits
        using FB20 = Field<_F12R1, 20, 1>; // Filter bits
        using FB21 = Field<_F12R1, 21, 1>; // Filter bits
        using FB22 = Field<_F12R1, 22, 1>; // Filter bits
        using FB23 = Field<_F12R1, 23, 1>; // Filter bits
        using FB24 = Field<_F12R1, 24, 1>; // Filter bits
        using FB25 = Field<_F12R1, 25, 1>; // Filter bits
        using FB26 = Field<_F12R1, 26, 1>; // Filter bits
        using FB27 = Field<_F12R1, 27, 1>; // Filter bits
        using FB28 = Field<_F12R1, 28, 1>; // Filter bits
        using FB29 = Field<_F12R1, 29, 1>; // Filter bits
        using FB30 = Field<_F12R1, 30, 1>; // Filter bits
        using FB31 = Field<_F12R1, 31, 1>; // Filter bits
    };

    // Filter bank 12 register 2
    struct _F12R2 : Register<CAN1_BASE + 0x2A4, ReadWrite, _F12R2> {
        using FB0 = Field<_F12R2, 0, 1>; // Filter bits
        using FB1 = Field<_F12R2, 1, 1>; // Filter bits
        using FB2 = Field<_F12R2, 2, 1>; // Filter bits
        using FB3 = Field<_F12R2, 3, 1>; // Filter bits
        using FB4 = Field<_F12R2, 4, 1>; // Filter bits
        using FB5 = Field<_F12R2, 5, 1>; // Filter bits
        using FB6 = Field<_F12R2, 6, 1>; // Filter bits
        using FB7 = Field<_F12R2, 7, 1>; // Filter bits
        using FB8 = Field<_F12R2, 8, 1>; // Filter bits
        using FB9 = Field<_F12R2, 9, 1>; // Filter bits
        using FB10 = Field<_F12R2, 10, 1>; // Filter bits
        using FB11 = Field<_F12R2, 11, 1>; // Filter bits
        using FB12 = Field<_F12R2, 12, 1>; // Filter bits
        using FB13 = Field<_F12R2, 13, 1>; // Filter bits
        using FB14 = Field<_F12R2, 14, 1>; // Filter bits
        using FB15 = Field<_F12R2, 15, 1>; // Filter bits
        using FB16 = Field<_F12R2, 16, 1>; // Filter bits
        using FB17 = Field<_F12R2, 17, 1>; // Filter bits
        using FB18 = Field<_F12R2, 18, 1>; // Filter bits
        using FB19 = Field<_F12R2, 19, 1>; // Filter bits
        using FB20 = Field<_F12R2, 20, 1>; // Filter bits
        using FB21 = Field<_F12R2, 21, 1>; // Filter bits
        using FB22 = Field<_F12R2, 22, 1>; // Filter bits
        using FB23 = Field<_F12R2, 23, 1>; // Filter bits
        using FB24 = Field<_F12R2, 24, 1>; // Filter bits
        using FB25 = Field<_F12R2, 25, 1>; // Filter bits
        using FB26 = Field<_F12R2, 26, 1>; // Filter bits
        using FB27 = Field<_F12R2, 27, 1>; // Filter bits
        using FB28 = Field<_F12R2, 28, 1>; // Filter bits
        using FB29 = Field<_F12R2, 29, 1>; // Filter bits
        using FB30 = Field<_F12R2, 30, 1>; // Filter bits
        using FB31 = Field<_F12R2, 31, 1>; // Filter bits
    };

    // Filter bank 13 register 1
    struct _F13R1 : Register<CAN1_BASE + 0x2A8, ReadWrite, _F13R1> {
        using FB0 = Field<_F13R1, 0, 1>; // Filter bits
        using FB1 = Field<_F13R1, 1, 1>; // Filter bits
        using FB2 = Field<_F13R1, 2, 1>; // Filter bits
        using FB3 = Field<_F13R1, 3, 1>; // Filter bits
        using FB4 = Field<_F13R1, 4, 1>; // Filter bits
        using FB5 = Field<_F13R1, 5, 1>; // Filter bits
        using FB6 = Field<_F13R1, 6, 1>; // Filter bits
        using FB7 = Field<_F13R1, 7, 1>; // Filter bits
        using FB8 = Field<_F13R1, 8, 1>; // Filter bits
        using FB9 = Field<_F13R1, 9, 1>; // Filter bits
        using FB10 = Field<_F13R1, 10, 1>; // Filter bits
        using FB11 = Field<_F13R1, 11, 1>; // Filter bits
        using FB12 = Field<_F13R1, 12, 1>; // Filter bits
        using FB13 = Field<_F13R1, 13, 1>; // Filter bits
        using FB14 = Field<_F13R1, 14, 1>; // Filter bits
        using FB15 = Field<_F13R1, 15, 1>; // Filter bits
        using FB16 = Field<_F13R1, 16, 1>; // Filter bits
        using FB17 = Field<_F13R1, 17, 1>; // Filter bits
        using FB18 = Field<_F13R1, 18, 1>; // Filter bits
        using FB19 = Field<_F13R1, 19, 1>; // Filter bits
        using FB20 = Field<_F13R1, 20, 1>; // Filter bits
        using FB21 = Field<_F13R1, 21, 1>; // Filter bits
        using FB22 = Field<_F13R1, 22, 1>; // Filter bits
        using FB23 = Field<_F13R1, 23, 1>; // Filter bits
        using FB24 = Field<_F13R1, 24, 1>; // Filter bits
        using FB25 = Field<_F13R1, 25, 1>; // Filter bits
        using FB26 = Field<_F13R1, 26, 1>; // Filter bits
        using FB27 = Field<_F13R1, 27, 1>; // Filter bits
        using FB28 = Field<_F13R1, 28, 1>; // Filter bits
        using FB29 = Field<_F13R1, 29, 1>; // Filter bits
        using FB30 = Field<_F13R1, 30, 1>; // Filter bits
        using FB31 = Field<_F13R1, 31, 1>; // Filter bits
    };

    // Filter bank 13 register 2
    struct _F13R2 : Register<CAN1_BASE + 0x2AC, ReadWrite, _F13R2> {
        using FB0 = Field<_F13R2, 0, 1>; // Filter bits
        using FB1 = Field<_F13R2, 1, 1>; // Filter bits
        using FB2 = Field<_F13R2, 2, 1>; // Filter bits
        using FB3 = Field<_F13R2, 3, 1>; // Filter bits
        using FB4 = Field<_F13R2, 4, 1>; // Filter bits
        using FB5 = Field<_F13R2, 5, 1>; // Filter bits
        using FB6 = Field<_F13R2, 6, 1>; // Filter bits
        using FB7 = Field<_F13R2, 7, 1>; // Filter bits
        using FB8 = Field<_F13R2, 8, 1>; // Filter bits
        using FB9 = Field<_F13R2, 9, 1>; // Filter bits
        using FB10 = Field<_F13R2, 10, 1>; // Filter bits
        using FB11 = Field<_F13R2, 11, 1>; // Filter bits
        using FB12 = Field<_F13R2, 12, 1>; // Filter bits
        using FB13 = Field<_F13R2, 13, 1>; // Filter bits
        using FB14 = Field<_F13R2, 14, 1>; // Filter bits
        using FB15 = Field<_F13R2, 15, 1>; // Filter bits
        using FB16 = Field<_F13R2, 16, 1>; // Filter bits
        using FB17 = Field<_F13R2, 17, 1>; // Filter bits
        using FB18 = Field<_F13R2, 18, 1>; // Filter bits
        using FB19 = Field<_F13R2, 19, 1>; // Filter bits
        using FB20 = Field<_F13R2, 20, 1>; // Filter bits
        using FB21 = Field<_F13R2, 21, 1>; // Filter bits
        using FB22 = Field<_F13R2, 22, 1>; // Filter bits
        using FB23 = Field<_F13R2, 23, 1>; // Filter bits
        using FB24 = Field<_F13R2, 24, 1>; // Filter bits
        using FB25 = Field<_F13R2, 25, 1>; // Filter bits
        using FB26 = Field<_F13R2, 26, 1>; // Filter bits
        using FB27 = Field<_F13R2, 27, 1>; // Filter bits
        using FB28 = Field<_F13R2, 28, 1>; // Filter bits
        using FB29 = Field<_F13R2, 29, 1>; // Filter bits
        using FB30 = Field<_F13R2, 30, 1>; // Filter bits
        using FB31 = Field<_F13R2, 31, 1>; // Filter bits
    };

    // Filter bank 14 register 1
    struct _F14R1 : Register<CAN1_BASE + 0x2B0, ReadWrite, _F14R1> {
        using FB0 = Field<_F14R1, 0, 1>; // Filter bits
        using FB1 = Field<_F14R1, 1, 1>; // Filter bits
        using FB2 = Field<_F14R1, 2, 1>; // Filter bits
        using FB3 = Field<_F14R1, 3, 1>; // Filter bits
        using FB4 = Field<_F14R1, 4, 1>; // Filter bits
        using FB5 = Field<_F14R1, 5, 1>; // Filter bits
        using FB6 = Field<_F14R1, 6, 1>; // Filter bits
        using FB7 = Field<_F14R1, 7, 1>; // Filter bits
        using FB8 = Field<_F14R1, 8, 1>; // Filter bits
        using FB9 = Field<_F14R1, 9, 1>; // Filter bits
        using FB10 = Field<_F14R1, 10, 1>; // Filter bits
        using FB11 = Field<_F14R1, 11, 1>; // Filter bits
        using FB12 = Field<_F14R1, 12, 1>; // Filter bits
        using FB13 = Field<_F14R1, 13, 1>; // Filter bits
        using FB14 = Field<_F14R1, 14, 1>; // Filter bits
        using FB15 = Field<_F14R1, 15, 1>; // Filter bits
        using FB16 = Field<_F14R1, 16, 1>; // Filter bits
        using FB17 = Field<_F14R1, 17, 1>; // Filter bits
        using FB18 = Field<_F14R1, 18, 1>; // Filter bits
        using FB19 = Field<_F14R1, 19, 1>; // Filter bits
        using FB20 = Field<_F14R1, 20, 1>; // Filter bits
        using FB21 = Field<_F14R1, 21, 1>; // Filter bits
        using FB22 = Field<_F14R1, 22, 1>; // Filter bits
        using FB23 = Field<_F14R1, 23, 1>; // Filter bits
        using FB24 = Field<_F14R1, 24, 1>; // Filter bits
        using FB25 = Field<_F14R1, 25, 1>; // Filter bits
        using FB26 = Field<_F14R1, 26, 1>; // Filter bits
        using FB27 = Field<_F14R1, 27, 1>; // Filter bits
        using FB28 = Field<_F14R1, 28, 1>; // Filter bits
        using FB29 = Field<_F14R1, 29, 1>; // Filter bits
        using FB30 = Field<_F14R1, 30, 1>; // Filter bits
        using FB31 = Field<_F14R1, 31, 1>; // Filter bits
    };

    // Filter bank 14 register 2
    struct _F14R2 : Register<CAN1_BASE + 0x2B4, ReadWrite, _F14R2> {
        using FB0 = Field<_F14R2, 0, 1>; // Filter bits
        using FB1 = Field<_F14R2, 1, 1>; // Filter bits
        using FB2 = Field<_F14R2, 2, 1>; // Filter bits
        using FB3 = Field<_F14R2, 3, 1>; // Filter bits
        using FB4 = Field<_F14R2, 4, 1>; // Filter bits
        using FB5 = Field<_F14R2, 5, 1>; // Filter bits
        using FB6 = Field<_F14R2, 6, 1>; // Filter bits
        using FB7 = Field<_F14R2, 7, 1>; // Filter bits
        using FB8 = Field<_F14R2, 8, 1>; // Filter bits
        using FB9 = Field<_F14R2, 9, 1>; // Filter bits
        using FB10 = Field<_F14R2, 10, 1>; // Filter bits
        using FB11 = Field<_F14R2, 11, 1>; // Filter bits
        using FB12 = Field<_F14R2, 12, 1>; // Filter bits
        using FB13 = Field<_F14R2, 13, 1>; // Filter bits
        using FB14 = Field<_F14R2, 14, 1>; // Filter bits
        using FB15 = Field<_F14R2, 15, 1>; // Filter bits
        using FB16 = Field<_F14R2, 16, 1>; // Filter bits
        using FB17 = Field<_F14R2, 17, 1>; // Filter bits
        using FB18 = Field<_F14R2, 18, 1>; // Filter bits
        using FB19 = Field<_F14R2, 19, 1>; // Filter bits
        using FB20 = Field<_F14R2, 20, 1>; // Filter bits
        using FB21 = Field<_F14R2, 21, 1>; // Filter bits
        using FB22 = Field<_F14R2, 22, 1>; // Filter bits
        using FB23 = Field<_F14R2, 23, 1>; // Filter bits
        using FB24 = Field<_F14R2, 24, 1>; // Filter bits
        using FB25 = Field<_F14R2, 25, 1>; // Filter bits
        using FB26 = Field<_F14R2, 26, 1>; // Filter bits
        using FB27 = Field<_F14R2, 27, 1>; // Filter bits
        using FB28 = Field<_F14R2, 28, 1>; // Filter bits
        using FB29 = Field<_F14R2, 29, 1>; // Filter bits
        using FB30 = Field<_F14R2, 30, 1>; // Filter bits
        using FB31 = Field<_F14R2, 31, 1>; // Filter bits
    };

    // Filter bank 15 register 1
    struct _F15R1 : Register<CAN1_BASE + 0x2B8, ReadWrite, _F15R1> {
        using FB0 = Field<_F15R1, 0, 1>; // Filter bits
        using FB1 = Field<_F15R1, 1, 1>; // Filter bits
        using FB2 = Field<_F15R1, 2, 1>; // Filter bits
        using FB3 = Field<_F15R1, 3, 1>; // Filter bits
        using FB4 = Field<_F15R1, 4, 1>; // Filter bits
        using FB5 = Field<_F15R1, 5, 1>; // Filter bits
        using FB6 = Field<_F15R1, 6, 1>; // Filter bits
        using FB7 = Field<_F15R1, 7, 1>; // Filter bits
        using FB8 = Field<_F15R1, 8, 1>; // Filter bits
        using FB9 = Field<_F15R1, 9, 1>; // Filter bits
        using FB10 = Field<_F15R1, 10, 1>; // Filter bits
        using FB11 = Field<_F15R1, 11, 1>; // Filter bits
        using FB12 = Field<_F15R1, 12, 1>; // Filter bits
        using FB13 = Field<_F15R1, 13, 1>; // Filter bits
        using FB14 = Field<_F15R1, 14, 1>; // Filter bits
        using FB15 = Field<_F15R1, 15, 1>; // Filter bits
        using FB16 = Field<_F15R1, 16, 1>; // Filter bits
        using FB17 = Field<_F15R1, 17, 1>; // Filter bits
        using FB18 = Field<_F15R1, 18, 1>; // Filter bits
        using FB19 = Field<_F15R1, 19, 1>; // Filter bits
        using FB20 = Field<_F15R1, 20, 1>; // Filter bits
        using FB21 = Field<_F15R1, 21, 1>; // Filter bits
        using FB22 = Field<_F15R1, 22, 1>; // Filter bits
        using FB23 = Field<_F15R1, 23, 1>; // Filter bits
        using FB24 = Field<_F15R1, 24, 1>; // Filter bits
        using FB25 = Field<_F15R1, 25, 1>; // Filter bits
        using FB26 = Field<_F15R1, 26, 1>; // Filter bits
        using FB27 = Field<_F15R1, 27, 1>; // Filter bits
        using FB28 = Field<_F15R1, 28, 1>; // Filter bits
        using FB29 = Field<_F15R1, 29, 1>; // Filter bits
        using FB30 = Field<_F15R1, 30, 1>; // Filter bits
        using FB31 = Field<_F15R1, 31, 1>; // Filter bits
    };

    // Filter bank 15 register 2
    struct _F15R2 : Register<CAN1_BASE + 0x2BC, ReadWrite, _F15R2> {
        using FB0 = Field<_F15R2, 0, 1>; // Filter bits
        using FB1 = Field<_F15R2, 1, 1>; // Filter bits
        using FB2 = Field<_F15R2, 2, 1>; // Filter bits
        using FB3 = Field<_F15R2, 3, 1>; // Filter bits
        using FB4 = Field<_F15R2, 4, 1>; // Filter bits
        using FB5 = Field<_F15R2, 5, 1>; // Filter bits
        using FB6 = Field<_F15R2, 6, 1>; // Filter bits
        using FB7 = Field<_F15R2, 7, 1>; // Filter bits
        using FB8 = Field<_F15R2, 8, 1>; // Filter bits
        using FB9 = Field<_F15R2, 9, 1>; // Filter bits
        using FB10 = Field<_F15R2, 10, 1>; // Filter bits
        using FB11 = Field<_F15R2, 11, 1>; // Filter bits
        using FB12 = Field<_F15R2, 12, 1>; // Filter bits
        using FB13 = Field<_F15R2, 13, 1>; // Filter bits
        using FB14 = Field<_F15R2, 14, 1>; // Filter bits
        using FB15 = Field<_F15R2, 15, 1>; // Filter bits
        using FB16 = Field<_F15R2, 16, 1>; // Filter bits
        using FB17 = Field<_F15R2, 17, 1>; // Filter bits
        using FB18 = Field<_F15R2, 18, 1>; // Filter bits
        using FB19 = Field<_F15R2, 19, 1>; // Filter bits
        using FB20 = Field<_F15R2, 20, 1>; // Filter bits
        using FB21 = Field<_F15R2, 21, 1>; // Filter bits
        using FB22 = Field<_F15R2, 22, 1>; // Filter bits
        using FB23 = Field<_F15R2, 23, 1>; // Filter bits
        using FB24 = Field<_F15R2, 24, 1>; // Filter bits
        using FB25 = Field<_F15R2, 25, 1>; // Filter bits
        using FB26 = Field<_F15R2, 26, 1>; // Filter bits
        using FB27 = Field<_F15R2, 27, 1>; // Filter bits
        using FB28 = Field<_F15R2, 28, 1>; // Filter bits
        using FB29 = Field<_F15R2, 29, 1>; // Filter bits
        using FB30 = Field<_F15R2, 30, 1>; // Filter bits
        using FB31 = Field<_F15R2, 31, 1>; // Filter bits
    };

    // Filter bank 16 register 1
    struct _F16R1 : Register<CAN1_BASE + 0x2C0, ReadWrite, _F16R1> {
        using FB0 = Field<_F16R1, 0, 1>; // Filter bits
        using FB1 = Field<_F16R1, 1, 1>; // Filter bits
        using FB2 = Field<_F16R1, 2, 1>; // Filter bits
        using FB3 = Field<_F16R1, 3, 1>; // Filter bits
        using FB4 = Field<_F16R1, 4, 1>; // Filter bits
        using FB5 = Field<_F16R1, 5, 1>; // Filter bits
        using FB6 = Field<_F16R1, 6, 1>; // Filter bits
        using FB7 = Field<_F16R1, 7, 1>; // Filter bits
        using FB8 = Field<_F16R1, 8, 1>; // Filter bits
        using FB9 = Field<_F16R1, 9, 1>; // Filter bits
        using FB10 = Field<_F16R1, 10, 1>; // Filter bits
        using FB11 = Field<_F16R1, 11, 1>; // Filter bits
        using FB12 = Field<_F16R1, 12, 1>; // Filter bits
        using FB13 = Field<_F16R1, 13, 1>; // Filter bits
        using FB14 = Field<_F16R1, 14, 1>; // Filter bits
        using FB15 = Field<_F16R1, 15, 1>; // Filter bits
        using FB16 = Field<_F16R1, 16, 1>; // Filter bits
        using FB17 = Field<_F16R1, 17, 1>; // Filter bits
        using FB18 = Field<_F16R1, 18, 1>; // Filter bits
        using FB19 = Field<_F16R1, 19, 1>; // Filter bits
        using FB20 = Field<_F16R1, 20, 1>; // Filter bits
        using FB21 = Field<_F16R1, 21, 1>; // Filter bits
        using FB22 = Field<_F16R1, 22, 1>; // Filter bits
        using FB23 = Field<_F16R1, 23, 1>; // Filter bits
        using FB24 = Field<_F16R1, 24, 1>; // Filter bits
        using FB25 = Field<_F16R1, 25, 1>; // Filter bits
        using FB26 = Field<_F16R1, 26, 1>; // Filter bits
        using FB27 = Field<_F16R1, 27, 1>; // Filter bits
        using FB28 = Field<_F16R1, 28, 1>; // Filter bits
        using FB29 = Field<_F16R1, 29, 1>; // Filter bits
        using FB30 = Field<_F16R1, 30, 1>; // Filter bits
        using FB31 = Field<_F16R1, 31, 1>; // Filter bits
    };

    // Filter bank 16 register 2
    struct _F16R2 : Register<CAN1_BASE + 0x2C4, ReadWrite, _F16R2> {
        using FB0 = Field<_F16R2, 0, 1>; // Filter bits
        using FB1 = Field<_F16R2, 1, 1>; // Filter bits
        using FB2 = Field<_F16R2, 2, 1>; // Filter bits
        using FB3 = Field<_F16R2, 3, 1>; // Filter bits
        using FB4 = Field<_F16R2, 4, 1>; // Filter bits
        using FB5 = Field<_F16R2, 5, 1>; // Filter bits
        using FB6 = Field<_F16R2, 6, 1>; // Filter bits
        using FB7 = Field<_F16R2, 7, 1>; // Filter bits
        using FB8 = Field<_F16R2, 8, 1>; // Filter bits
        using FB9 = Field<_F16R2, 9, 1>; // Filter bits
        using FB10 = Field<_F16R2, 10, 1>; // Filter bits
        using FB11 = Field<_F16R2, 11, 1>; // Filter bits
        using FB12 = Field<_F16R2, 12, 1>; // Filter bits
        using FB13 = Field<_F16R2, 13, 1>; // Filter bits
        using FB14 = Field<_F16R2, 14, 1>; // Filter bits
        using FB15 = Field<_F16R2, 15, 1>; // Filter bits
        using FB16 = Field<_F16R2, 16, 1>; // Filter bits
        using FB17 = Field<_F16R2, 17, 1>; // Filter bits
        using FB18 = Field<_F16R2, 18, 1>; // Filter bits
        using FB19 = Field<_F16R2, 19, 1>; // Filter bits
        using FB20 = Field<_F16R2, 20, 1>; // Filter bits
        using FB21 = Field<_F16R2, 21, 1>; // Filter bits
        using FB22 = Field<_F16R2, 22, 1>; // Filter bits
        using FB23 = Field<_F16R2, 23, 1>; // Filter bits
        using FB24 = Field<_F16R2, 24, 1>; // Filter bits
        using FB25 = Field<_F16R2, 25, 1>; // Filter bits
        using FB26 = Field<_F16R2, 26, 1>; // Filter bits
        using FB27 = Field<_F16R2, 27, 1>; // Filter bits
        using FB28 = Field<_F16R2, 28, 1>; // Filter bits
        using FB29 = Field<_F16R2, 29, 1>; // Filter bits
        using FB30 = Field<_F16R2, 30, 1>; // Filter bits
        using FB31 = Field<_F16R2, 31, 1>; // Filter bits
    };

    // Filter bank 17 register 1
    struct _F17R1 : Register<CAN1_BASE + 0x2C8, ReadWrite, _F17R1> {
        using FB0 = Field<_F17R1, 0, 1>; // Filter bits
        using FB1 = Field<_F17R1, 1, 1>; // Filter bits
        using FB2 = Field<_F17R1, 2, 1>; // Filter bits
        using FB3 = Field<_F17R1, 3, 1>; // Filter bits
        using FB4 = Field<_F17R1, 4, 1>; // Filter bits
        using FB5 = Field<_F17R1, 5, 1>; // Filter bits
        using FB6 = Field<_F17R1, 6, 1>; // Filter bits
        using FB7 = Field<_F17R1, 7, 1>; // Filter bits
        using FB8 = Field<_F17R1, 8, 1>; // Filter bits
        using FB9 = Field<_F17R1, 9, 1>; // Filter bits
        using FB10 = Field<_F17R1, 10, 1>; // Filter bits
        using FB11 = Field<_F17R1, 11, 1>; // Filter bits
        using FB12 = Field<_F17R1, 12, 1>; // Filter bits
        using FB13 = Field<_F17R1, 13, 1>; // Filter bits
        using FB14 = Field<_F17R1, 14, 1>; // Filter bits
        using FB15 = Field<_F17R1, 15, 1>; // Filter bits
        using FB16 = Field<_F17R1, 16, 1>; // Filter bits
        using FB17 = Field<_F17R1, 17, 1>; // Filter bits
        using FB18 = Field<_F17R1, 18, 1>; // Filter bits
        using FB19 = Field<_F17R1, 19, 1>; // Filter bits
        using FB20 = Field<_F17R1, 20, 1>; // Filter bits
        using FB21 = Field<_F17R1, 21, 1>; // Filter bits
        using FB22 = Field<_F17R1, 22, 1>; // Filter bits
        using FB23 = Field<_F17R1, 23, 1>; // Filter bits
        using FB24 = Field<_F17R1, 24, 1>; // Filter bits
        using FB25 = Field<_F17R1, 25, 1>; // Filter bits
        using FB26 = Field<_F17R1, 26, 1>; // Filter bits
        using FB27 = Field<_F17R1, 27, 1>; // Filter bits
        using FB28 = Field<_F17R1, 28, 1>; // Filter bits
        using FB29 = Field<_F17R1, 29, 1>; // Filter bits
        using FB30 = Field<_F17R1, 30, 1>; // Filter bits
        using FB31 = Field<_F17R1, 31, 1>; // Filter bits
    };

    // Filter bank 17 register 2
    struct _F17R2 : Register<CAN1_BASE + 0x2CC, ReadWrite, _F17R2> {
        using FB0 = Field<_F17R2, 0, 1>; // Filter bits
        using FB1 = Field<_F17R2, 1, 1>; // Filter bits
        using FB2 = Field<_F17R2, 2, 1>; // Filter bits
        using FB3 = Field<_F17R2, 3, 1>; // Filter bits
        using FB4 = Field<_F17R2, 4, 1>; // Filter bits
        using FB5 = Field<_F17R2, 5, 1>; // Filter bits
        using FB6 = Field<_F17R2, 6, 1>; // Filter bits
        using FB7 = Field<_F17R2, 7, 1>; // Filter bits
        using FB8 = Field<_F17R2, 8, 1>; // Filter bits
        using FB9 = Field<_F17R2, 9, 1>; // Filter bits
        using FB10 = Field<_F17R2, 10, 1>; // Filter bits
        using FB11 = Field<_F17R2, 11, 1>; // Filter bits
        using FB12 = Field<_F17R2, 12, 1>; // Filter bits
        using FB13 = Field<_F17R2, 13, 1>; // Filter bits
        using FB14 = Field<_F17R2, 14, 1>; // Filter bits
        using FB15 = Field<_F17R2, 15, 1>; // Filter bits
        using FB16 = Field<_F17R2, 16, 1>; // Filter bits
        using FB17 = Field<_F17R2, 17, 1>; // Filter bits
        using FB18 = Field<_F17R2, 18, 1>; // Filter bits
        using FB19 = Field<_F17R2, 19, 1>; // Filter bits
        using FB20 = Field<_F17R2, 20, 1>; // Filter bits
        using FB21 = Field<_F17R2, 21, 1>; // Filter bits
        using FB22 = Field<_F17R2, 22, 1>; // Filter bits
        using FB23 = Field<_F17R2, 23, 1>; // Filter bits
        using FB24 = Field<_F17R2, 24, 1>; // Filter bits
        using FB25 = Field<_F17R2, 25, 1>; // Filter bits
        using FB26 = Field<_F17R2, 26, 1>; // Filter bits
        using FB27 = Field<_F17R2, 27, 1>; // Filter bits
        using FB28 = Field<_F17R2, 28, 1>; // Filter bits
        using FB29 = Field<_F17R2, 29, 1>; // Filter bits
        using FB30 = Field<_F17R2, 30, 1>; // Filter bits
        using FB31 = Field<_F17R2, 31, 1>; // Filter bits
    };

    // Filter bank 18 register 1
    struct _F18R1 : Register<CAN1_BASE + 0x2D0, ReadWrite, _F18R1> {
        using FB0 = Field<_F18R1, 0, 1>; // Filter bits
        using FB1 = Field<_F18R1, 1, 1>; // Filter bits
        using FB2 = Field<_F18R1, 2, 1>; // Filter bits
        using FB3 = Field<_F18R1, 3, 1>; // Filter bits
        using FB4 = Field<_F18R1, 4, 1>; // Filter bits
        using FB5 = Field<_F18R1, 5, 1>; // Filter bits
        using FB6 = Field<_F18R1, 6, 1>; // Filter bits
        using FB7 = Field<_F18R1, 7, 1>; // Filter bits
        using FB8 = Field<_F18R1, 8, 1>; // Filter bits
        using FB9 = Field<_F18R1, 9, 1>; // Filter bits
        using FB10 = Field<_F18R1, 10, 1>; // Filter bits
        using FB11 = Field<_F18R1, 11, 1>; // Filter bits
        using FB12 = Field<_F18R1, 12, 1>; // Filter bits
        using FB13 = Field<_F18R1, 13, 1>; // Filter bits
        using FB14 = Field<_F18R1, 14, 1>; // Filter bits
        using FB15 = Field<_F18R1, 15, 1>; // Filter bits
        using FB16 = Field<_F18R1, 16, 1>; // Filter bits
        using FB17 = Field<_F18R1, 17, 1>; // Filter bits
        using FB18 = Field<_F18R1, 18, 1>; // Filter bits
        using FB19 = Field<_F18R1, 19, 1>; // Filter bits
        using FB20 = Field<_F18R1, 20, 1>; // Filter bits
        using FB21 = Field<_F18R1, 21, 1>; // Filter bits
        using FB22 = Field<_F18R1, 22, 1>; // Filter bits
        using FB23 = Field<_F18R1, 23, 1>; // Filter bits
        using FB24 = Field<_F18R1, 24, 1>; // Filter bits
        using FB25 = Field<_F18R1, 25, 1>; // Filter bits
        using FB26 = Field<_F18R1, 26, 1>; // Filter bits
        using FB27 = Field<_F18R1, 27, 1>; // Filter bits
        using FB28 = Field<_F18R1, 28, 1>; // Filter bits
        using FB29 = Field<_F18R1, 29, 1>; // Filter bits
        using FB30 = Field<_F18R1, 30, 1>; // Filter bits
        using FB31 = Field<_F18R1, 31, 1>; // Filter bits
    };

    // Filter bank 18 register 2
    struct _F18R2 : Register<CAN1_BASE + 0x2D4, ReadWrite, _F18R2> {
        using FB0 = Field<_F18R2, 0, 1>; // Filter bits
        using FB1 = Field<_F18R2, 1, 1>; // Filter bits
        using FB2 = Field<_F18R2, 2, 1>; // Filter bits
        using FB3 = Field<_F18R2, 3, 1>; // Filter bits
        using FB4 = Field<_F18R2, 4, 1>; // Filter bits
        using FB5 = Field<_F18R2, 5, 1>; // Filter bits
        using FB6 = Field<_F18R2, 6, 1>; // Filter bits
        using FB7 = Field<_F18R2, 7, 1>; // Filter bits
        using FB8 = Field<_F18R2, 8, 1>; // Filter bits
        using FB9 = Field<_F18R2, 9, 1>; // Filter bits
        using FB10 = Field<_F18R2, 10, 1>; // Filter bits
        using FB11 = Field<_F18R2, 11, 1>; // Filter bits
        using FB12 = Field<_F18R2, 12, 1>; // Filter bits
        using FB13 = Field<_F18R2, 13, 1>; // Filter bits
        using FB14 = Field<_F18R2, 14, 1>; // Filter bits
        using FB15 = Field<_F18R2, 15, 1>; // Filter bits
        using FB16 = Field<_F18R2, 16, 1>; // Filter bits
        using FB17 = Field<_F18R2, 17, 1>; // Filter bits
        using FB18 = Field<_F18R2, 18, 1>; // Filter bits
        using FB19 = Field<_F18R2, 19, 1>; // Filter bits
        using FB20 = Field<_F18R2, 20, 1>; // Filter bits
        using FB21 = Field<_F18R2, 21, 1>; // Filter bits
        using FB22 = Field<_F18R2, 22, 1>; // Filter bits
        using FB23 = Field<_F18R2, 23, 1>; // Filter bits
        using FB24 = Field<_F18R2, 24, 1>; // Filter bits
        using FB25 = Field<_F18R2, 25, 1>; // Filter bits
        using FB26 = Field<_F18R2, 26, 1>; // Filter bits
        using FB27 = Field<_F18R2, 27, 1>; // Filter bits
        using FB28 = Field<_F18R2, 28, 1>; // Filter bits
        using FB29 = Field<_F18R2, 29, 1>; // Filter bits
        using FB30 = Field<_F18R2, 30, 1>; // Filter bits
        using FB31 = Field<_F18R2, 31, 1>; // Filter bits
    };

    // Filter bank 19 register 1
    struct _F19R1 : Register<CAN1_BASE + 0x2D8, ReadWrite, _F19R1> {
        using FB0 = Field<_F19R1, 0, 1>; // Filter bits
        using FB1 = Field<_F19R1, 1, 1>; // Filter bits
        using FB2 = Field<_F19R1, 2, 1>; // Filter bits
        using FB3 = Field<_F19R1, 3, 1>; // Filter bits
        using FB4 = Field<_F19R1, 4, 1>; // Filter bits
        using FB5 = Field<_F19R1, 5, 1>; // Filter bits
        using FB6 = Field<_F19R1, 6, 1>; // Filter bits
        using FB7 = Field<_F19R1, 7, 1>; // Filter bits
        using FB8 = Field<_F19R1, 8, 1>; // Filter bits
        using FB9 = Field<_F19R1, 9, 1>; // Filter bits
        using FB10 = Field<_F19R1, 10, 1>; // Filter bits
        using FB11 = Field<_F19R1, 11, 1>; // Filter bits
        using FB12 = Field<_F19R1, 12, 1>; // Filter bits
        using FB13 = Field<_F19R1, 13, 1>; // Filter bits
        using FB14 = Field<_F19R1, 14, 1>; // Filter bits
        using FB15 = Field<_F19R1, 15, 1>; // Filter bits
        using FB16 = Field<_F19R1, 16, 1>; // Filter bits
        using FB17 = Field<_F19R1, 17, 1>; // Filter bits
        using FB18 = Field<_F19R1, 18, 1>; // Filter bits
        using FB19 = Field<_F19R1, 19, 1>; // Filter bits
        using FB20 = Field<_F19R1, 20, 1>; // Filter bits
        using FB21 = Field<_F19R1, 21, 1>; // Filter bits
        using FB22 = Field<_F19R1, 22, 1>; // Filter bits
        using FB23 = Field<_F19R1, 23, 1>; // Filter bits
        using FB24 = Field<_F19R1, 24, 1>; // Filter bits
        using FB25 = Field<_F19R1, 25, 1>; // Filter bits
        using FB26 = Field<_F19R1, 26, 1>; // Filter bits
        using FB27 = Field<_F19R1, 27, 1>; // Filter bits
        using FB28 = Field<_F19R1, 28, 1>; // Filter bits
        using FB29 = Field<_F19R1, 29, 1>; // Filter bits
        using FB30 = Field<_F19R1, 30, 1>; // Filter bits
        using FB31 = Field<_F19R1, 31, 1>; // Filter bits
    };

    // Filter bank 19 register 2
    struct _F19R2 : Register<CAN1_BASE + 0x2DC, ReadWrite, _F19R2> {
        using FB0 = Field<_F19R2, 0, 1>; // Filter bits
        using FB1 = Field<_F19R2, 1, 1>; // Filter bits
        using FB2 = Field<_F19R2, 2, 1>; // Filter bits
        using FB3 = Field<_F19R2, 3, 1>; // Filter bits
        using FB4 = Field<_F19R2, 4, 1>; // Filter bits
        using FB5 = Field<_F19R2, 5, 1>; // Filter bits
        using FB6 = Field<_F19R2, 6, 1>; // Filter bits
        using FB7 = Field<_F19R2, 7, 1>; // Filter bits
        using FB8 = Field<_F19R2, 8, 1>; // Filter bits
        using FB9 = Field<_F19R2, 9, 1>; // Filter bits
        using FB10 = Field<_F19R2, 10, 1>; // Filter bits
        using FB11 = Field<_F19R2, 11, 1>; // Filter bits
        using FB12 = Field<_F19R2, 12, 1>; // Filter bits
        using FB13 = Field<_F19R2, 13, 1>; // Filter bits
        using FB14 = Field<_F19R2, 14, 1>; // Filter bits
        using FB15 = Field<_F19R2, 15, 1>; // Filter bits
        using FB16 = Field<_F19R2, 16, 1>; // Filter bits
        using FB17 = Field<_F19R2, 17, 1>; // Filter bits
        using FB18 = Field<_F19R2, 18, 1>; // Filter bits
        using FB19 = Field<_F19R2, 19, 1>; // Filter bits
        using FB20 = Field<_F19R2, 20, 1>; // Filter bits
        using FB21 = Field<_F19R2, 21, 1>; // Filter bits
        using FB22 = Field<_F19R2, 22, 1>; // Filter bits
        using FB23 = Field<_F19R2, 23, 1>; // Filter bits
        using FB24 = Field<_F19R2, 24, 1>; // Filter bits
        using FB25 = Field<_F19R2, 25, 1>; // Filter bits
        using FB26 = Field<_F19R2, 26, 1>; // Filter bits
        using FB27 = Field<_F19R2, 27, 1>; // Filter bits
        using FB28 = Field<_F19R2, 28, 1>; // Filter bits
        using FB29 = Field<_F19R2, 29, 1>; // Filter bits
        using FB30 = Field<_F19R2, 30, 1>; // Filter bits
        using FB31 = Field<_F19R2, 31, 1>; // Filter bits
    };

    // Filter bank 20 register 1
    struct _F20R1 : Register<CAN1_BASE + 0x2E0, ReadWrite, _F20R1> {
        using FB0 = Field<_F20R1, 0, 1>; // Filter bits
        using FB1 = Field<_F20R1, 1, 1>; // Filter bits
        using FB2 = Field<_F20R1, 2, 1>; // Filter bits
        using FB3 = Field<_F20R1, 3, 1>; // Filter bits
        using FB4 = Field<_F20R1, 4, 1>; // Filter bits
        using FB5 = Field<_F20R1, 5, 1>; // Filter bits
        using FB6 = Field<_F20R1, 6, 1>; // Filter bits
        using FB7 = Field<_F20R1, 7, 1>; // Filter bits
        using FB8 = Field<_F20R1, 8, 1>; // Filter bits
        using FB9 = Field<_F20R1, 9, 1>; // Filter bits
        using FB10 = Field<_F20R1, 10, 1>; // Filter bits
        using FB11 = Field<_F20R1, 11, 1>; // Filter bits
        using FB12 = Field<_F20R1, 12, 1>; // Filter bits
        using FB13 = Field<_F20R1, 13, 1>; // Filter bits
        using FB14 = Field<_F20R1, 14, 1>; // Filter bits
        using FB15 = Field<_F20R1, 15, 1>; // Filter bits
        using FB16 = Field<_F20R1, 16, 1>; // Filter bits
        using FB17 = Field<_F20R1, 17, 1>; // Filter bits
        using FB18 = Field<_F20R1, 18, 1>; // Filter bits
        using FB19 = Field<_F20R1, 19, 1>; // Filter bits
        using FB20 = Field<_F20R1, 20, 1>; // Filter bits
        using FB21 = Field<_F20R1, 21, 1>; // Filter bits
        using FB22 = Field<_F20R1, 22, 1>; // Filter bits
        using FB23 = Field<_F20R1, 23, 1>; // Filter bits
        using FB24 = Field<_F20R1, 24, 1>; // Filter bits
        using FB25 = Field<_F20R1, 25, 1>; // Filter bits
        using FB26 = Field<_F20R1, 26, 1>; // Filter bits
        using FB27 = Field<_F20R1, 27, 1>; // Filter bits
        using FB28 = Field<_F20R1, 28, 1>; // Filter bits
        using FB29 = Field<_F20R1, 29, 1>; // Filter bits
        using FB30 = Field<_F20R1, 30, 1>; // Filter bits
        using FB31 = Field<_F20R1, 31, 1>; // Filter bits
    };

    // Filter bank 20 register 2
    struct _F20R2 : Register<CAN1_BASE + 0x2E4, ReadWrite, _F20R2> {
        using FB0 = Field<_F20R2, 0, 1>; // Filter bits
        using FB1 = Field<_F20R2, 1, 1>; // Filter bits
        using FB2 = Field<_F20R2, 2, 1>; // Filter bits
        using FB3 = Field<_F20R2, 3, 1>; // Filter bits
        using FB4 = Field<_F20R2, 4, 1>; // Filter bits
        using FB5 = Field<_F20R2, 5, 1>; // Filter bits
        using FB6 = Field<_F20R2, 6, 1>; // Filter bits
        using FB7 = Field<_F20R2, 7, 1>; // Filter bits
        using FB8 = Field<_F20R2, 8, 1>; // Filter bits
        using FB9 = Field<_F20R2, 9, 1>; // Filter bits
        using FB10 = Field<_F20R2, 10, 1>; // Filter bits
        using FB11 = Field<_F20R2, 11, 1>; // Filter bits
        using FB12 = Field<_F20R2, 12, 1>; // Filter bits
        using FB13 = Field<_F20R2, 13, 1>; // Filter bits
        using FB14 = Field<_F20R2, 14, 1>; // Filter bits
        using FB15 = Field<_F20R2, 15, 1>; // Filter bits
        using FB16 = Field<_F20R2, 16, 1>; // Filter bits
        using FB17 = Field<_F20R2, 17, 1>; // Filter bits
        using FB18 = Field<_F20R2, 18, 1>; // Filter bits
        using FB19 = Field<_F20R2, 19, 1>; // Filter bits
        using FB20 = Field<_F20R2, 20, 1>; // Filter bits
        using FB21 = Field<_F20R2, 21, 1>; // Filter bits
        using FB22 = Field<_F20R2, 22, 1>; // Filter bits
        using FB23 = Field<_F20R2, 23, 1>; // Filter bits
        using FB24 = Field<_F20R2, 24, 1>; // Filter bits
        using FB25 = Field<_F20R2, 25, 1>; // Filter bits
        using FB26 = Field<_F20R2, 26, 1>; // Filter bits
        using FB27 = Field<_F20R2, 27, 1>; // Filter bits
        using FB28 = Field<_F20R2, 28, 1>; // Filter bits
        using FB29 = Field<_F20R2, 29, 1>; // Filter bits
        using FB30 = Field<_F20R2, 30, 1>; // Filter bits
        using FB31 = Field<_F20R2, 31, 1>; // Filter bits
    };

    // Filter bank 21 register 1
    struct _F21R1 : Register<CAN1_BASE + 0x2E8, ReadWrite, _F21R1> {
        using FB0 = Field<_F21R1, 0, 1>; // Filter bits
        using FB1 = Field<_F21R1, 1, 1>; // Filter bits
        using FB2 = Field<_F21R1, 2, 1>; // Filter bits
        using FB3 = Field<_F21R1, 3, 1>; // Filter bits
        using FB4 = Field<_F21R1, 4, 1>; // Filter bits
        using FB5 = Field<_F21R1, 5, 1>; // Filter bits
        using FB6 = Field<_F21R1, 6, 1>; // Filter bits
        using FB7 = Field<_F21R1, 7, 1>; // Filter bits
        using FB8 = Field<_F21R1, 8, 1>; // Filter bits
        using FB9 = Field<_F21R1, 9, 1>; // Filter bits
        using FB10 = Field<_F21R1, 10, 1>; // Filter bits
        using FB11 = Field<_F21R1, 11, 1>; // Filter bits
        using FB12 = Field<_F21R1, 12, 1>; // Filter bits
        using FB13 = Field<_F21R1, 13, 1>; // Filter bits
        using FB14 = Field<_F21R1, 14, 1>; // Filter bits
        using FB15 = Field<_F21R1, 15, 1>; // Filter bits
        using FB16 = Field<_F21R1, 16, 1>; // Filter bits
        using FB17 = Field<_F21R1, 17, 1>; // Filter bits
        using FB18 = Field<_F21R1, 18, 1>; // Filter bits
        using FB19 = Field<_F21R1, 19, 1>; // Filter bits
        using FB20 = Field<_F21R1, 20, 1>; // Filter bits
        using FB21 = Field<_F21R1, 21, 1>; // Filter bits
        using FB22 = Field<_F21R1, 22, 1>; // Filter bits
        using FB23 = Field<_F21R1, 23, 1>; // Filter bits
        using FB24 = Field<_F21R1, 24, 1>; // Filter bits
        using FB25 = Field<_F21R1, 25, 1>; // Filter bits
        using FB26 = Field<_F21R1, 26, 1>; // Filter bits
        using FB27 = Field<_F21R1, 27, 1>; // Filter bits
        using FB28 = Field<_F21R1, 28, 1>; // Filter bits
        using FB29 = Field<_F21R1, 29, 1>; // Filter bits
        using FB30 = Field<_F21R1, 30, 1>; // Filter bits
        using FB31 = Field<_F21R1, 31, 1>; // Filter bits
    };

    // Filter bank 21 register 2
    struct _F21R2 : Register<CAN1_BASE + 0x2EC, ReadWrite, _F21R2> {
        using FB0 = Field<_F21R2, 0, 1>; // Filter bits
        using FB1 = Field<_F21R2, 1, 1>; // Filter bits
        using FB2 = Field<_F21R2, 2, 1>; // Filter bits
        using FB3 = Field<_F21R2, 3, 1>; // Filter bits
        using FB4 = Field<_F21R2, 4, 1>; // Filter bits
        using FB5 = Field<_F21R2, 5, 1>; // Filter bits
        using FB6 = Field<_F21R2, 6, 1>; // Filter bits
        using FB7 = Field<_F21R2, 7, 1>; // Filter bits
        using FB8 = Field<_F21R2, 8, 1>; // Filter bits
        using FB9 = Field<_F21R2, 9, 1>; // Filter bits
        using FB10 = Field<_F21R2, 10, 1>; // Filter bits
        using FB11 = Field<_F21R2, 11, 1>; // Filter bits
        using FB12 = Field<_F21R2, 12, 1>; // Filter bits
        using FB13 = Field<_F21R2, 13, 1>; // Filter bits
        using FB14 = Field<_F21R2, 14, 1>; // Filter bits
        using FB15 = Field<_F21R2, 15, 1>; // Filter bits
        using FB16 = Field<_F21R2, 16, 1>; // Filter bits
        using FB17 = Field<_F21R2, 17, 1>; // Filter bits
        using FB18 = Field<_F21R2, 18, 1>; // Filter bits
        using FB19 = Field<_F21R2, 19, 1>; // Filter bits
        using FB20 = Field<_F21R2, 20, 1>; // Filter bits
        using FB21 = Field<_F21R2, 21, 1>; // Filter bits
        using FB22 = Field<_F21R2, 22, 1>; // Filter bits
        using FB23 = Field<_F21R2, 23, 1>; // Filter bits
        using FB24 = Field<_F21R2, 24, 1>; // Filter bits
        using FB25 = Field<_F21R2, 25, 1>; // Filter bits
        using FB26 = Field<_F21R2, 26, 1>; // Filter bits
        using FB27 = Field<_F21R2, 27, 1>; // Filter bits
        using FB28 = Field<_F21R2, 28, 1>; // Filter bits
        using FB29 = Field<_F21R2, 29, 1>; // Filter bits
        using FB30 = Field<_F21R2, 30, 1>; // Filter bits
        using FB31 = Field<_F21R2, 31, 1>; // Filter bits
    };

    // Filter bank 22 register 1
    struct _F22R1 : Register<CAN1_BASE + 0x2F0, ReadWrite, _F22R1> {
        using FB0 = Field<_F22R1, 0, 1>; // Filter bits
        using FB1 = Field<_F22R1, 1, 1>; // Filter bits
        using FB2 = Field<_F22R1, 2, 1>; // Filter bits
        using FB3 = Field<_F22R1, 3, 1>; // Filter bits
        using FB4 = Field<_F22R1, 4, 1>; // Filter bits
        using FB5 = Field<_F22R1, 5, 1>; // Filter bits
        using FB6 = Field<_F22R1, 6, 1>; // Filter bits
        using FB7 = Field<_F22R1, 7, 1>; // Filter bits
        using FB8 = Field<_F22R1, 8, 1>; // Filter bits
        using FB9 = Field<_F22R1, 9, 1>; // Filter bits
        using FB10 = Field<_F22R1, 10, 1>; // Filter bits
        using FB11 = Field<_F22R1, 11, 1>; // Filter bits
        using FB12 = Field<_F22R1, 12, 1>; // Filter bits
        using FB13 = Field<_F22R1, 13, 1>; // Filter bits
        using FB14 = Field<_F22R1, 14, 1>; // Filter bits
        using FB15 = Field<_F22R1, 15, 1>; // Filter bits
        using FB16 = Field<_F22R1, 16, 1>; // Filter bits
        using FB17 = Field<_F22R1, 17, 1>; // Filter bits
        using FB18 = Field<_F22R1, 18, 1>; // Filter bits
        using FB19 = Field<_F22R1, 19, 1>; // Filter bits
        using FB20 = Field<_F22R1, 20, 1>; // Filter bits
        using FB21 = Field<_F22R1, 21, 1>; // Filter bits
        using FB22 = Field<_F22R1, 22, 1>; // Filter bits
        using FB23 = Field<_F22R1, 23, 1>; // Filter bits
        using FB24 = Field<_F22R1, 24, 1>; // Filter bits
        using FB25 = Field<_F22R1, 25, 1>; // Filter bits
        using FB26 = Field<_F22R1, 26, 1>; // Filter bits
        using FB27 = Field<_F22R1, 27, 1>; // Filter bits
        using FB28 = Field<_F22R1, 28, 1>; // Filter bits
        using FB29 = Field<_F22R1, 29, 1>; // Filter bits
        using FB30 = Field<_F22R1, 30, 1>; // Filter bits
        using FB31 = Field<_F22R1, 31, 1>; // Filter bits
    };

    // Filter bank 22 register 2
    struct _F22R2 : Register<CAN1_BASE + 0x2F4, ReadWrite, _F22R2> {
        using FB0 = Field<_F22R2, 0, 1>; // Filter bits
        using FB1 = Field<_F22R2, 1, 1>; // Filter bits
        using FB2 = Field<_F22R2, 2, 1>; // Filter bits
        using FB3 = Field<_F22R2, 3, 1>; // Filter bits
        using FB4 = Field<_F22R2, 4, 1>; // Filter bits
        using FB5 = Field<_F22R2, 5, 1>; // Filter bits
        using FB6 = Field<_F22R2, 6, 1>; // Filter bits
        using FB7 = Field<_F22R2, 7, 1>; // Filter bits
        using FB8 = Field<_F22R2, 8, 1>; // Filter bits
        using FB9 = Field<_F22R2, 9, 1>; // Filter bits
        using FB10 = Field<_F22R2, 10, 1>; // Filter bits
        using FB11 = Field<_F22R2, 11, 1>; // Filter bits
        using FB12 = Field<_F22R2, 12, 1>; // Filter bits
        using FB13 = Field<_F22R2, 13, 1>; // Filter bits
        using FB14 = Field<_F22R2, 14, 1>; // Filter bits
        using FB15 = Field<_F22R2, 15, 1>; // Filter bits
        using FB16 = Field<_F22R2, 16, 1>; // Filter bits
        using FB17 = Field<_F22R2, 17, 1>; // Filter bits
        using FB18 = Field<_F22R2, 18, 1>; // Filter bits
        using FB19 = Field<_F22R2, 19, 1>; // Filter bits
        using FB20 = Field<_F22R2, 20, 1>; // Filter bits
        using FB21 = Field<_F22R2, 21, 1>; // Filter bits
        using FB22 = Field<_F22R2, 22, 1>; // Filter bits
        using FB23 = Field<_F22R2, 23, 1>; // Filter bits
        using FB24 = Field<_F22R2, 24, 1>; // Filter bits
        using FB25 = Field<_F22R2, 25, 1>; // Filter bits
        using FB26 = Field<_F22R2, 26, 1>; // Filter bits
        using FB27 = Field<_F22R2, 27, 1>; // Filter bits
        using FB28 = Field<_F22R2, 28, 1>; // Filter bits
        using FB29 = Field<_F22R2, 29, 1>; // Filter bits
        using FB30 = Field<_F22R2, 30, 1>; // Filter bits
        using FB31 = Field<_F22R2, 31, 1>; // Filter bits
    };

    // Filter bank 23 register 1
    struct _F23R1 : Register<CAN1_BASE + 0x2F8, ReadWrite, _F23R1> {
        using FB0 = Field<_F23R1, 0, 1>; // Filter bits
        using FB1 = Field<_F23R1, 1, 1>; // Filter bits
        using FB2 = Field<_F23R1, 2, 1>; // Filter bits
        using FB3 = Field<_F23R1, 3, 1>; // Filter bits
        using FB4 = Field<_F23R1, 4, 1>; // Filter bits
        using FB5 = Field<_F23R1, 5, 1>; // Filter bits
        using FB6 = Field<_F23R1, 6, 1>; // Filter bits
        using FB7 = Field<_F23R1, 7, 1>; // Filter bits
        using FB8 = Field<_F23R1, 8, 1>; // Filter bits
        using FB9 = Field<_F23R1, 9, 1>; // Filter bits
        using FB10 = Field<_F23R1, 10, 1>; // Filter bits
        using FB11 = Field<_F23R1, 11, 1>; // Filter bits
        using FB12 = Field<_F23R1, 12, 1>; // Filter bits
        using FB13 = Field<_F23R1, 13, 1>; // Filter bits
        using FB14 = Field<_F23R1, 14, 1>; // Filter bits
        using FB15 = Field<_F23R1, 15, 1>; // Filter bits
        using FB16 = Field<_F23R1, 16, 1>; // Filter bits
        using FB17 = Field<_F23R1, 17, 1>; // Filter bits
        using FB18 = Field<_F23R1, 18, 1>; // Filter bits
        using FB19 = Field<_F23R1, 19, 1>; // Filter bits
        using FB20 = Field<_F23R1, 20, 1>; // Filter bits
        using FB21 = Field<_F23R1, 21, 1>; // Filter bits
        using FB22 = Field<_F23R1, 22, 1>; // Filter bits
        using FB23 = Field<_F23R1, 23, 1>; // Filter bits
        using FB24 = Field<_F23R1, 24, 1>; // Filter bits
        using FB25 = Field<_F23R1, 25, 1>; // Filter bits
        using FB26 = Field<_F23R1, 26, 1>; // Filter bits
        using FB27 = Field<_F23R1, 27, 1>; // Filter bits
        using FB28 = Field<_F23R1, 28, 1>; // Filter bits
        using FB29 = Field<_F23R1, 29, 1>; // Filter bits
        using FB30 = Field<_F23R1, 30, 1>; // Filter bits
        using FB31 = Field<_F23R1, 31, 1>; // Filter bits
    };

    // Filter bank 23 register 2
    struct _F23R2 : Register<CAN1_BASE + 0x2FC, ReadWrite, _F23R2> {
        using FB0 = Field<_F23R2, 0, 1>; // Filter bits
        using FB1 = Field<_F23R2, 1, 1>; // Filter bits
        using FB2 = Field<_F23R2, 2, 1>; // Filter bits
        using FB3 = Field<_F23R2, 3, 1>; // Filter bits
        using FB4 = Field<_F23R2, 4, 1>; // Filter bits
        using FB5 = Field<_F23R2, 5, 1>; // Filter bits
        using FB6 = Field<_F23R2, 6, 1>; // Filter bits
        using FB7 = Field<_F23R2, 7, 1>; // Filter bits
        using FB8 = Field<_F23R2, 8, 1>; // Filter bits
        using FB9 = Field<_F23R2, 9, 1>; // Filter bits
        using FB10 = Field<_F23R2, 10, 1>; // Filter bits
        using FB11 = Field<_F23R2, 11, 1>; // Filter bits
        using FB12 = Field<_F23R2, 12, 1>; // Filter bits
        using FB13 = Field<_F23R2, 13, 1>; // Filter bits
        using FB14 = Field<_F23R2, 14, 1>; // Filter bits
        using FB15 = Field<_F23R2, 15, 1>; // Filter bits
        using FB16 = Field<_F23R2, 16, 1>; // Filter bits
        using FB17 = Field<_F23R2, 17, 1>; // Filter bits
        using FB18 = Field<_F23R2, 18, 1>; // Filter bits
        using FB19 = Field<_F23R2, 19, 1>; // Filter bits
        using FB20 = Field<_F23R2, 20, 1>; // Filter bits
        using FB21 = Field<_F23R2, 21, 1>; // Filter bits
        using FB22 = Field<_F23R2, 22, 1>; // Filter bits
        using FB23 = Field<_F23R2, 23, 1>; // Filter bits
        using FB24 = Field<_F23R2, 24, 1>; // Filter bits
        using FB25 = Field<_F23R2, 25, 1>; // Filter bits
        using FB26 = Field<_F23R2, 26, 1>; // Filter bits
        using FB27 = Field<_F23R2, 27, 1>; // Filter bits
        using FB28 = Field<_F23R2, 28, 1>; // Filter bits
        using FB29 = Field<_F23R2, 29, 1>; // Filter bits
        using FB30 = Field<_F23R2, 30, 1>; // Filter bits
        using FB31 = Field<_F23R2, 31, 1>; // Filter bits
    };

    // Filter bank 24 register 1
    struct _F24R1 : Register<CAN1_BASE + 0x300, ReadWrite, _F24R1> {
        using FB0 = Field<_F24R1, 0, 1>; // Filter bits
        using FB1 = Field<_F24R1, 1, 1>; // Filter bits
        using FB2 = Field<_F24R1, 2, 1>; // Filter bits
        using FB3 = Field<_F24R1, 3, 1>; // Filter bits
        using FB4 = Field<_F24R1, 4, 1>; // Filter bits
        using FB5 = Field<_F24R1, 5, 1>; // Filter bits
        using FB6 = Field<_F24R1, 6, 1>; // Filter bits
        using FB7 = Field<_F24R1, 7, 1>; // Filter bits
        using FB8 = Field<_F24R1, 8, 1>; // Filter bits
        using FB9 = Field<_F24R1, 9, 1>; // Filter bits
        using FB10 = Field<_F24R1, 10, 1>; // Filter bits
        using FB11 = Field<_F24R1, 11, 1>; // Filter bits
        using FB12 = Field<_F24R1, 12, 1>; // Filter bits
        using FB13 = Field<_F24R1, 13, 1>; // Filter bits
        using FB14 = Field<_F24R1, 14, 1>; // Filter bits
        using FB15 = Field<_F24R1, 15, 1>; // Filter bits
        using FB16 = Field<_F24R1, 16, 1>; // Filter bits
        using FB17 = Field<_F24R1, 17, 1>; // Filter bits
        using FB18 = Field<_F24R1, 18, 1>; // Filter bits
        using FB19 = Field<_F24R1, 19, 1>; // Filter bits
        using FB20 = Field<_F24R1, 20, 1>; // Filter bits
        using FB21 = Field<_F24R1, 21, 1>; // Filter bits
        using FB22 = Field<_F24R1, 22, 1>; // Filter bits
        using FB23 = Field<_F24R1, 23, 1>; // Filter bits
        using FB24 = Field<_F24R1, 24, 1>; // Filter bits
        using FB25 = Field<_F24R1, 25, 1>; // Filter bits
        using FB26 = Field<_F24R1, 26, 1>; // Filter bits
        using FB27 = Field<_F24R1, 27, 1>; // Filter bits
        using FB28 = Field<_F24R1, 28, 1>; // Filter bits
        using FB29 = Field<_F24R1, 29, 1>; // Filter bits
        using FB30 = Field<_F24R1, 30, 1>; // Filter bits
        using FB31 = Field<_F24R1, 31, 1>; // Filter bits
    };

    // Filter bank 24 register 2
    struct _F24R2 : Register<CAN1_BASE + 0x304, ReadWrite, _F24R2> {
        using FB0 = Field<_F24R2, 0, 1>; // Filter bits
        using FB1 = Field<_F24R2, 1, 1>; // Filter bits
        using FB2 = Field<_F24R2, 2, 1>; // Filter bits
        using FB3 = Field<_F24R2, 3, 1>; // Filter bits
        using FB4 = Field<_F24R2, 4, 1>; // Filter bits
        using FB5 = Field<_F24R2, 5, 1>; // Filter bits
        using FB6 = Field<_F24R2, 6, 1>; // Filter bits
        using FB7 = Field<_F24R2, 7, 1>; // Filter bits
        using FB8 = Field<_F24R2, 8, 1>; // Filter bits
        using FB9 = Field<_F24R2, 9, 1>; // Filter bits
        using FB10 = Field<_F24R2, 10, 1>; // Filter bits
        using FB11 = Field<_F24R2, 11, 1>; // Filter bits
        using FB12 = Field<_F24R2, 12, 1>; // Filter bits
        using FB13 = Field<_F24R2, 13, 1>; // Filter bits
        using FB14 = Field<_F24R2, 14, 1>; // Filter bits
        using FB15 = Field<_F24R2, 15, 1>; // Filter bits
        using FB16 = Field<_F24R2, 16, 1>; // Filter bits
        using FB17 = Field<_F24R2, 17, 1>; // Filter bits
        using FB18 = Field<_F24R2, 18, 1>; // Filter bits
        using FB19 = Field<_F24R2, 19, 1>; // Filter bits
        using FB20 = Field<_F24R2, 20, 1>; // Filter bits
        using FB21 = Field<_F24R2, 21, 1>; // Filter bits
        using FB22 = Field<_F24R2, 22, 1>; // Filter bits
        using FB23 = Field<_F24R2, 23, 1>; // Filter bits
        using FB24 = Field<_F24R2, 24, 1>; // Filter bits
        using FB25 = Field<_F24R2, 25, 1>; // Filter bits
        using FB26 = Field<_F24R2, 26, 1>; // Filter bits
        using FB27 = Field<_F24R2, 27, 1>; // Filter bits
        using FB28 = Field<_F24R2, 28, 1>; // Filter bits
        using FB29 = Field<_F24R2, 29, 1>; // Filter bits
        using FB30 = Field<_F24R2, 30, 1>; // Filter bits
        using FB31 = Field<_F24R2, 31, 1>; // Filter bits
    };

    // Filter bank 25 register 1
    struct _F25R1 : Register<CAN1_BASE + 0x308, ReadWrite, _F25R1> {
        using FB0 = Field<_F25R1, 0, 1>; // Filter bits
        using FB1 = Field<_F25R1, 1, 1>; // Filter bits
        using FB2 = Field<_F25R1, 2, 1>; // Filter bits
        using FB3 = Field<_F25R1, 3, 1>; // Filter bits
        using FB4 = Field<_F25R1, 4, 1>; // Filter bits
        using FB5 = Field<_F25R1, 5, 1>; // Filter bits
        using FB6 = Field<_F25R1, 6, 1>; // Filter bits
        using FB7 = Field<_F25R1, 7, 1>; // Filter bits
        using FB8 = Field<_F25R1, 8, 1>; // Filter bits
        using FB9 = Field<_F25R1, 9, 1>; // Filter bits
        using FB10 = Field<_F25R1, 10, 1>; // Filter bits
        using FB11 = Field<_F25R1, 11, 1>; // Filter bits
        using FB12 = Field<_F25R1, 12, 1>; // Filter bits
        using FB13 = Field<_F25R1, 13, 1>; // Filter bits
        using FB14 = Field<_F25R1, 14, 1>; // Filter bits
        using FB15 = Field<_F25R1, 15, 1>; // Filter bits
        using FB16 = Field<_F25R1, 16, 1>; // Filter bits
        using FB17 = Field<_F25R1, 17, 1>; // Filter bits
        using FB18 = Field<_F25R1, 18, 1>; // Filter bits
        using FB19 = Field<_F25R1, 19, 1>; // Filter bits
        using FB20 = Field<_F25R1, 20, 1>; // Filter bits
        using FB21 = Field<_F25R1, 21, 1>; // Filter bits
        using FB22 = Field<_F25R1, 22, 1>; // Filter bits
        using FB23 = Field<_F25R1, 23, 1>; // Filter bits
        using FB24 = Field<_F25R1, 24, 1>; // Filter bits
        using FB25 = Field<_F25R1, 25, 1>; // Filter bits
        using FB26 = Field<_F25R1, 26, 1>; // Filter bits
        using FB27 = Field<_F25R1, 27, 1>; // Filter bits
        using FB28 = Field<_F25R1, 28, 1>; // Filter bits
        using FB29 = Field<_F25R1, 29, 1>; // Filter bits
        using FB30 = Field<_F25R1, 30, 1>; // Filter bits
        using FB31 = Field<_F25R1, 31, 1>; // Filter bits
    };

    // Filter bank 25 register 2
    struct _F25R2 : Register<CAN1_BASE + 0x30C, ReadWrite, _F25R2> {
        using FB0 = Field<_F25R2, 0, 1>; // Filter bits
        using FB1 = Field<_F25R2, 1, 1>; // Filter bits
        using FB2 = Field<_F25R2, 2, 1>; // Filter bits
        using FB3 = Field<_F25R2, 3, 1>; // Filter bits
        using FB4 = Field<_F25R2, 4, 1>; // Filter bits
        using FB5 = Field<_F25R2, 5, 1>; // Filter bits
        using FB6 = Field<_F25R2, 6, 1>; // Filter bits
        using FB7 = Field<_F25R2, 7, 1>; // Filter bits
        using FB8 = Field<_F25R2, 8, 1>; // Filter bits
        using FB9 = Field<_F25R2, 9, 1>; // Filter bits
        using FB10 = Field<_F25R2, 10, 1>; // Filter bits
        using FB11 = Field<_F25R2, 11, 1>; // Filter bits
        using FB12 = Field<_F25R2, 12, 1>; // Filter bits
        using FB13 = Field<_F25R2, 13, 1>; // Filter bits
        using FB14 = Field<_F25R2, 14, 1>; // Filter bits
        using FB15 = Field<_F25R2, 15, 1>; // Filter bits
        using FB16 = Field<_F25R2, 16, 1>; // Filter bits
        using FB17 = Field<_F25R2, 17, 1>; // Filter bits
        using FB18 = Field<_F25R2, 18, 1>; // Filter bits
        using FB19 = Field<_F25R2, 19, 1>; // Filter bits
        using FB20 = Field<_F25R2, 20, 1>; // Filter bits
        using FB21 = Field<_F25R2, 21, 1>; // Filter bits
        using FB22 = Field<_F25R2, 22, 1>; // Filter bits
        using FB23 = Field<_F25R2, 23, 1>; // Filter bits
        using FB24 = Field<_F25R2, 24, 1>; // Filter bits
        using FB25 = Field<_F25R2, 25, 1>; // Filter bits
        using FB26 = Field<_F25R2, 26, 1>; // Filter bits
        using FB27 = Field<_F25R2, 27, 1>; // Filter bits
        using FB28 = Field<_F25R2, 28, 1>; // Filter bits
        using FB29 = Field<_F25R2, 29, 1>; // Filter bits
        using FB30 = Field<_F25R2, 30, 1>; // Filter bits
        using FB31 = Field<_F25R2, 31, 1>; // Filter bits
    };

    // Filter bank 26 register 1
    struct _F26R1 : Register<CAN1_BASE + 0x310, ReadWrite, _F26R1> {
        using FB0 = Field<_F26R1, 0, 1>; // Filter bits
        using FB1 = Field<_F26R1, 1, 1>; // Filter bits
        using FB2 = Field<_F26R1, 2, 1>; // Filter bits
        using FB3 = Field<_F26R1, 3, 1>; // Filter bits
        using FB4 = Field<_F26R1, 4, 1>; // Filter bits
        using FB5 = Field<_F26R1, 5, 1>; // Filter bits
        using FB6 = Field<_F26R1, 6, 1>; // Filter bits
        using FB7 = Field<_F26R1, 7, 1>; // Filter bits
        using FB8 = Field<_F26R1, 8, 1>; // Filter bits
        using FB9 = Field<_F26R1, 9, 1>; // Filter bits
        using FB10 = Field<_F26R1, 10, 1>; // Filter bits
        using FB11 = Field<_F26R1, 11, 1>; // Filter bits
        using FB12 = Field<_F26R1, 12, 1>; // Filter bits
        using FB13 = Field<_F26R1, 13, 1>; // Filter bits
        using FB14 = Field<_F26R1, 14, 1>; // Filter bits
        using FB15 = Field<_F26R1, 15, 1>; // Filter bits
        using FB16 = Field<_F26R1, 16, 1>; // Filter bits
        using FB17 = Field<_F26R1, 17, 1>; // Filter bits
        using FB18 = Field<_F26R1, 18, 1>; // Filter bits
        using FB19 = Field<_F26R1, 19, 1>; // Filter bits
        using FB20 = Field<_F26R1, 20, 1>; // Filter bits
        using FB21 = Field<_F26R1, 21, 1>; // Filter bits
        using FB22 = Field<_F26R1, 22, 1>; // Filter bits
        using FB23 = Field<_F26R1, 23, 1>; // Filter bits
        using FB24 = Field<_F26R1, 24, 1>; // Filter bits
        using FB25 = Field<_F26R1, 25, 1>; // Filter bits
        using FB26 = Field<_F26R1, 26, 1>; // Filter bits
        using FB27 = Field<_F26R1, 27, 1>; // Filter bits
        using FB28 = Field<_F26R1, 28, 1>; // Filter bits
        using FB29 = Field<_F26R1, 29, 1>; // Filter bits
        using FB30 = Field<_F26R1, 30, 1>; // Filter bits
        using FB31 = Field<_F26R1, 31, 1>; // Filter bits
    };

    // Filter bank 26 register 2
    struct _F26R2 : Register<CAN1_BASE + 0x314, ReadWrite, _F26R2> {
        using FB0 = Field<_F26R2, 0, 1>; // Filter bits
        using FB1 = Field<_F26R2, 1, 1>; // Filter bits
        using FB2 = Field<_F26R2, 2, 1>; // Filter bits
        using FB3 = Field<_F26R2, 3, 1>; // Filter bits
        using FB4 = Field<_F26R2, 4, 1>; // Filter bits
        using FB5 = Field<_F26R2, 5, 1>; // Filter bits
        using FB6 = Field<_F26R2, 6, 1>; // Filter bits
        using FB7 = Field<_F26R2, 7, 1>; // Filter bits
        using FB8 = Field<_F26R2, 8, 1>; // Filter bits
        using FB9 = Field<_F26R2, 9, 1>; // Filter bits
        using FB10 = Field<_F26R2, 10, 1>; // Filter bits
        using FB11 = Field<_F26R2, 11, 1>; // Filter bits
        using FB12 = Field<_F26R2, 12, 1>; // Filter bits
        using FB13 = Field<_F26R2, 13, 1>; // Filter bits
        using FB14 = Field<_F26R2, 14, 1>; // Filter bits
        using FB15 = Field<_F26R2, 15, 1>; // Filter bits
        using FB16 = Field<_F26R2, 16, 1>; // Filter bits
        using FB17 = Field<_F26R2, 17, 1>; // Filter bits
        using FB18 = Field<_F26R2, 18, 1>; // Filter bits
        using FB19 = Field<_F26R2, 19, 1>; // Filter bits
        using FB20 = Field<_F26R2, 20, 1>; // Filter bits
        using FB21 = Field<_F26R2, 21, 1>; // Filter bits
        using FB22 = Field<_F26R2, 22, 1>; // Filter bits
        using FB23 = Field<_F26R2, 23, 1>; // Filter bits
        using FB24 = Field<_F26R2, 24, 1>; // Filter bits
        using FB25 = Field<_F26R2, 25, 1>; // Filter bits
        using FB26 = Field<_F26R2, 26, 1>; // Filter bits
        using FB27 = Field<_F26R2, 27, 1>; // Filter bits
        using FB28 = Field<_F26R2, 28, 1>; // Filter bits
        using FB29 = Field<_F26R2, 29, 1>; // Filter bits
        using FB30 = Field<_F26R2, 30, 1>; // Filter bits
        using FB31 = Field<_F26R2, 31, 1>; // Filter bits
    };

    // Filter bank 27 register 1
    struct _F27R1 : Register<CAN1_BASE + 0x318, ReadWrite, _F27R1> {
        using FB0 = Field<_F27R1, 0, 1>; // Filter bits
        using FB1 = Field<_F27R1, 1, 1>; // Filter bits
        using FB2 = Field<_F27R1, 2, 1>; // Filter bits
        using FB3 = Field<_F27R1, 3, 1>; // Filter bits
        using FB4 = Field<_F27R1, 4, 1>; // Filter bits
        using FB5 = Field<_F27R1, 5, 1>; // Filter bits
        using FB6 = Field<_F27R1, 6, 1>; // Filter bits
        using FB7 = Field<_F27R1, 7, 1>; // Filter bits
        using FB8 = Field<_F27R1, 8, 1>; // Filter bits
        using FB9 = Field<_F27R1, 9, 1>; // Filter bits
        using FB10 = Field<_F27R1, 10, 1>; // Filter bits
        using FB11 = Field<_F27R1, 11, 1>; // Filter bits
        using FB12 = Field<_F27R1, 12, 1>; // Filter bits
        using FB13 = Field<_F27R1, 13, 1>; // Filter bits
        using FB14 = Field<_F27R1, 14, 1>; // Filter bits
        using FB15 = Field<_F27R1, 15, 1>; // Filter bits
        using FB16 = Field<_F27R1, 16, 1>; // Filter bits
        using FB17 = Field<_F27R1, 17, 1>; // Filter bits
        using FB18 = Field<_F27R1, 18, 1>; // Filter bits
        using FB19 = Field<_F27R1, 19, 1>; // Filter bits
        using FB20 = Field<_F27R1, 20, 1>; // Filter bits
        using FB21 = Field<_F27R1, 21, 1>; // Filter bits
        using FB22 = Field<_F27R1, 22, 1>; // Filter bits
        using FB23 = Field<_F27R1, 23, 1>; // Filter bits
        using FB24 = Field<_F27R1, 24, 1>; // Filter bits
        using FB25 = Field<_F27R1, 25, 1>; // Filter bits
        using FB26 = Field<_F27R1, 26, 1>; // Filter bits
        using FB27 = Field<_F27R1, 27, 1>; // Filter bits
        using FB28 = Field<_F27R1, 28, 1>; // Filter bits
        using FB29 = Field<_F27R1, 29, 1>; // Filter bits
        using FB30 = Field<_F27R1, 30, 1>; // Filter bits
        using FB31 = Field<_F27R1, 31, 1>; // Filter bits
    };

    // Filter bank 27 register 2
    struct _F27R2 : Register<CAN1_BASE + 0x31C, ReadWrite, _F27R2> {
        using FB0 = Field<_F27R2, 0, 1>; // Filter bits
        using FB1 = Field<_F27R2, 1, 1>; // Filter bits
        using FB2 = Field<_F27R2, 2, 1>; // Filter bits
        using FB3 = Field<_F27R2, 3, 1>; // Filter bits
        using FB4 = Field<_F27R2, 4, 1>; // Filter bits
        using FB5 = Field<_F27R2, 5, 1>; // Filter bits
        using FB6 = Field<_F27R2, 6, 1>; // Filter bits
        using FB7 = Field<_F27R2, 7, 1>; // Filter bits
        using FB8 = Field<_F27R2, 8, 1>; // Filter bits
        using FB9 = Field<_F27R2, 9, 1>; // Filter bits
        using FB10 = Field<_F27R2, 10, 1>; // Filter bits
        using FB11 = Field<_F27R2, 11, 1>; // Filter bits
        using FB12 = Field<_F27R2, 12, 1>; // Filter bits
        using FB13 = Field<_F27R2, 13, 1>; // Filter bits
        using FB14 = Field<_F27R2, 14, 1>; // Filter bits
        using FB15 = Field<_F27R2, 15, 1>; // Filter bits
        using FB16 = Field<_F27R2, 16, 1>; // Filter bits
        using FB17 = Field<_F27R2, 17, 1>; // Filter bits
        using FB18 = Field<_F27R2, 18, 1>; // Filter bits
        using FB19 = Field<_F27R2, 19, 1>; // Filter bits
        using FB20 = Field<_F27R2, 20, 1>; // Filter bits
        using FB21 = Field<_F27R2, 21, 1>; // Filter bits
        using FB22 = Field<_F27R2, 22, 1>; // Filter bits
        using FB23 = Field<_F27R2, 23, 1>; // Filter bits
        using FB24 = Field<_F27R2, 24, 1>; // Filter bits
        using FB25 = Field<_F27R2, 25, 1>; // Filter bits
        using FB26 = Field<_F27R2, 26, 1>; // Filter bits
        using FB27 = Field<_F27R2, 27, 1>; // Filter bits
        using FB28 = Field<_F27R2, 28, 1>; // Filter bits
        using FB29 = Field<_F27R2, 29, 1>; // Filter bits
        using FB30 = Field<_F27R2, 30, 1>; // Filter bits
        using FB31 = Field<_F27R2, 31, 1>; // Filter bits
    };

} // namespace CAN1

// --------------------------------------------
// CAN2: 
// Base address: 0x40006800
// --------------------------------------------

namespace CAN2 {
    static constexpr uint32_t CAN2_BASE = 0x40006800;

} // namespace CAN2

// --------------------------------------------
// CAN3: 
// Base address: 0x40003400
// --------------------------------------------

namespace CAN3 {
    static constexpr uint32_t CAN3_BASE = 0x40003400;

} // namespace CAN3

// --------------------------------------------
// Flash: FLASH
// Base address: 0x40023C00
// --------------------------------------------

namespace Flash {
    static constexpr uint32_t Flash_BASE = 0x40023C00;

    // Flash access control register
    struct _ACR : Register<Flash_BASE + 0x0, ReadWrite, _ACR> {
        using LATENCY = Field<_ACR, 0, 4>; // Latency
        using PRFTEN = Field<_ACR, 8, 1>; // Prefetch enable
        using ARTEN = Field<_ACR, 9, 1>; // ART Accelerator Enable
        using ARTRST = Field<_ACR, 11, 1>; // ART Accelerator reset
    };

    // Flash key register
    struct _KEYR : Register<Flash_BASE + 0x4, WriteOnly, _KEYR> {
        using KEY = Field<_KEYR, 0, 32>; // FPEC key
    };

    // Flash option key register
    struct _OPTKEYR : Register<Flash_BASE + 0x8, WriteOnly, _OPTKEYR> {
        using OPTKEY = Field<_OPTKEYR, 0, 32>; // Option byte key
    };

    // Status register
    struct _SR : Register<Flash_BASE + 0xC, ReadWrite, _SR> {
        using EOP = Field<_SR, 0, 1>; // End of operation
        using OPERR = Field<_SR, 1, 1>; // Operation error
        using WRPERR = Field<_SR, 4, 1>; // Write protection error
        using PGAERR = Field<_SR, 5, 1>; // Programming alignment error
        using PGPERR = Field<_SR, 6, 1>; // Programming parallelism error
        using PGSERR = Field<_SR, 7, 1>; // Programming sequence error
        using BSY = Field<_SR, 16, 1>; // Busy
    };

    // Control register
    struct _CR : Register<Flash_BASE + 0x10, ReadWrite, _CR> {
        using PG = Field<_CR, 0, 1>; // Programming
        using SER = Field<_CR, 1, 1>; // Sector Erase
        using MER = Field<_CR, 2, 1>; // Mass Erase of sectors 0 to 11
        using SNB = Field<_CR, 3, 5>; // Sector number
        using PSIZE = Field<_CR, 8, 2>; // Program size
        using MER1 = Field<_CR, 15, 1>; // Mass Erase of sectors 12 to 23
        using STRT = Field<_CR, 16, 1>; // Start
        using EOPIE = Field<_CR, 24, 1>; // End of operation interrupt enable
        using ERRIE = Field<_CR, 25, 1>; // Error interrupt enable
        using LOCK = Field<_CR, 31, 1>; // Lock
    };

    // Flash option control register
    struct _OPTCR : Register<Flash_BASE + 0x14, ReadWrite, _OPTCR> {
        using OPTLOCK = Field<_OPTCR, 0, 1>; // Option lock
        using OPTSTRT = Field<_OPTCR, 1, 1>; // Option start
        using BOR_LEV = Field<_OPTCR, 2, 2>; // BOR reset Level
        using WWDG_SW = Field<_OPTCR, 4, 1>; // User option bytes
        using IWDG_SW = Field<_OPTCR, 5, 1>; // User option bytes
        using nRST_STOP = Field<_OPTCR, 6, 1>; // User option bytes
        using nRST_STDBY = Field<_OPTCR, 7, 1>; // User option bytes
        using RDP = Field<_OPTCR, 8, 8>; // Read protect
        using nWRP = Field<_OPTCR, 16, 12>; // Not write protect
        using nDBOOT = Field<_OPTCR, 28, 1>; // Dual Boot mode (valid only when nDBANK=0)
        using nDBANK = Field<_OPTCR, 29, 1>; // Not dual bank mode
        using IWDG_STDBY = Field<_OPTCR, 30, 1>; // Independent watchdog counter freeze in standby mode
        using IWDG_STOP = Field<_OPTCR, 31, 1>; // Independent watchdog counter freeze in Stop mode
    };

    // Flash option control register 1
    struct _OPTCR1 : Register<Flash_BASE + 0x18, ReadWrite, _OPTCR1> {
        using BOOT_ADD0 = Field<_OPTCR1, 0, 16>; // Boot base address when Boot pin =0
        using BOOT_ADD1 = Field<_OPTCR1, 16, 16>; // Boot base address when Boot pin =1
    };

} // namespace Flash

// --------------------------------------------
// EXTI: External interrupt/event controller
// Base address: 0x40013C00
// --------------------------------------------

namespace EXTI {
    static constexpr uint32_t EXTI_BASE = 0x40013C00;

    // Interrupt mask register (EXTI_IMR)
    struct _IMR : Register<EXTI_BASE + 0x0, ReadWrite, _IMR> {
        using MR0 = Field<_IMR, 0, 1>; // Interrupt Mask on line 0
        using MR1 = Field<_IMR, 1, 1>; // Interrupt Mask on line 1
        using MR2 = Field<_IMR, 2, 1>; // Interrupt Mask on line 2
        using MR3 = Field<_IMR, 3, 1>; // Interrupt Mask on line 3
        using MR4 = Field<_IMR, 4, 1>; // Interrupt Mask on line 4
        using MR5 = Field<_IMR, 5, 1>; // Interrupt Mask on line 5
        using MR6 = Field<_IMR, 6, 1>; // Interrupt Mask on line 6
        using MR7 = Field<_IMR, 7, 1>; // Interrupt Mask on line 7
        using MR8 = Field<_IMR, 8, 1>; // Interrupt Mask on line 8
        using MR9 = Field<_IMR, 9, 1>; // Interrupt Mask on line 9
        using MR10 = Field<_IMR, 10, 1>; // Interrupt Mask on line 10
        using MR11 = Field<_IMR, 11, 1>; // Interrupt Mask on line 11
        using MR12 = Field<_IMR, 12, 1>; // Interrupt Mask on line 12
        using MR13 = Field<_IMR, 13, 1>; // Interrupt Mask on line 13
        using MR14 = Field<_IMR, 14, 1>; // Interrupt Mask on line 14
        using MR15 = Field<_IMR, 15, 1>; // Interrupt Mask on line 15
        using MR16 = Field<_IMR, 16, 1>; // Interrupt Mask on line 16
        using MR17 = Field<_IMR, 17, 1>; // Interrupt Mask on line 17
        using MR18 = Field<_IMR, 18, 1>; // Interrupt Mask on line 18
        using MR19 = Field<_IMR, 19, 1>; // Interrupt Mask on line 19
        using MR20 = Field<_IMR, 20, 1>; // Interrupt Mask on line 20
        using MR21 = Field<_IMR, 21, 1>; // Interrupt Mask on line 21
        using MR22 = Field<_IMR, 22, 1>; // Interrupt Mask on line 22
    };

    // Event mask register (EXTI_EMR)
    struct _EMR : Register<EXTI_BASE + 0x4, ReadWrite, _EMR> {
        using MR0 = Field<_EMR, 0, 1>; // Event Mask on line 0
        using MR1 = Field<_EMR, 1, 1>; // Event Mask on line 1
        using MR2 = Field<_EMR, 2, 1>; // Event Mask on line 2
        using MR3 = Field<_EMR, 3, 1>; // Event Mask on line 3
        using MR4 = Field<_EMR, 4, 1>; // Event Mask on line 4
        using MR5 = Field<_EMR, 5, 1>; // Event Mask on line 5
        using MR6 = Field<_EMR, 6, 1>; // Event Mask on line 6
        using MR7 = Field<_EMR, 7, 1>; // Event Mask on line 7
        using MR8 = Field<_EMR, 8, 1>; // Event Mask on line 8
        using MR9 = Field<_EMR, 9, 1>; // Event Mask on line 9
        using MR10 = Field<_EMR, 10, 1>; // Event Mask on line 10
        using MR11 = Field<_EMR, 11, 1>; // Event Mask on line 11
        using MR12 = Field<_EMR, 12, 1>; // Event Mask on line 12
        using MR13 = Field<_EMR, 13, 1>; // Event Mask on line 13
        using MR14 = Field<_EMR, 14, 1>; // Event Mask on line 14
        using MR15 = Field<_EMR, 15, 1>; // Event Mask on line 15
        using MR16 = Field<_EMR, 16, 1>; // Event Mask on line 16
        using MR17 = Field<_EMR, 17, 1>; // Event Mask on line 17
        using MR18 = Field<_EMR, 18, 1>; // Event Mask on line 18
        using MR19 = Field<_EMR, 19, 1>; // Event Mask on line 19
        using MR20 = Field<_EMR, 20, 1>; // Event Mask on line 20
        using MR21 = Field<_EMR, 21, 1>; // Event Mask on line 21
        using MR22 = Field<_EMR, 22, 1>; // Event Mask on line 22
    };

    // Rising Trigger selection register (EXTI_RTSR)
    struct _RTSR : Register<EXTI_BASE + 0x8, ReadWrite, _RTSR> {
        using TR0 = Field<_RTSR, 0, 1>; // Rising trigger event configuration of line 0
        using TR1 = Field<_RTSR, 1, 1>; // Rising trigger event configuration of line 1
        using TR2 = Field<_RTSR, 2, 1>; // Rising trigger event configuration of line 2
        using TR3 = Field<_RTSR, 3, 1>; // Rising trigger event configuration of line 3
        using TR4 = Field<_RTSR, 4, 1>; // Rising trigger event configuration of line 4
        using TR5 = Field<_RTSR, 5, 1>; // Rising trigger event configuration of line 5
        using TR6 = Field<_RTSR, 6, 1>; // Rising trigger event configuration of line 6
        using TR7 = Field<_RTSR, 7, 1>; // Rising trigger event configuration of line 7
        using TR8 = Field<_RTSR, 8, 1>; // Rising trigger event configuration of line 8
        using TR9 = Field<_RTSR, 9, 1>; // Rising trigger event configuration of line 9
        using TR10 = Field<_RTSR, 10, 1>; // Rising trigger event configuration of line 10
        using TR11 = Field<_RTSR, 11, 1>; // Rising trigger event configuration of line 11
        using TR12 = Field<_RTSR, 12, 1>; // Rising trigger event configuration of line 12
        using TR13 = Field<_RTSR, 13, 1>; // Rising trigger event configuration of line 13
        using TR14 = Field<_RTSR, 14, 1>; // Rising trigger event configuration of line 14
        using TR15 = Field<_RTSR, 15, 1>; // Rising trigger event configuration of line 15
        using TR16 = Field<_RTSR, 16, 1>; // Rising trigger event configuration of line 16
        using TR17 = Field<_RTSR, 17, 1>; // Rising trigger event configuration of line 17
        using TR18 = Field<_RTSR, 18, 1>; // Rising trigger event configuration of line 18
        using TR19 = Field<_RTSR, 19, 1>; // Rising trigger event configuration of line 19
        using TR20 = Field<_RTSR, 20, 1>; // Rising trigger event configuration of line 20
        using TR21 = Field<_RTSR, 21, 1>; // Rising trigger event configuration of line 21
        using TR22 = Field<_RTSR, 22, 1>; // Rising trigger event configuration of line 22
    };

    // Falling Trigger selection register (EXTI_FTSR)
    struct _FTSR : Register<EXTI_BASE + 0xC, ReadWrite, _FTSR> {
        using TR0 = Field<_FTSR, 0, 1>; // Falling trigger event configuration of line 0
        using TR1 = Field<_FTSR, 1, 1>; // Falling trigger event configuration of line 1
        using TR2 = Field<_FTSR, 2, 1>; // Falling trigger event configuration of line 2
        using TR3 = Field<_FTSR, 3, 1>; // Falling trigger event configuration of line 3
        using TR4 = Field<_FTSR, 4, 1>; // Falling trigger event configuration of line 4
        using TR5 = Field<_FTSR, 5, 1>; // Falling trigger event configuration of line 5
        using TR6 = Field<_FTSR, 6, 1>; // Falling trigger event configuration of line 6
        using TR7 = Field<_FTSR, 7, 1>; // Falling trigger event configuration of line 7
        using TR8 = Field<_FTSR, 8, 1>; // Falling trigger event configuration of line 8
        using TR9 = Field<_FTSR, 9, 1>; // Falling trigger event configuration of line 9
        using TR10 = Field<_FTSR, 10, 1>; // Falling trigger event configuration of line 10
        using TR11 = Field<_FTSR, 11, 1>; // Falling trigger event configuration of line 11
        using TR12 = Field<_FTSR, 12, 1>; // Falling trigger event configuration of line 12
        using TR13 = Field<_FTSR, 13, 1>; // Falling trigger event configuration of line 13
        using TR14 = Field<_FTSR, 14, 1>; // Falling trigger event configuration of line 14
        using TR15 = Field<_FTSR, 15, 1>; // Falling trigger event configuration of line 15
        using TR16 = Field<_FTSR, 16, 1>; // Falling trigger event configuration of line 16
        using TR17 = Field<_FTSR, 17, 1>; // Falling trigger event configuration of line 17
        using TR18 = Field<_FTSR, 18, 1>; // Falling trigger event configuration of line 18
        using TR19 = Field<_FTSR, 19, 1>; // Falling trigger event configuration of line 19
        using TR20 = Field<_FTSR, 20, 1>; // Falling trigger event configuration of line 20
        using TR21 = Field<_FTSR, 21, 1>; // Falling trigger event configuration of line 21
        using TR22 = Field<_FTSR, 22, 1>; // Falling trigger event configuration of line 22
    };

    // Software interrupt event register (EXTI_SWIER)
    struct _SWIER : Register<EXTI_BASE + 0x10, ReadWrite, _SWIER> {
        using SWIER0 = Field<_SWIER, 0, 1>; // Software Interrupt on line 0
        using SWIER1 = Field<_SWIER, 1, 1>; // Software Interrupt on line 1
        using SWIER2 = Field<_SWIER, 2, 1>; // Software Interrupt on line 2
        using SWIER3 = Field<_SWIER, 3, 1>; // Software Interrupt on line 3
        using SWIER4 = Field<_SWIER, 4, 1>; // Software Interrupt on line 4
        using SWIER5 = Field<_SWIER, 5, 1>; // Software Interrupt on line 5
        using SWIER6 = Field<_SWIER, 6, 1>; // Software Interrupt on line 6
        using SWIER7 = Field<_SWIER, 7, 1>; // Software Interrupt on line 7
        using SWIER8 = Field<_SWIER, 8, 1>; // Software Interrupt on line 8
        using SWIER9 = Field<_SWIER, 9, 1>; // Software Interrupt on line 9
        using SWIER10 = Field<_SWIER, 10, 1>; // Software Interrupt on line 10
        using SWIER11 = Field<_SWIER, 11, 1>; // Software Interrupt on line 11
        using SWIER12 = Field<_SWIER, 12, 1>; // Software Interrupt on line 12
        using SWIER13 = Field<_SWIER, 13, 1>; // Software Interrupt on line 13
        using SWIER14 = Field<_SWIER, 14, 1>; // Software Interrupt on line 14
        using SWIER15 = Field<_SWIER, 15, 1>; // Software Interrupt on line 15
        using SWIER16 = Field<_SWIER, 16, 1>; // Software Interrupt on line 16
        using SWIER17 = Field<_SWIER, 17, 1>; // Software Interrupt on line 17
        using SWIER18 = Field<_SWIER, 18, 1>; // Software Interrupt on line 18
        using SWIER19 = Field<_SWIER, 19, 1>; // Software Interrupt on line 19
        using SWIER20 = Field<_SWIER, 20, 1>; // Software Interrupt on line 20
        using SWIER21 = Field<_SWIER, 21, 1>; // Software Interrupt on line 21
        using SWIER22 = Field<_SWIER, 22, 1>; // Software Interrupt on line 22
    };

    // Pending register (EXTI_PR)
    struct _PR : Register<EXTI_BASE + 0x14, ReadWrite, _PR> {
        using PR0 = Field<_PR, 0, 1>; // Pending bit 0
        using PR1 = Field<_PR, 1, 1>; // Pending bit 1
        using PR2 = Field<_PR, 2, 1>; // Pending bit 2
        using PR3 = Field<_PR, 3, 1>; // Pending bit 3
        using PR4 = Field<_PR, 4, 1>; // Pending bit 4
        using PR5 = Field<_PR, 5, 1>; // Pending bit 5
        using PR6 = Field<_PR, 6, 1>; // Pending bit 6
        using PR7 = Field<_PR, 7, 1>; // Pending bit 7
        using PR8 = Field<_PR, 8, 1>; // Pending bit 8
        using PR9 = Field<_PR, 9, 1>; // Pending bit 9
        using PR10 = Field<_PR, 10, 1>; // Pending bit 10
        using PR11 = Field<_PR, 11, 1>; // Pending bit 11
        using PR12 = Field<_PR, 12, 1>; // Pending bit 12
        using PR13 = Field<_PR, 13, 1>; // Pending bit 13
        using PR14 = Field<_PR, 14, 1>; // Pending bit 14
        using PR15 = Field<_PR, 15, 1>; // Pending bit 15
        using PR16 = Field<_PR, 16, 1>; // Pending bit 16
        using PR17 = Field<_PR, 17, 1>; // Pending bit 17
        using PR18 = Field<_PR, 18, 1>; // Pending bit 18
        using PR19 = Field<_PR, 19, 1>; // Pending bit 19
        using PR20 = Field<_PR, 20, 1>; // Pending bit 20
        using PR21 = Field<_PR, 21, 1>; // Pending bit 21
        using PR22 = Field<_PR, 22, 1>; // Pending bit 22
    };

} // namespace EXTI

// --------------------------------------------
// LTCD: LCD-TFT Controller
// Base address: 0x40016800
// --------------------------------------------

namespace LTCD {
    static constexpr uint32_t LTCD_BASE = 0x40016800;

    // Synchronization Size Configuration Register
    struct _SSCR : Register<LTCD_BASE + 0x8, ReadWrite, _SSCR> {
        using HSW = Field<_SSCR, 16, 10>; // Horizontal Synchronization Width (in units of pixel clock period)
        using VSH = Field<_SSCR, 0, 11>; // Vertical Synchronization Height (in units of horizontal scan line)
    };

    // Back Porch Configuration Register
    struct _BPCR : Register<LTCD_BASE + 0xC, ReadWrite, _BPCR> {
        using AHBP = Field<_BPCR, 16, 10>; // Accumulated Horizontal back porch (in units of pixel clock period)
        using AVBP = Field<_BPCR, 0, 11>; // Accumulated Vertical back porch (in units of horizontal scan line)
    };

    // Active Width Configuration Register
    struct _AWCR : Register<LTCD_BASE + 0x10, ReadWrite, _AWCR> {
        using AAV = Field<_AWCR, 16, 10>; // AAV
        using AAH = Field<_AWCR, 0, 11>; // Accumulated Active Height (in units of horizontal scan line)
    };

    // Total Width Configuration Register
    struct _TWCR : Register<LTCD_BASE + 0x14, ReadWrite, _TWCR> {
        using TOTALW = Field<_TWCR, 16, 10>; // Total Width (in units of pixel clock period)
        using TOTALH = Field<_TWCR, 0, 11>; // Total Height (in units of horizontal scan line)
    };

    // Global Control Register
    struct _GCR : Register<LTCD_BASE + 0x18, ReadWrite, _GCR> {
        using HSPOL = Field<_GCR, 31, 1>; // Horizontal Synchronization Polarity
        using VSPOL = Field<_GCR, 30, 1>; // Vertical Synchronization Polarity
        using DEPOL = Field<_GCR, 29, 1>; // Data Enable Polarity
        using PCPOL = Field<_GCR, 28, 1>; // Pixel Clock Polarity
        using DEN = Field<_GCR, 16, 1>; // Dither Enable
        using DRW = Field<_GCR, 12, 3>; // Dither Red Width
        using DGW = Field<_GCR, 8, 3>; // Dither Green Width
        using DBW = Field<_GCR, 4, 3>; // Dither Blue Width
        using LTDCEN = Field<_GCR, 0, 1>; // LCD-TFT controller enable bit
    };

    // Shadow Reload Configuration Register
    struct _SRCR : Register<LTCD_BASE + 0x24, ReadWrite, _SRCR> {
        using VBR = Field<_SRCR, 1, 1>; // Vertical Blanking Reload
        using IMR = Field<_SRCR, 0, 1>; // Immediate Reload
    };

    // Background Color Configuration Register
    struct _BCCR : Register<LTCD_BASE + 0x2C, ReadWrite, _BCCR> {
        using BC = Field<_BCCR, 0, 24>; // Background Color Red value
    };

    // Interrupt Enable Register
    struct _IER : Register<LTCD_BASE + 0x34, ReadWrite, _IER> {
        using RRIE = Field<_IER, 3, 1>; // Register Reload interrupt enable
        using TERRIE = Field<_IER, 2, 1>; // Transfer Error Interrupt Enable
        using FUIE = Field<_IER, 1, 1>; // FIFO Underrun Interrupt Enable
        using LIE = Field<_IER, 0, 1>; // Line Interrupt Enable
    };

    // Interrupt Status Register
    struct _ISR : Register<LTCD_BASE + 0x38, ReadOnly, _ISR> {
        using RRIF = Field<_ISR, 3, 1>; // Register Reload Interrupt Flag
        using TERRIF = Field<_ISR, 2, 1>; // Transfer Error interrupt flag
        using FUIF = Field<_ISR, 1, 1>; // FIFO Underrun Interrupt flag
        using LIF = Field<_ISR, 0, 1>; // Line Interrupt flag
    };

    // Interrupt Clear Register
    struct _ICR : Register<LTCD_BASE + 0x3C, WriteOnly, _ICR> {
        using CRRIF = Field<_ICR, 3, 1>; // Clears Register Reload Interrupt Flag
        using CTERRIF = Field<_ICR, 2, 1>; // Clears the Transfer Error Interrupt Flag
        using CFUIF = Field<_ICR, 1, 1>; // Clears the FIFO Underrun Interrupt flag
        using CLIF = Field<_ICR, 0, 1>; // Clears the Line Interrupt Flag
    };

    // Line Interrupt Position Configuration Register
    struct _LIPCR : Register<LTCD_BASE + 0x40, ReadWrite, _LIPCR> {
        using LIPOS = Field<_LIPCR, 0, 11>; // Line Interrupt Position
    };

    // Current Position Status Register
    struct _CPSR : Register<LTCD_BASE + 0x44, ReadOnly, _CPSR> {
        using CXPOS = Field<_CPSR, 16, 16>; // Current X Position
        using CYPOS = Field<_CPSR, 0, 16>; // Current Y Position
    };

    // Current Display Status Register
    struct _CDSR : Register<LTCD_BASE + 0x48, ReadOnly, _CDSR> {
        using HSYNCS = Field<_CDSR, 3, 1>; // Horizontal Synchronization display Status
        using VSYNCS = Field<_CDSR, 2, 1>; // Vertical Synchronization display Status
        using HDES = Field<_CDSR, 1, 1>; // Horizontal Data Enable display Status
        using VDES = Field<_CDSR, 0, 1>; // Vertical Data Enable display Status
    };

    // Layerx Control Register
    struct _L1CR : Register<LTCD_BASE + 0x84, ReadWrite, _L1CR> {
        using CLUTEN = Field<_L1CR, 4, 1>; // Color Look-Up Table Enable
        using COLKEN = Field<_L1CR, 1, 1>; // Color Keying Enable
        using LEN = Field<_L1CR, 0, 1>; // Layer Enable
    };

    // Layerx Window Horizontal Position Configuration Register
    struct _L1WHPCR : Register<LTCD_BASE + 0x88, ReadWrite, _L1WHPCR> {
        using WHSPPOS = Field<_L1WHPCR, 16, 12>; // Window Horizontal Stop Position
        using WHSTPOS = Field<_L1WHPCR, 0, 12>; // Window Horizontal Start Position
    };

    // Layerx Window Vertical Position Configuration Register
    struct _L1WVPCR : Register<LTCD_BASE + 0x8C, ReadWrite, _L1WVPCR> {
        using WVSPPOS = Field<_L1WVPCR, 16, 11>; // Window Vertical Stop Position
        using WVSTPOS = Field<_L1WVPCR, 0, 11>; // Window Vertical Start Position
    };

    // Layerx Color Keying Configuration Register
    struct _L1CKCR : Register<LTCD_BASE + 0x90, ReadWrite, _L1CKCR> {
        using CKRED = Field<_L1CKCR, 16, 8>; // Color Key Red value
        using CKGREEN = Field<_L1CKCR, 8, 8>; // Color Key Green value
        using CKBLUE = Field<_L1CKCR, 0, 8>; // Color Key Blue value
    };

    // Layerx Pixel Format Configuration Register
    struct _L1PFCR : Register<LTCD_BASE + 0x94, ReadWrite, _L1PFCR> {
        using PF = Field<_L1PFCR, 0, 3>; // Pixel Format
    };

    // Layerx Constant Alpha Configuration Register
    struct _L1CACR : Register<LTCD_BASE + 0x98, ReadWrite, _L1CACR> {
        using CONSTA = Field<_L1CACR, 0, 8>; // Constant Alpha
    };

    // Layerx Default Color Configuration Register
    struct _L1DCCR : Register<LTCD_BASE + 0x9C, ReadWrite, _L1DCCR> {
        using DCALPHA = Field<_L1DCCR, 24, 8>; // Default Color Alpha
        using DCRED = Field<_L1DCCR, 16, 8>; // Default Color Red
        using DCGREEN = Field<_L1DCCR, 8, 8>; // Default Color Green
        using DCBLUE = Field<_L1DCCR, 0, 8>; // Default Color Blue
    };

    // Layerx Blending Factors Configuration Register
    struct _L1BFCR : Register<LTCD_BASE + 0xA0, ReadWrite, _L1BFCR> {
        using BF1 = Field<_L1BFCR, 8, 3>; // Blending Factor 1
        using BF2 = Field<_L1BFCR, 0, 3>; // Blending Factor 2
    };

    // Layerx Color Frame Buffer Address Register
    struct _L1CFBAR : Register<LTCD_BASE + 0xAC, ReadWrite, _L1CFBAR> {
        using CFBADD = Field<_L1CFBAR, 0, 32>; // Color Frame Buffer Start Address
    };

    // Layerx Color Frame Buffer Length Register
    struct _L1CFBLR : Register<LTCD_BASE + 0xB0, ReadWrite, _L1CFBLR> {
        using CFBP = Field<_L1CFBLR, 16, 13>; // Color Frame Buffer Pitch in bytes
        using CFBLL = Field<_L1CFBLR, 0, 13>; // Color Frame Buffer Line Length
    };

    // Layerx ColorFrame Buffer Line Number Register
    struct _L1CFBLNR : Register<LTCD_BASE + 0xB4, ReadWrite, _L1CFBLNR> {
        using CFBLNBR = Field<_L1CFBLNR, 0, 11>; // Frame Buffer Line Number
    };

    // Layerx CLUT Write Register
    struct _L1CLUTWR : Register<LTCD_BASE + 0xC4, WriteOnly, _L1CLUTWR> {
        using CLUTADD = Field<_L1CLUTWR, 24, 8>; // CLUT Address
        using RED = Field<_L1CLUTWR, 16, 8>; // Red value
        using GREEN = Field<_L1CLUTWR, 8, 8>; // Green value
        using BLUE = Field<_L1CLUTWR, 0, 8>; // Blue value
    };

    // Layerx Control Register
    struct _L2CR : Register<LTCD_BASE + 0x104, ReadWrite, _L2CR> {
        using CLUTEN = Field<_L2CR, 4, 1>; // Color Look-Up Table Enable
        using COLKEN = Field<_L2CR, 1, 1>; // Color Keying Enable
        using LEN = Field<_L2CR, 0, 1>; // Layer Enable
    };

    // Layerx Window Horizontal Position Configuration Register
    struct _L2WHPCR : Register<LTCD_BASE + 0x108, ReadWrite, _L2WHPCR> {
        using WHSPPOS = Field<_L2WHPCR, 16, 12>; // Window Horizontal Stop Position
        using WHSTPOS = Field<_L2WHPCR, 0, 12>; // Window Horizontal Start Position
    };

    // Layerx Window Vertical Position Configuration Register
    struct _L2WVPCR : Register<LTCD_BASE + 0x10C, ReadWrite, _L2WVPCR> {
        using WVSPPOS = Field<_L2WVPCR, 16, 11>; // Window Vertical Stop Position
        using WVSTPOS = Field<_L2WVPCR, 0, 11>; // Window Vertical Start Position
    };

    // Layerx Color Keying Configuration Register
    struct _L2CKCR : Register<LTCD_BASE + 0x110, ReadWrite, _L2CKCR> {
        using CKRED = Field<_L2CKCR, 15, 9>; // Color Key Red value
        using CKGREEN = Field<_L2CKCR, 8, 7>; // Color Key Green value
        using CKBLUE = Field<_L2CKCR, 0, 8>; // Color Key Blue value
    };

    // Layerx Pixel Format Configuration Register
    struct _L2PFCR : Register<LTCD_BASE + 0x114, ReadWrite, _L2PFCR> {
        using PF = Field<_L2PFCR, 0, 3>; // Pixel Format
    };

    // Layerx Constant Alpha Configuration Register
    struct _L2CACR : Register<LTCD_BASE + 0x118, ReadWrite, _L2CACR> {
        using CONSTA = Field<_L2CACR, 0, 8>; // Constant Alpha
    };

    // Layerx Default Color Configuration Register
    struct _L2DCCR : Register<LTCD_BASE + 0x11C, ReadWrite, _L2DCCR> {
        using DCALPHA = Field<_L2DCCR, 24, 8>; // Default Color Alpha
        using DCRED = Field<_L2DCCR, 16, 8>; // Default Color Red
        using DCGREEN = Field<_L2DCCR, 8, 8>; // Default Color Green
        using DCBLUE = Field<_L2DCCR, 0, 8>; // Default Color Blue
    };

    // Layerx Blending Factors Configuration Register
    struct _L2BFCR : Register<LTCD_BASE + 0x120, ReadWrite, _L2BFCR> {
        using BF1 = Field<_L2BFCR, 8, 3>; // Blending Factor 1
        using BF2 = Field<_L2BFCR, 0, 3>; // Blending Factor 2
    };

    // Layerx Color Frame Buffer Address Register
    struct _L2CFBAR : Register<LTCD_BASE + 0x12C, ReadWrite, _L2CFBAR> {
        using CFBADD = Field<_L2CFBAR, 0, 32>; // Color Frame Buffer Start Address
    };

    // Layerx Color Frame Buffer Length Register
    struct _L2CFBLR : Register<LTCD_BASE + 0x130, ReadWrite, _L2CFBLR> {
        using CFBP = Field<_L2CFBLR, 16, 13>; // Color Frame Buffer Pitch in bytes
        using CFBLL = Field<_L2CFBLR, 0, 13>; // Color Frame Buffer Line Length
    };

    // Layerx ColorFrame Buffer Line Number Register
    struct _L2CFBLNR : Register<LTCD_BASE + 0x134, ReadWrite, _L2CFBLNR> {
        using CFBLNBR = Field<_L2CFBLNR, 0, 11>; // Frame Buffer Line Number
    };

    // Layerx CLUT Write Register
    struct _L2CLUTWR : Register<LTCD_BASE + 0x144, WriteOnly, _L2CLUTWR> {
        using CLUTADD = Field<_L2CLUTWR, 24, 8>; // CLUT Address
        using RED = Field<_L2CLUTWR, 16, 8>; // Red value
        using GREEN = Field<_L2CLUTWR, 8, 8>; // Green value
        using BLUE = Field<_L2CLUTWR, 0, 8>; // Blue value
    };

} // namespace LTCD

// --------------------------------------------
// SAI1: Serial audio interface
// Base address: 0x40015800
// --------------------------------------------

namespace SAI1 {
    static constexpr uint32_t SAI1_BASE = 0x40015800;

    // BConfiguration register 1
    struct _BCR1 : Register<SAI1_BASE + 0x24, ReadWrite, _BCR1> {
        using MCKDIV = Field<_BCR1, 20, 4>; // Master clock divider
        using NODIV = Field<_BCR1, 19, 1>; // No divider
        using DMAEN = Field<_BCR1, 17, 1>; // DMA enable
        using SAIBEN = Field<_BCR1, 16, 1>; // Audio block B enable
        using OutDri = Field<_BCR1, 13, 1>; // Output drive
        using MONO = Field<_BCR1, 12, 1>; // Mono mode
        using SYNCEN = Field<_BCR1, 10, 2>; // Synchronization enable
        using CKSTR = Field<_BCR1, 9, 1>; // Clock strobing edge
        using LSBFIRST = Field<_BCR1, 8, 1>; // Least significant bit first
        using DS = Field<_BCR1, 5, 3>; // Data size
        using PRTCFG = Field<_BCR1, 2, 2>; // Protocol configuration
        using MODE = Field<_BCR1, 0, 2>; // Audio block mode
    };

    // BConfiguration register 2
    struct _BCR2 : Register<SAI1_BASE + 0x28, ReadWrite, _BCR2> {
        using COMP = Field<_BCR2, 14, 2>; // Companding mode
        using CPL = Field<_BCR2, 13, 1>; // Complement bit
        using MUTECN = Field<_BCR2, 7, 6>; // Mute counter
        using MUTEVAL = Field<_BCR2, 6, 1>; // Mute value
        using MUTE = Field<_BCR2, 5, 1>; // Mute
        using TRIS = Field<_BCR2, 4, 1>; // Tristate management on data line
        using FFLUS = Field<_BCR2, 3, 1>; // FIFO flush
        using FTH = Field<_BCR2, 0, 3>; // FIFO threshold
    };

    // BFRCR
    struct _BFRCR : Register<SAI1_BASE + 0x2C, ReadWrite, _BFRCR> {
        using FSOFF = Field<_BFRCR, 18, 1>; // Frame synchronization offset
        using FSPOL = Field<_BFRCR, 17, 1>; // Frame synchronization polarity
        using FSDEF = Field<_BFRCR, 16, 1>; // Frame synchronization definition
        using FSALL = Field<_BFRCR, 8, 7>; // Frame synchronization active level length
        using FRL = Field<_BFRCR, 0, 8>; // Frame length
    };

    // BSlot register
    struct _BSLOTR : Register<SAI1_BASE + 0x30, ReadWrite, _BSLOTR> {
        using SLOTEN = Field<_BSLOTR, 16, 16>; // Slot enable
        using NBSLOT = Field<_BSLOTR, 8, 4>; // Number of slots in an audio frame
        using SLOTSZ = Field<_BSLOTR, 6, 2>; // Slot size
        using FBOFF = Field<_BSLOTR, 0, 5>; // First bit offset
    };

    // BInterrupt mask register2
    struct _BIM : Register<SAI1_BASE + 0x34, ReadWrite, _BIM> {
        using LFSDETIE = Field<_BIM, 6, 1>; // Late frame synchronization detection interrupt enable
        using AFSDETIE = Field<_BIM, 5, 1>; // Anticipated frame synchronization detection interrupt enable
        using CNRDYIE = Field<_BIM, 4, 1>; // Codec not ready interrupt enable
        using FREQIE = Field<_BIM, 3, 1>; // FIFO request interrupt enable
        using WCKCFG = Field<_BIM, 2, 1>; // Wrong clock configuration interrupt enable
        using MUTEDET = Field<_BIM, 1, 1>; // Mute detection interrupt enable
        using OVRUDRIE = Field<_BIM, 0, 1>; // Overrun/underrun interrupt enable
    };

    // BStatus register
    struct _BSR : Register<SAI1_BASE + 0x38, ReadOnly, _BSR> {
        using FLVL = Field<_BSR, 16, 3>; // FIFO level threshold
        using LFSDET = Field<_BSR, 6, 1>; // Late frame synchronization detection
        using AFSDET = Field<_BSR, 5, 1>; // Anticipated frame synchronization detection
        using CNRDY = Field<_BSR, 4, 1>; // Codec not ready
        using FREQ = Field<_BSR, 3, 1>; // FIFO request
        using WCKCFG = Field<_BSR, 2, 1>; // Wrong clock configuration flag
        using MUTEDET = Field<_BSR, 1, 1>; // Mute detection
        using OVRUDR = Field<_BSR, 0, 1>; // Overrun / underrun
    };

    // BClear flag register
    struct _BCLRFR : Register<SAI1_BASE + 0x3C, WriteOnly, _BCLRFR> {
        using LFSDET = Field<_BCLRFR, 6, 1>; // Clear late frame synchronization detection flag
        using CAFSDET = Field<_BCLRFR, 5, 1>; // Clear anticipated frame synchronization detection flag
        using CNRDY = Field<_BCLRFR, 4, 1>; // Clear codec not ready flag
        using WCKCFG = Field<_BCLRFR, 2, 1>; // Clear wrong clock configuration flag
        using MUTEDET = Field<_BCLRFR, 1, 1>; // Mute detection flag
        using OVRUDR = Field<_BCLRFR, 0, 1>; // Clear overrun / underrun
    };

    // BData register
    struct _BDR : Register<SAI1_BASE + 0x40, ReadWrite, _BDR> {
        using DATA = Field<_BDR, 0, 32>; // Data
    };

    // AConfiguration register 1
    struct _ACR1 : Register<SAI1_BASE + 0x4, ReadWrite, _ACR1> {
        using MCKDIV = Field<_ACR1, 20, 4>; // Master clock divider
        using NODIV = Field<_ACR1, 19, 1>; // No divider
        using DMAEN = Field<_ACR1, 17, 1>; // DMA enable
        using SAIAEN = Field<_ACR1, 16, 1>; // Audio block A enable
        using OutDri = Field<_ACR1, 13, 1>; // Output drive
        using MONO = Field<_ACR1, 12, 1>; // Mono mode
        using SYNCEN = Field<_ACR1, 10, 2>; // Synchronization enable
        using CKSTR = Field<_ACR1, 9, 1>; // Clock strobing edge
        using LSBFIRST = Field<_ACR1, 8, 1>; // Least significant bit first
        using DS = Field<_ACR1, 5, 3>; // Data size
        using PRTCFG = Field<_ACR1, 2, 2>; // Protocol configuration
        using MODE = Field<_ACR1, 0, 2>; // Audio block mode
    };

    // AConfiguration register 2
    struct _ACR2 : Register<SAI1_BASE + 0x8, ReadWrite, _ACR2> {
        using COMP = Field<_ACR2, 14, 2>; // Companding mode
        using CPL = Field<_ACR2, 13, 1>; // Complement bit
        using MUTECN = Field<_ACR2, 7, 6>; // Mute counter
        using MUTEVAL = Field<_ACR2, 6, 1>; // Mute value
        using MUTE = Field<_ACR2, 5, 1>; // Mute
        using TRIS = Field<_ACR2, 4, 1>; // Tristate management on data line
        using FFLUS = Field<_ACR2, 3, 1>; // FIFO flush
        using FTH = Field<_ACR2, 0, 3>; // FIFO threshold
    };

    // AFRCR
    struct _AFRCR : Register<SAI1_BASE + 0xC, ReadWrite, _AFRCR> {
        using FSOFF = Field<_AFRCR, 18, 1>; // Frame synchronization offset
        using FSPOL = Field<_AFRCR, 17, 1>; // Frame synchronization polarity
        using FSDEF = Field<_AFRCR, 16, 1>; // Frame synchronization definition
        using FSALL = Field<_AFRCR, 8, 7>; // Frame synchronization active level length
        using FRL = Field<_AFRCR, 0, 8>; // Frame length
    };

    // ASlot register
    struct _ASLOTR : Register<SAI1_BASE + 0x10, ReadWrite, _ASLOTR> {
        using SLOTEN = Field<_ASLOTR, 16, 16>; // Slot enable
        using NBSLOT = Field<_ASLOTR, 8, 4>; // Number of slots in an audio frame
        using SLOTSZ = Field<_ASLOTR, 6, 2>; // Slot size
        using FBOFF = Field<_ASLOTR, 0, 5>; // First bit offset
    };

    // AInterrupt mask register2
    struct _AIM : Register<SAI1_BASE + 0x14, ReadWrite, _AIM> {
        using LFSDET = Field<_AIM, 6, 1>; // Late frame synchronization detection interrupt enable
        using AFSDETIE = Field<_AIM, 5, 1>; // Anticipated frame synchronization detection interrupt enable
        using CNRDYIE = Field<_AIM, 4, 1>; // Codec not ready interrupt enable
        using FREQIE = Field<_AIM, 3, 1>; // FIFO request interrupt enable
        using WCKCFG = Field<_AIM, 2, 1>; // Wrong clock configuration interrupt enable
        using MUTEDET = Field<_AIM, 1, 1>; // Mute detection interrupt enable
        using OVRUDRIE = Field<_AIM, 0, 1>; // Overrun/underrun interrupt enable
    };

    // AStatus register
    struct _ASR : Register<SAI1_BASE + 0x18, ReadWrite, _ASR> {
        using FLVL = Field<_ASR, 16, 3>; // FIFO level threshold
        using LFSDET = Field<_ASR, 6, 1>; // Late frame synchronization detection
        using AFSDET = Field<_ASR, 5, 1>; // Anticipated frame synchronization detection
        using CNRDY = Field<_ASR, 4, 1>; // Codec not ready
        using FREQ = Field<_ASR, 3, 1>; // FIFO request
        using WCKCFG = Field<_ASR, 2, 1>; // Wrong clock configuration flag. This bit is read only.
        using MUTEDET = Field<_ASR, 1, 1>; // Mute detection
        using OVRUDR = Field<_ASR, 0, 1>; // Overrun / underrun
    };

    // AClear flag register
    struct _ACLRFR : Register<SAI1_BASE + 0x1C, ReadWrite, _ACLRFR> {
        using LFSDET = Field<_ACLRFR, 6, 1>; // Clear late frame synchronization detection flag
        using CAFSDET = Field<_ACLRFR, 5, 1>; // Clear anticipated frame synchronization detection flag.
        using CNRDY = Field<_ACLRFR, 4, 1>; // Clear codec not ready flag
        using WCKCFG = Field<_ACLRFR, 2, 1>; // Clear wrong clock configuration flag
        using MUTEDET = Field<_ACLRFR, 1, 1>; // Mute detection flag
        using OVRUDR = Field<_ACLRFR, 0, 1>; // Clear overrun / underrun
    };

    // AData register
    struct _ADR : Register<SAI1_BASE + 0x20, ReadWrite, _ADR> {
        using DATA = Field<_ADR, 0, 32>; // Data
    };

    // Global configuration register
    struct _GCR : Register<SAI1_BASE + 0x0, ReadWrite, _GCR> {
        using SYNCIN = Field<_GCR, 0, 2>; // Synchronization inputs
        using SYNCOUT = Field<_GCR, 4, 2>; // Synchronization outputs
    };

} // namespace SAI1

// --------------------------------------------
// SAI2: 
// Base address: 0x40015C00
// --------------------------------------------

namespace SAI2 {
    static constexpr uint32_t SAI2_BASE = 0x40015C00;

} // namespace SAI2

// --------------------------------------------
// DMA2D: DMA2D controller
// Base address: 0x4002B000
// --------------------------------------------

namespace DMA2D {
    static constexpr uint32_t DMA2D_BASE = 0x4002B000;

    // control register
    struct _CR : Register<DMA2D_BASE + 0x0, ReadWrite, _CR> {
        using MODE = Field<_CR, 16, 2>; // DMA2D mode
        using CEIE = Field<_CR, 13, 1>; // Configuration Error Interrupt Enable
        using CTCIE = Field<_CR, 12, 1>; // CLUT transfer complete interrupt enable
        using CAEIE = Field<_CR, 11, 1>; // CLUT access error interrupt enable
        using TWIE = Field<_CR, 10, 1>; // Transfer watermark interrupt enable
        using TCIE = Field<_CR, 9, 1>; // Transfer complete interrupt enable
        using TEIE = Field<_CR, 8, 1>; // Transfer error interrupt enable
        using ABORT = Field<_CR, 2, 1>; // Abort
        using SUSP = Field<_CR, 1, 1>; // Suspend
        using START = Field<_CR, 0, 1>; // Start
    };

    // Interrupt Status Register
    struct _ISR : Register<DMA2D_BASE + 0x4, ReadOnly, _ISR> {
        using CEIF = Field<_ISR, 5, 1>; // Configuration error interrupt flag
        using CTCIF = Field<_ISR, 4, 1>; // CLUT transfer complete interrupt flag
        using CAEIF = Field<_ISR, 3, 1>; // CLUT access error interrupt flag
        using TWIF = Field<_ISR, 2, 1>; // Transfer watermark interrupt flag
        using TCIF = Field<_ISR, 1, 1>; // Transfer complete interrupt flag
        using TEIF = Field<_ISR, 0, 1>; // Transfer error interrupt flag
    };

    // interrupt flag clear register
    struct _IFCR : Register<DMA2D_BASE + 0x8, ReadWrite, _IFCR> {
        using CCEIF = Field<_IFCR, 5, 1>; // Clear configuration error interrupt flag
        using CCTCIF = Field<_IFCR, 4, 1>; // Clear CLUT transfer complete interrupt flag
        using CAECIF = Field<_IFCR, 3, 1>; // Clear CLUT access error interrupt flag
        using CTWIF = Field<_IFCR, 2, 1>; // Clear transfer watermark interrupt flag
        using CTCIF = Field<_IFCR, 1, 1>; // Clear transfer complete interrupt flag
        using CTEIF = Field<_IFCR, 0, 1>; // Clear Transfer error interrupt flag
    };

    // foreground memory address register
    struct _FGMAR : Register<DMA2D_BASE + 0xC, ReadWrite, _FGMAR> {
        using MA = Field<_FGMAR, 0, 32>; // Memory address
    };

    // foreground offset register
    struct _FGOR : Register<DMA2D_BASE + 0x10, ReadWrite, _FGOR> {
        using LO = Field<_FGOR, 0, 14>; // Line offset
    };

    // background memory address register
    struct _BGMAR : Register<DMA2D_BASE + 0x14, ReadWrite, _BGMAR> {
        using MA = Field<_BGMAR, 0, 32>; // Memory address
    };

    // background offset register
    struct _BGOR : Register<DMA2D_BASE + 0x18, ReadWrite, _BGOR> {
        using LO = Field<_BGOR, 0, 14>; // Line offset
    };

    // foreground PFC control register
    struct _FGPFCCR : Register<DMA2D_BASE + 0x1C, ReadWrite, _FGPFCCR> {
        using ALPHA = Field<_FGPFCCR, 24, 8>; // Alpha value
        using AM = Field<_FGPFCCR, 16, 2>; // Alpha mode
        using CS = Field<_FGPFCCR, 8, 8>; // CLUT size
        using START = Field<_FGPFCCR, 5, 1>; // Start
        using CCM = Field<_FGPFCCR, 4, 1>; // CLUT color mode
        using CM = Field<_FGPFCCR, 0, 4>; // Color mode
    };

    // foreground color register
    struct _FGCOLR : Register<DMA2D_BASE + 0x20, ReadWrite, _FGCOLR> {
        using RED = Field<_FGCOLR, 16, 8>; // Red Value
        using GREEN = Field<_FGCOLR, 8, 8>; // Green Value
        using BLUE = Field<_FGCOLR, 0, 8>; // Blue Value
    };

    // background PFC control register
    struct _BGPFCCR : Register<DMA2D_BASE + 0x24, ReadWrite, _BGPFCCR> {
        using ALPHA = Field<_BGPFCCR, 24, 8>; // Alpha value
        using AM = Field<_BGPFCCR, 16, 2>; // Alpha mode
        using CS = Field<_BGPFCCR, 8, 8>; // CLUT size
        using START = Field<_BGPFCCR, 5, 1>; // Start
        using CCM = Field<_BGPFCCR, 4, 1>; // CLUT Color mode
        using CM = Field<_BGPFCCR, 0, 4>; // Color mode
    };

    // background color register
    struct _BGCOLR : Register<DMA2D_BASE + 0x28, ReadWrite, _BGCOLR> {
        using RED = Field<_BGCOLR, 16, 8>; // Red Value
        using GREEN = Field<_BGCOLR, 8, 8>; // Green Value
        using BLUE = Field<_BGCOLR, 0, 8>; // Blue Value
    };

    // foreground CLUT memory address register
    struct _FGCMAR : Register<DMA2D_BASE + 0x2C, ReadWrite, _FGCMAR> {
        using MA = Field<_FGCMAR, 0, 32>; // Memory Address
    };

    // background CLUT memory address register
    struct _BGCMAR : Register<DMA2D_BASE + 0x30, ReadWrite, _BGCMAR> {
        using MA = Field<_BGCMAR, 0, 32>; // Memory address
    };

    // output PFC control register
    struct _OPFCCR : Register<DMA2D_BASE + 0x34, ReadWrite, _OPFCCR> {
        using CM = Field<_OPFCCR, 0, 3>; // Color mode
    };

    // output color register
    struct _OCOLR : Register<DMA2D_BASE + 0x38, ReadWrite, _OCOLR> {
        using APLHA = Field<_OCOLR, 24, 8>; // Alpha Channel Value
        using RED = Field<_OCOLR, 16, 8>; // Red Value
        using GREEN = Field<_OCOLR, 8, 8>; // Green Value
        using BLUE = Field<_OCOLR, 0, 8>; // Blue Value
    };

    // output memory address register
    struct _OMAR : Register<DMA2D_BASE + 0x3C, ReadWrite, _OMAR> {
        using MA = Field<_OMAR, 0, 32>; // Memory Address
    };

    // output offset register
    struct _OOR : Register<DMA2D_BASE + 0x40, ReadWrite, _OOR> {
        using LO = Field<_OOR, 0, 14>; // Line Offset
    };

    // number of line register
    struct _NLR : Register<DMA2D_BASE + 0x44, ReadWrite, _NLR> {
        using PL = Field<_NLR, 16, 14>; // Pixel per lines
        using NL = Field<_NLR, 0, 16>; // Number of lines
    };

    // line watermark register
    struct _LWR : Register<DMA2D_BASE + 0x48, ReadWrite, _LWR> {
        using LW = Field<_LWR, 0, 16>; // Line watermark
    };

    // AHB master timer configuration register
    struct _AMTCR : Register<DMA2D_BASE + 0x4C, ReadWrite, _AMTCR> {
        using DT = Field<_AMTCR, 8, 8>; // Dead Time
        using EN = Field<_AMTCR, 0, 1>; // Enable
    };

    // FGCLUT
    struct _FGCLUT : Register<DMA2D_BASE + 0x400, ReadWrite, _FGCLUT> {
        using APLHA = Field<_FGCLUT, 24, 8>; // APLHA
        using RED = Field<_FGCLUT, 16, 8>; // RED
        using GREEN = Field<_FGCLUT, 8, 8>; // GREEN
        using BLUE = Field<_FGCLUT, 0, 8>; // BLUE
    };

    // BGCLUT
    struct _BGCLUT : Register<DMA2D_BASE + 0x800, ReadWrite, _BGCLUT> {
        using APLHA = Field<_BGCLUT, 24, 8>; // APLHA
        using RED = Field<_BGCLUT, 16, 8>; // RED
        using GREEN = Field<_BGCLUT, 8, 8>; // GREEN
        using BLUE = Field<_BGCLUT, 0, 8>; // BLUE
    };

} // namespace DMA2D

// --------------------------------------------
// QUADSPI: QuadSPI interface
// Base address: 0xA0001000
// --------------------------------------------

namespace QUADSPI {
    static constexpr uint32_t QUADSPI_BASE = 0xA0001000;

    // control register
    struct _CR : Register<QUADSPI_BASE + 0x0, ReadWrite, _CR> {
        using PRESCALER = Field<_CR, 24, 8>; // Clock prescaler
        using PMM = Field<_CR, 23, 1>; // Polling match mode
        using APMS = Field<_CR, 22, 1>; // Automatic poll mode stop
        using TOIE = Field<_CR, 20, 1>; // TimeOut interrupt enable
        using SMIE = Field<_CR, 19, 1>; // Status match interrupt enable
        using FTIE = Field<_CR, 18, 1>; // FIFO threshold interrupt enable
        using TCIE = Field<_CR, 17, 1>; // Transfer complete interrupt enable
        using TEIE = Field<_CR, 16, 1>; // Transfer error interrupt enable
        using FTHRES = Field<_CR, 8, 5>; // IFO threshold level
        using FSEL = Field<_CR, 7, 1>; // FLASH memory selection
        using DFM = Field<_CR, 6, 1>; // Dual-flash mode
        using SSHIFT = Field<_CR, 4, 1>; // Sample shift
        using TCEN = Field<_CR, 3, 1>; // Timeout counter enable
        using DMAEN = Field<_CR, 2, 1>; // DMA enable
        using ABORT = Field<_CR, 1, 1>; // Abort request
        using EN = Field<_CR, 0, 1>; // Enable
    };

    // device configuration register
    struct _DCR : Register<QUADSPI_BASE + 0x4, ReadWrite, _DCR> {
        using FSIZE = Field<_DCR, 16, 5>; // FLASH memory size
        using CSHT = Field<_DCR, 8, 3>; // Chip select high time
        using CKMODE = Field<_DCR, 0, 1>; // Mode 0 / mode 3
    };

    // status register
    struct _SR : Register<QUADSPI_BASE + 0x8, ReadOnly, _SR> {
        using FLEVEL = Field<_SR, 8, 7>; // FIFO level
        using BUSY = Field<_SR, 5, 1>; // Busy
        using TOF = Field<_SR, 4, 1>; // Timeout flag
        using SMF = Field<_SR, 3, 1>; // Status match flag
        using FTF = Field<_SR, 2, 1>; // FIFO threshold flag
        using TCF = Field<_SR, 1, 1>; // Transfer complete flag
        using TEF = Field<_SR, 0, 1>; // Transfer error flag
    };

    // flag clear register
    struct _FCR : Register<QUADSPI_BASE + 0xC, ReadWrite, _FCR> {
        using CTOF = Field<_FCR, 4, 1>; // Clear timeout flag
        using CSMF = Field<_FCR, 3, 1>; // Clear status match flag
        using CTCF = Field<_FCR, 1, 1>; // Clear transfer complete flag
        using CTEF = Field<_FCR, 0, 1>; // Clear transfer error flag
    };

    // data length register
    struct _DLR : Register<QUADSPI_BASE + 0x10, ReadWrite, _DLR> {
        using DL = Field<_DLR, 0, 32>; // Data length
    };

    // communication configuration register
    struct _CCR : Register<QUADSPI_BASE + 0x14, ReadWrite, _CCR> {
        using DDRM = Field<_CCR, 31, 1>; // Double data rate mode
        using DHHC = Field<_CCR, 30, 1>; // DDR hold half cycle
        using SIOO = Field<_CCR, 28, 1>; // Send instruction only once mode
        using FMODE = Field<_CCR, 26, 2>; // Functional mode
        using DMODE = Field<_CCR, 24, 2>; // Data mode
        using DCYC = Field<_CCR, 18, 5>; // Number of dummy cycles
        using ABSIZE = Field<_CCR, 16, 2>; // Alternate bytes size
        using ABMODE = Field<_CCR, 14, 2>; // Alternate bytes mode
        using ADSIZE = Field<_CCR, 12, 2>; // Address size
        using ADMODE = Field<_CCR, 10, 2>; // Address mode
        using IMODE = Field<_CCR, 8, 2>; // Instruction mode
        using INSTRUCTION = Field<_CCR, 0, 8>; // Instruction
    };

    // address register
    struct _AR : Register<QUADSPI_BASE + 0x18, ReadWrite, _AR> {
        using ADDRESS = Field<_AR, 0, 32>; // Address
    };

    // ABR
    struct _ABR : Register<QUADSPI_BASE + 0x1C, ReadWrite, _ABR> {
        using ALTERNATE = Field<_ABR, 0, 32>; // ALTERNATE
    };

    // data register
    struct _DR : Register<QUADSPI_BASE + 0x20, ReadWrite, _DR> {
        using DATA = Field<_DR, 0, 32>; // Data
    };

    // polling status mask register
    struct _PSMKR : Register<QUADSPI_BASE + 0x24, ReadWrite, _PSMKR> {
        using MASK = Field<_PSMKR, 0, 32>; // Status mask
    };

    // polling status match register
    struct _PSMAR : Register<QUADSPI_BASE + 0x28, ReadWrite, _PSMAR> {
        using MATCH = Field<_PSMAR, 0, 32>; // Status match
    };

    // polling interval register
    struct _PIR : Register<QUADSPI_BASE + 0x2C, ReadWrite, _PIR> {
        using INTERVAL = Field<_PIR, 0, 16>; // Polling interval
    };

    // low-power timeout register
    struct _LPTR : Register<QUADSPI_BASE + 0x30, ReadWrite, _LPTR> {
        using TIMEOUT = Field<_LPTR, 0, 16>; // Timeout period
    };

} // namespace QUADSPI

// --------------------------------------------
// CEC: HDMI-CEC controller
// Base address: 0x40006C00
// --------------------------------------------

namespace CEC {
    static constexpr uint32_t CEC_BASE = 0x40006C00;

    // control register
    struct _CR : Register<CEC_BASE + 0x0, ReadWrite, _CR> {
        using TXEOM = Field<_CR, 2, 1>; // Tx End Of Message
        using TXSOM = Field<_CR, 1, 1>; // Tx start of message
        using CECEN = Field<_CR, 0, 1>; // CEC Enable
    };

    // configuration register
    struct _CFGR : Register<CEC_BASE + 0x4, ReadWrite, _CFGR> {
        using SFT = Field<_CFGR, 0, 3>; // Signal Free Time
        using RXTOL = Field<_CFGR, 3, 1>; // Rx-Tolerance
        using BRESTP = Field<_CFGR, 4, 1>; // Rx-stop on bit rising error
        using BREGEN = Field<_CFGR, 5, 1>; // Generate error-bit on bit rising error
        using LBPEGEN = Field<_CFGR, 6, 1>; // Generate Error-Bit on Long Bit Period Error
        using BRDNOGEN = Field<_CFGR, 7, 1>; // Avoid Error-Bit Generation in Broadcast
        using SFTOP = Field<_CFGR, 8, 1>; // SFT Option Bit
        using OAR = Field<_CFGR, 16, 15>; // Own addresses configuration
        using LSTN = Field<_CFGR, 31, 1>; // Listen mode
    };

    // Tx data register
    struct _TXDR : Register<CEC_BASE + 0x8, WriteOnly, _TXDR> {
        using TXD = Field<_TXDR, 0, 8>; // Tx Data register
    };

    // Rx Data Register
    struct _RXDR : Register<CEC_BASE + 0xC, ReadOnly, _RXDR> {
        using RXDR = Field<_RXDR, 0, 8>; // CEC Rx Data Register
    };

    // Interrupt and Status Register
    struct _ISR : Register<CEC_BASE + 0x10, ReadWrite, _ISR> {
        using TXACKE = Field<_ISR, 12, 1>; // Tx-Missing acknowledge error
        using TXERR = Field<_ISR, 11, 1>; // Tx-Error
        using TXUDR = Field<_ISR, 10, 1>; // Tx-Buffer Underrun
        using TXEND = Field<_ISR, 9, 1>; // End of Transmission
        using TXBR = Field<_ISR, 8, 1>; // Tx-Byte Request
        using ARBLST = Field<_ISR, 7, 1>; // Arbitration Lost
        using RXACKE = Field<_ISR, 6, 1>; // Rx-Missing Acknowledge
        using LBPE = Field<_ISR, 5, 1>; // Rx-Long Bit Period Error
        using SBPE = Field<_ISR, 4, 1>; // Rx-Short Bit period error
        using BRE = Field<_ISR, 3, 1>; // Rx-Bit rising error
        using RXOVR = Field<_ISR, 2, 1>; // Rx-Overrun
        using RXEND = Field<_ISR, 1, 1>; // End Of Reception
        using RXBR = Field<_ISR, 0, 1>; // Rx-Byte Received
    };

    // interrupt enable register
    struct _IER : Register<CEC_BASE + 0x14, ReadWrite, _IER> {
        using TXACKIE = Field<_IER, 12, 1>; // Tx-Missing Acknowledge Error Interrupt Enable
        using TXERRIE = Field<_IER, 11, 1>; // Tx-Error Interrupt Enable
        using TXUDRIE = Field<_IER, 10, 1>; // Tx-Underrun interrupt enable
        using TXENDIE = Field<_IER, 9, 1>; // Tx-End of message interrupt enable
        using TXBRIE = Field<_IER, 8, 1>; // Tx-Byte Request Interrupt Enable
        using ARBLSTIE = Field<_IER, 7, 1>; // Arbitration Lost Interrupt Enable
        using RXACKIE = Field<_IER, 6, 1>; // Rx-Missing Acknowledge Error Interrupt Enable
        using LBPEIE = Field<_IER, 5, 1>; // Long Bit Period Error Interrupt Enable
        using SBPEIE = Field<_IER, 4, 1>; // Short Bit Period Error Interrupt Enable
        using BREIE = Field<_IER, 3, 1>; // Bit Rising Error Interrupt Enable
        using RXOVRIE = Field<_IER, 2, 1>; // Rx-Buffer Overrun Interrupt Enable
        using RXENDIE = Field<_IER, 1, 1>; // End Of Reception Interrupt Enable
        using RXBRIE = Field<_IER, 0, 1>; // Rx-Byte Received Interrupt Enable
    };

} // namespace CEC

// --------------------------------------------
// SPDIFRX: Receiver Interface
// Base address: 0x40004000
// --------------------------------------------

namespace SPDIFRX {
    static constexpr uint32_t SPDIFRX_BASE = 0x40004000;

    // Control register
    struct _CR : Register<SPDIFRX_BASE + 0x0, ReadWrite, _CR> {
        using SPDIFEN = Field<_CR, 0, 2>; // Peripheral Block Enable
        using RXDMAEN = Field<_CR, 2, 1>; // Receiver DMA ENable for data flow
        using RXSTEO = Field<_CR, 3, 1>; // STerEO Mode
        using DRFMT = Field<_CR, 4, 2>; // RX Data format
        using PMSK = Field<_CR, 6, 1>; // Mask Parity error bit
        using VMSK = Field<_CR, 7, 1>; // Mask of Validity bit
        using CUMSK = Field<_CR, 8, 1>; // Mask of channel status and user bits
        using PTMSK = Field<_CR, 9, 1>; // Mask of Preamble Type bits
        using CBDMAEN = Field<_CR, 10, 1>; // Control Buffer DMA ENable for control flow
        using CHSEL = Field<_CR, 11, 1>; // Channel Selection
        using NBTR = Field<_CR, 12, 2>; // Maximum allowed re-tries during synchronization phase
        using WFA = Field<_CR, 14, 1>; // Wait For Activity
        using INSEL = Field<_CR, 16, 3>; // input selection
    };

    // Interrupt mask register
    struct _IMR : Register<SPDIFRX_BASE + 0x4, ReadWrite, _IMR> {
        using RXNEIE = Field<_IMR, 0, 1>; // RXNE interrupt enable
        using CSRNEIE = Field<_IMR, 1, 1>; // Control Buffer Ready Interrupt Enable
        using PERRIE = Field<_IMR, 2, 1>; // Parity error interrupt enable
        using OVRIE = Field<_IMR, 3, 1>; // Overrun error Interrupt Enable
        using SBLKIE = Field<_IMR, 4, 1>; // Synchronization Block Detected Interrupt Enable
        using SYNCDIE = Field<_IMR, 5, 1>; // Synchronization Done
        using IFEIE = Field<_IMR, 6, 1>; // Serial Interface Error Interrupt Enable
    };

    // Status register
    struct _SR : Register<SPDIFRX_BASE + 0x8, ReadOnly, _SR> {
        using RXNE = Field<_SR, 0, 1>; // Read data register not empty
        using CSRNE = Field<_SR, 1, 1>; // Control Buffer register is not empty
        using PERR = Field<_SR, 2, 1>; // Parity error
        using OVR = Field<_SR, 3, 1>; // Overrun error
        using SBD = Field<_SR, 4, 1>; // Synchronization Block Detected
        using SYNCD = Field<_SR, 5, 1>; // Synchronization Done
        using FERR = Field<_SR, 6, 1>; // Framing error
        using SERR = Field<_SR, 7, 1>; // Synchronization error
        using TERR = Field<_SR, 8, 1>; // Time-out error
        using WIDTH5 = Field<_SR, 16, 15>; // Duration of 5 symbols counted with SPDIF_CLK
    };

    // Interrupt Flag Clear register
    struct _IFCR : Register<SPDIFRX_BASE + 0xC, WriteOnly, _IFCR> {
        using PERRCF = Field<_IFCR, 2, 1>; // Clears the Parity error flag
        using OVRCF = Field<_IFCR, 3, 1>; // Clears the Overrun error flag
        using SBDCF = Field<_IFCR, 4, 1>; // Clears the Synchronization Block Detected flag
        using SYNCDCF = Field<_IFCR, 5, 1>; // Clears the Synchronization Done flag
    };

    // Data input register
    struct _DR : Register<SPDIFRX_BASE + 0x10, ReadOnly, _DR> {
        using DR = Field<_DR, 0, 24>; // Parity Error bit
        using PE = Field<_DR, 24, 1>; // Parity Error bit
        using V = Field<_DR, 25, 1>; // Validity bit
        using U = Field<_DR, 26, 1>; // User bit
        using C = Field<_DR, 27, 1>; // Channel Status bit
        using PT = Field<_DR, 28, 2>; // Preamble Type
    };

    // Channel Status register
    struct _CSR : Register<SPDIFRX_BASE + 0x14, ReadOnly, _CSR> {
        using USR = Field<_CSR, 0, 16>; // User data information
        using CS = Field<_CSR, 16, 8>; // Channel A status information
        using SOB = Field<_CSR, 24, 1>; // Start Of Block
    };

    // Debug Information register
    struct _DIR : Register<SPDIFRX_BASE + 0x18, ReadOnly, _DIR> {
        using THI = Field<_DIR, 0, 13>; // Threshold HIGH
        using TLO = Field<_DIR, 16, 13>; // Threshold LOW
    };

} // namespace SPDIFRX

// --------------------------------------------
// SDMMC1: Secure digital input/output interface
// Base address: 0x40012C00
// --------------------------------------------

namespace SDMMC1 {
    static constexpr uint32_t SDMMC1_BASE = 0x40012C00;

    // power control register
    struct _POWER : Register<SDMMC1_BASE + 0x0, ReadWrite, _POWER> {
        using PWRCTRL = Field<_POWER, 0, 2>; // PWRCTRL
    };

    // SDI clock control register
    struct _CLKCR : Register<SDMMC1_BASE + 0x4, ReadWrite, _CLKCR> {
        using HWFC_EN = Field<_CLKCR, 14, 1>; // HW Flow Control enable
        using NEGEDGE = Field<_CLKCR, 13, 1>; // SDIO_CK dephasing selection bit
        using WIDBUS = Field<_CLKCR, 11, 2>; // Wide bus mode enable bit
        using BYPASS = Field<_CLKCR, 10, 1>; // Clock divider bypass enable bit
        using PWRSAV = Field<_CLKCR, 9, 1>; // Power saving configuration bit
        using CLKEN = Field<_CLKCR, 8, 1>; // Clock enable bit
        using CLKDIV = Field<_CLKCR, 0, 8>; // Clock divide factor
    };

    // argument register
    struct _ARG : Register<SDMMC1_BASE + 0x8, ReadWrite, _ARG> {
        using CMDARG = Field<_ARG, 0, 32>; // Command argument
    };

    // command register
    struct _CMD : Register<SDMMC1_BASE + 0xC, ReadWrite, _CMD> {
        using CE_ATACMD = Field<_CMD, 14, 1>; // CE-ATA command
        using nIEN = Field<_CMD, 13, 1>; // not Interrupt Enable
        using ENCMDcompl = Field<_CMD, 12, 1>; // Enable CMD completion
        using SDIOSuspend = Field<_CMD, 11, 1>; // SD I/O suspend command
        using CPSMEN = Field<_CMD, 10, 1>; // Command path state machine (CPSM) Enable bit
        using WAITPEND = Field<_CMD, 9, 1>; // CPSM Waits for ends of data transfer (CmdPend internal signal)
        using WAITINT = Field<_CMD, 8, 1>; // CPSM waits for interrupt request
        using WAITRESP = Field<_CMD, 6, 2>; // Wait for response bits
        using CMDINDEX = Field<_CMD, 0, 6>; // Command index
    };

    // command response register
    struct _RESPCMD : Register<SDMMC1_BASE + 0x10, ReadOnly, _RESPCMD> {
        using RESPCMD = Field<_RESPCMD, 0, 6>; // Response command index
    };

    // response 1..4 register
    struct _RESP1 : Register<SDMMC1_BASE + 0x14, ReadOnly, _RESP1> {
        using CARDSTATUS1 = Field<_RESP1, 0, 32>; // see Table 132
    };

    // response 1..4 register
    struct _RESP2 : Register<SDMMC1_BASE + 0x18, ReadOnly, _RESP2> {
        using CARDSTATUS2 = Field<_RESP2, 0, 32>; // see Table 132
    };

    // response 1..4 register
    struct _RESP3 : Register<SDMMC1_BASE + 0x1C, ReadOnly, _RESP3> {
        using CARDSTATUS3 = Field<_RESP3, 0, 32>; // see Table 132
    };

    // response 1..4 register
    struct _RESP4 : Register<SDMMC1_BASE + 0x20, ReadOnly, _RESP4> {
        using CARDSTATUS4 = Field<_RESP4, 0, 32>; // see Table 132
    };

    // data timer register
    struct _DTIMER : Register<SDMMC1_BASE + 0x24, ReadWrite, _DTIMER> {
        using DATATIME = Field<_DTIMER, 0, 32>; // Data timeout period
    };

    // data length register
    struct _DLEN : Register<SDMMC1_BASE + 0x28, ReadWrite, _DLEN> {
        using DATALENGTH = Field<_DLEN, 0, 25>; // Data length value
    };

    // data control register
    struct _DCTRL : Register<SDMMC1_BASE + 0x2C, ReadWrite, _DCTRL> {
        using SDIOEN = Field<_DCTRL, 11, 1>; // SD I/O enable functions
        using RWMOD = Field<_DCTRL, 10, 1>; // Read wait mode
        using RWSTOP = Field<_DCTRL, 9, 1>; // Read wait stop
        using RWSTART = Field<_DCTRL, 8, 1>; // Read wait start
        using DBLOCKSIZE = Field<_DCTRL, 4, 4>; // Data block size
        using DMAEN = Field<_DCTRL, 3, 1>; // DMA enable bit
        using DTMODE = Field<_DCTRL, 2, 1>; // Data transfer mode selection 1: Stream or SDIO multibyte data transfer
        using DTDIR = Field<_DCTRL, 1, 1>; // Data transfer direction selection
        using DTEN = Field<_DCTRL, 0, 1>; // DTEN
    };

    // data counter register
    struct _DCOUNT : Register<SDMMC1_BASE + 0x30, ReadOnly, _DCOUNT> {
        using DATACOUNT = Field<_DCOUNT, 0, 25>; // Data count value
    };

    // status register
    struct _STA : Register<SDMMC1_BASE + 0x34, ReadOnly, _STA> {
        using CEATAEND = Field<_STA, 23, 1>; // CE-ATA command completion signal received for CMD61
        using SDIOIT = Field<_STA, 22, 1>; // SDIO interrupt received
        using RXDAVL = Field<_STA, 21, 1>; // Data available in receive FIFO
        using TXDAVL = Field<_STA, 20, 1>; // Data available in transmit FIFO
        using RXFIFOE = Field<_STA, 19, 1>; // Receive FIFO empty
        using TXFIFOE = Field<_STA, 18, 1>; // Transmit FIFO empty
        using RXFIFOF = Field<_STA, 17, 1>; // Receive FIFO full
        using TXFIFOF = Field<_STA, 16, 1>; // Transmit FIFO full
        using RXFIFOHF = Field<_STA, 15, 1>; // Receive FIFO half full: there are at least 8 words in the FIFO
        using TXFIFOHE = Field<_STA, 14, 1>; // Transmit FIFO half empty: at least 8 words can be written into the FIFO
        using RXACT = Field<_STA, 13, 1>; // Data receive in progress
        using TXACT = Field<_STA, 12, 1>; // Data transmit in progress
        using CMDACT = Field<_STA, 11, 1>; // Command transfer in progress
        using DBCKEND = Field<_STA, 10, 1>; // Data block sent/received (CRC check passed)
        using STBITERR = Field<_STA, 9, 1>; // Start bit not detected on all data signals in wide bus mode
        using DATAEND = Field<_STA, 8, 1>; // Data end (data counter, SDIDCOUNT, is zero)
        using CMDSENT = Field<_STA, 7, 1>; // Command sent (no response required)
        using CMDREND = Field<_STA, 6, 1>; // Command response received (CRC check passed)
        using RXOVERR = Field<_STA, 5, 1>; // Received FIFO overrun error
        using TXUNDERR = Field<_STA, 4, 1>; // Transmit FIFO underrun error
        using DTIMEOUT = Field<_STA, 3, 1>; // Data timeout
        using CTIMEOUT = Field<_STA, 2, 1>; // Command response timeout
        using DCRCFAIL = Field<_STA, 1, 1>; // Data block sent/received (CRC check failed)
        using CCRCFAIL = Field<_STA, 0, 1>; // Command response received (CRC check failed)
    };

    // interrupt clear register
    struct _ICR : Register<SDMMC1_BASE + 0x38, ReadWrite, _ICR> {
        using CEATAENDC = Field<_ICR, 23, 1>; // CEATAEND flag clear bit
        using SDIOITC = Field<_ICR, 22, 1>; // SDIOIT flag clear bit
        using DBCKENDC = Field<_ICR, 10, 1>; // DBCKEND flag clear bit
        using STBITERRC = Field<_ICR, 9, 1>; // STBITERR flag clear bit
        using DATAENDC = Field<_ICR, 8, 1>; // DATAEND flag clear bit
        using CMDSENTC = Field<_ICR, 7, 1>; // CMDSENT flag clear bit
        using CMDRENDC = Field<_ICR, 6, 1>; // CMDREND flag clear bit
        using RXOVERRC = Field<_ICR, 5, 1>; // RXOVERR flag clear bit
        using TXUNDERRC = Field<_ICR, 4, 1>; // TXUNDERR flag clear bit
        using DTIMEOUTC = Field<_ICR, 3, 1>; // DTIMEOUT flag clear bit
        using CTIMEOUTC = Field<_ICR, 2, 1>; // CTIMEOUT flag clear bit
        using DCRCFAILC = Field<_ICR, 1, 1>; // DCRCFAIL flag clear bit
        using CCRCFAILC = Field<_ICR, 0, 1>; // CCRCFAIL flag clear bit
    };

    // mask register
    struct _MASK : Register<SDMMC1_BASE + 0x3C, ReadWrite, _MASK> {
        using CEATAENDIE = Field<_MASK, 23, 1>; // CE-ATA command completion signal received interrupt enable
        using SDIOITIE = Field<_MASK, 22, 1>; // SDIO mode interrupt received interrupt enable
        using RXDAVLIE = Field<_MASK, 21, 1>; // Data available in Rx FIFO interrupt enable
        using TXDAVLIE = Field<_MASK, 20, 1>; // Data available in Tx FIFO interrupt enable
        using RXFIFOEIE = Field<_MASK, 19, 1>; // Rx FIFO empty interrupt enable
        using TXFIFOEIE = Field<_MASK, 18, 1>; // Tx FIFO empty interrupt enable
        using RXFIFOFIE = Field<_MASK, 17, 1>; // Rx FIFO full interrupt enable
        using TXFIFOFIE = Field<_MASK, 16, 1>; // Tx FIFO full interrupt enable
        using RXFIFOHFIE = Field<_MASK, 15, 1>; // Rx FIFO half full interrupt enable
        using TXFIFOHEIE = Field<_MASK, 14, 1>; // Tx FIFO half empty interrupt enable
        using RXACTIE = Field<_MASK, 13, 1>; // Data receive acting interrupt enable
        using TXACTIE = Field<_MASK, 12, 1>; // Data transmit acting interrupt enable
        using CMDACTIE = Field<_MASK, 11, 1>; // Command acting interrupt enable
        using DBCKENDIE = Field<_MASK, 10, 1>; // Data block end interrupt enable
        using STBITERRIE = Field<_MASK, 9, 1>; // Start bit error interrupt enable
        using DATAENDIE = Field<_MASK, 8, 1>; // Data end interrupt enable
        using CMDSENTIE = Field<_MASK, 7, 1>; // Command sent interrupt enable
        using CMDRENDIE = Field<_MASK, 6, 1>; // Command response received interrupt enable
        using RXOVERRIE = Field<_MASK, 5, 1>; // Rx FIFO overrun error interrupt enable
        using TXUNDERRIE = Field<_MASK, 4, 1>; // Tx FIFO underrun error interrupt enable
        using DTIMEOUTIE = Field<_MASK, 3, 1>; // Data timeout interrupt enable
        using CTIMEOUTIE = Field<_MASK, 2, 1>; // Command timeout interrupt enable
        using DCRCFAILIE = Field<_MASK, 1, 1>; // Data CRC fail interrupt enable
        using CCRCFAILIE = Field<_MASK, 0, 1>; // Command CRC fail interrupt enable
    };

    // FIFO counter register
    struct _FIFOCNT : Register<SDMMC1_BASE + 0x48, ReadOnly, _FIFOCNT> {
        using FIFOCOUNT = Field<_FIFOCNT, 0, 24>; // Remaining number of words to be written to or read from the FIFO
    };

    // data FIFO register
    struct _FIFO : Register<SDMMC1_BASE + 0x80, ReadWrite, _FIFO> {
        using FIFOData = Field<_FIFO, 0, 32>; // Receive and transmit FIFO data
    };

} // namespace SDMMC1

// --------------------------------------------
// SDMMC2: 
// Base address: 0x40011C00
// --------------------------------------------

namespace SDMMC2 {
    static constexpr uint32_t SDMMC2_BASE = 0x40011C00;

} // namespace SDMMC2

// --------------------------------------------
// LPTIM1: Low power timer
// Base address: 0x40002400
// --------------------------------------------

namespace LPTIM1 {
    static constexpr uint32_t LPTIM1_BASE = 0x40002400;

    // Interrupt and Status Register
    struct _ISR : Register<LPTIM1_BASE + 0x0, ReadOnly, _ISR> {
        using DOWN = Field<_ISR, 6, 1>; // Counter direction change up to down
        using UP = Field<_ISR, 5, 1>; // Counter direction change down to up
        using ARROK = Field<_ISR, 4, 1>; // Autoreload register update OK
        using CMPOK = Field<_ISR, 3, 1>; // Compare register update OK
        using EXTTRIG = Field<_ISR, 2, 1>; // External trigger edge event
        using ARRM = Field<_ISR, 1, 1>; // Autoreload match
        using CMPM = Field<_ISR, 0, 1>; // Compare match
    };

    // Interrupt Clear Register
    struct _ICR : Register<LPTIM1_BASE + 0x4, WriteOnly, _ICR> {
        using DOWNCF = Field<_ICR, 6, 1>; // Direction change to down Clear Flag
        using UPCF = Field<_ICR, 5, 1>; // Direction change to UP Clear Flag
        using ARROKCF = Field<_ICR, 4, 1>; // Autoreload register update OK Clear Flag
        using CMPOKCF = Field<_ICR, 3, 1>; // Compare register update OK Clear Flag
        using EXTTRIGCF = Field<_ICR, 2, 1>; // External trigger valid edge Clear Flag
        using ARRMCF = Field<_ICR, 1, 1>; // Autoreload match Clear Flag
        using CMPMCF = Field<_ICR, 0, 1>; // compare match Clear Flag
    };

    // Interrupt Enable Register
    struct _IER : Register<LPTIM1_BASE + 0x8, ReadWrite, _IER> {
        using DOWNIE = Field<_IER, 6, 1>; // Direction change to down Interrupt Enable
        using UPIE = Field<_IER, 5, 1>; // Direction change to UP Interrupt Enable
        using ARROKIE = Field<_IER, 4, 1>; // Autoreload register update OK Interrupt Enable
        using CMPOKIE = Field<_IER, 3, 1>; // Compare register update OK Interrupt Enable
        using EXTTRIGIE = Field<_IER, 2, 1>; // External trigger valid edge Interrupt Enable
        using ARRMIE = Field<_IER, 1, 1>; // Autoreload match Interrupt Enable
        using CMPMIE = Field<_IER, 0, 1>; // Compare match Interrupt Enable
    };

    // Configuration Register
    struct _CFGR : Register<LPTIM1_BASE + 0xC, ReadWrite, _CFGR> {
        using ENC = Field<_CFGR, 24, 1>; // Encoder mode enable
        using COUNTMODE = Field<_CFGR, 23, 1>; // counter mode enabled
        using PRELOAD = Field<_CFGR, 22, 1>; // Registers update mode
        using WAVPOL = Field<_CFGR, 21, 1>; // Waveform shape polarity
        using WAVE = Field<_CFGR, 20, 1>; // Waveform shape
        using TIMOUT = Field<_CFGR, 19, 1>; // Timeout enable
        using TRIGEN = Field<_CFGR, 17, 2>; // Trigger enable and polarity
        using TRIGSEL = Field<_CFGR, 13, 3>; // Trigger selector
        using PRESC = Field<_CFGR, 9, 3>; // Clock prescaler
        using TRGFLT = Field<_CFGR, 6, 2>; // Configurable digital filter for trigger
        using CKFLT = Field<_CFGR, 3, 2>; // Configurable digital filter for external clock
        using CKPOL = Field<_CFGR, 1, 2>; // Clock Polarity
        using CKSEL = Field<_CFGR, 0, 1>; // Clock selector
    };

    // Control Register
    struct _CR : Register<LPTIM1_BASE + 0x10, ReadWrite, _CR> {
        using CNTSTRT = Field<_CR, 2, 1>; // Timer start in continuous mode
        using SNGSTRT = Field<_CR, 1, 1>; // LPTIM start in single mode
        using ENABLE = Field<_CR, 0, 1>; // LPTIM Enable
    };

    // Compare Register
    struct _CMP : Register<LPTIM1_BASE + 0x14, ReadWrite, _CMP> {
        using CMP = Field<_CMP, 0, 16>; // Compare value
    };

    // Autoreload Register
    struct _ARR : Register<LPTIM1_BASE + 0x18, ReadWrite, _ARR> {
        using ARR = Field<_ARR, 0, 16>; // Auto reload value
    };

    // Counter Register
    struct _CNT : Register<LPTIM1_BASE + 0x1C, ReadOnly, _CNT> {
        using CNT = Field<_CNT, 0, 16>; // Counter value
    };

} // namespace LPTIM1

// --------------------------------------------
// I2C1: Inter-integrated circuit
// Base address: 0x40005400
// --------------------------------------------

namespace I2C1 {
    static constexpr uint32_t I2C1_BASE = 0x40005400;

    // Control register 1
    struct _CR1 : Register<I2C1_BASE + 0x0, ReadWrite, _CR1> {
        using PE = Field<_CR1, 0, 1>; // Peripheral enable
        using TXIE = Field<_CR1, 1, 1>; // TX Interrupt enable
        using RXIE = Field<_CR1, 2, 1>; // RX Interrupt enable
        using ADDRIE = Field<_CR1, 3, 1>; // Address match interrupt enable (slave only)
        using NACKIE = Field<_CR1, 4, 1>; // Not acknowledge received interrupt enable
        using STOPIE = Field<_CR1, 5, 1>; // STOP detection Interrupt enable
        using TCIE = Field<_CR1, 6, 1>; // Transfer Complete interrupt enable
        using ERRIE = Field<_CR1, 7, 1>; // Error interrupts enable
        using DNF = Field<_CR1, 8, 4>; // Digital noise filter
        using ANFOFF = Field<_CR1, 12, 1>; // Analog noise filter OFF
        using TXDMAEN = Field<_CR1, 14, 1>; // DMA transmission requests enable
        using RXDMAEN = Field<_CR1, 15, 1>; // DMA reception requests enable
        using SBC = Field<_CR1, 16, 1>; // Slave byte control
        using NOSTRETCH = Field<_CR1, 17, 1>; // Clock stretching disable
        using WUPEN = Field<_CR1, 18, 1>; // Wakeup from STOP enable
        using GCEN = Field<_CR1, 19, 1>; // General call enable
        using SMBHEN = Field<_CR1, 20, 1>; // SMBus Host address enable
        using SMBDEN = Field<_CR1, 21, 1>; // SMBus Device Default address enable
        using ALERTEN = Field<_CR1, 22, 1>; // SMBUS alert enable
        using PECEN = Field<_CR1, 23, 1>; // PEC enable
    };

    // Control register 2
    struct _CR2 : Register<I2C1_BASE + 0x4, ReadWrite, _CR2> {
        using PECBYTE = Field<_CR2, 26, 1>; // Packet error checking byte
        using AUTOEND = Field<_CR2, 25, 1>; // Automatic end mode (master mode)
        using RELOAD = Field<_CR2, 24, 1>; // NBYTES reload mode
        using NBYTES = Field<_CR2, 16, 8>; // Number of bytes
        using NACK = Field<_CR2, 15, 1>; // NACK generation (slave mode)
        using STOP = Field<_CR2, 14, 1>; // Stop generation (master mode)
        using START = Field<_CR2, 13, 1>; // Start generation
        using HEAD10R = Field<_CR2, 12, 1>; // 10-bit address header only read direction (master receiver mode)
        using ADD10 = Field<_CR2, 11, 1>; // 10-bit addressing mode (master mode)
        using RD_WRN = Field<_CR2, 10, 1>; // Transfer direction (master mode)
        using SADD = Field<_CR2, 0, 10>; // Slave address bit (master mode)
    };

    // Own address register 1
    struct _OAR1 : Register<I2C1_BASE + 0x8, ReadWrite, _OAR1> {
        using OA1 = Field<_OAR1, 0, 10>; // Interface address
        using OA1MODE = Field<_OAR1, 10, 1>; // Own Address 1 10-bit mode
        using OA1EN = Field<_OAR1, 15, 1>; // Own Address 1 enable
    };

    // Own address register 2
    struct _OAR2 : Register<I2C1_BASE + 0xC, ReadWrite, _OAR2> {
        using OA2 = Field<_OAR2, 1, 7>; // Interface address
        using OA2MSK = Field<_OAR2, 8, 3>; // Own Address 2 masks
        using OA2EN = Field<_OAR2, 15, 1>; // Own Address 2 enable
    };

    // Timing register
    struct _TIMINGR : Register<I2C1_BASE + 0x10, ReadWrite, _TIMINGR> {
        using SCLL = Field<_TIMINGR, 0, 8>; // SCL low period (master mode)
        using SCLH = Field<_TIMINGR, 8, 8>; // SCL high period (master mode)
        using SDADEL = Field<_TIMINGR, 16, 4>; // Data hold time
        using SCLDEL = Field<_TIMINGR, 20, 4>; // Data setup time
        using PRESC = Field<_TIMINGR, 28, 4>; // Timing prescaler
    };

    // Status register 1
    struct _TIMEOUTR : Register<I2C1_BASE + 0x14, ReadWrite, _TIMEOUTR> {
        using TIMEOUTA = Field<_TIMEOUTR, 0, 12>; // Bus timeout A
        using TIDLE = Field<_TIMEOUTR, 12, 1>; // Idle clock timeout detection
        using TIMOUTEN = Field<_TIMEOUTR, 15, 1>; // Clock timeout enable
        using TIMEOUTB = Field<_TIMEOUTR, 16, 12>; // Bus timeout B
        using TEXTEN = Field<_TIMEOUTR, 31, 1>; // Extended clock timeout enable
    };

    // Interrupt and Status register
    struct _ISR : Register<I2C1_BASE + 0x18, ReadWrite, _ISR> {
        using ADDCODE = Field<_ISR, 17, 7>; // Address match code (Slave mode)
        using DIR = Field<_ISR, 16, 1>; // Transfer direction (Slave mode)
        using BUSY = Field<_ISR, 15, 1>; // Bus busy
        using ALERT = Field<_ISR, 13, 1>; // SMBus alert
        using TIMEOUT = Field<_ISR, 12, 1>; // Timeout or t_low detection flag
        using PECERR = Field<_ISR, 11, 1>; // PEC Error in reception
        using OVR = Field<_ISR, 10, 1>; // Overrun/Underrun (slave mode)
        using ARLO = Field<_ISR, 9, 1>; // Arbitration lost
        using BERR = Field<_ISR, 8, 1>; // Bus error
        using TCR = Field<_ISR, 7, 1>; // Transfer Complete Reload
        using TC = Field<_ISR, 6, 1>; // Transfer Complete (master mode)
        using STOPF = Field<_ISR, 5, 1>; // Stop detection flag
        using NACKF = Field<_ISR, 4, 1>; // Not acknowledge received flag
        using ADDR = Field<_ISR, 3, 1>; // Address matched (slave mode)
        using RXNE = Field<_ISR, 2, 1>; // Receive data register not empty (receivers)
        using TXIS = Field<_ISR, 1, 1>; // Transmit interrupt status (transmitters)
        using TXE = Field<_ISR, 0, 1>; // Transmit data register empty (transmitters)
    };

    // Interrupt clear register
    struct _ICR : Register<I2C1_BASE + 0x1C, WriteOnly, _ICR> {
        using ALERTCF = Field<_ICR, 13, 1>; // Alert flag clear
        using TIMOUTCF = Field<_ICR, 12, 1>; // Timeout detection flag clear
        using PECCF = Field<_ICR, 11, 1>; // PEC Error flag clear
        using OVRCF = Field<_ICR, 10, 1>; // Overrun/Underrun flag clear
        using ARLOCF = Field<_ICR, 9, 1>; // Arbitration lost flag clear
        using BERRCF = Field<_ICR, 8, 1>; // Bus error flag clear
        using STOPCF = Field<_ICR, 5, 1>; // Stop detection flag clear
        using NACKCF = Field<_ICR, 4, 1>; // Not Acknowledge flag clear
        using ADDRCF = Field<_ICR, 3, 1>; // Address Matched flag clear
    };

    // PEC register
    struct _PECR : Register<I2C1_BASE + 0x20, ReadOnly, _PECR> {
        using PEC = Field<_PECR, 0, 8>; // Packet error checking register
    };

    // Receive data register
    struct _RXDR : Register<I2C1_BASE + 0x24, ReadOnly, _RXDR> {
        using RXDATA = Field<_RXDR, 0, 8>; // 8-bit receive data
    };

    // Transmit data register
    struct _TXDR : Register<I2C1_BASE + 0x28, ReadWrite, _TXDR> {
        using TXDATA = Field<_TXDR, 0, 8>; // 8-bit transmit data
    };

} // namespace I2C1

// --------------------------------------------
// I2C2: 
// Base address: 0x40005800
// --------------------------------------------

namespace I2C2 {
    static constexpr uint32_t I2C2_BASE = 0x40005800;

} // namespace I2C2

// --------------------------------------------
// I2C3: 
// Base address: 0x40005C00
// --------------------------------------------

namespace I2C3 {
    static constexpr uint32_t I2C3_BASE = 0x40005C00;

} // namespace I2C3

// --------------------------------------------
// I2C4: 
// Base address: 0x40006000
// --------------------------------------------

namespace I2C4 {
    static constexpr uint32_t I2C4_BASE = 0x40006000;

} // namespace I2C4

// --------------------------------------------
// RTC: Real-time clock
// Base address: 0x40002800
// --------------------------------------------

namespace RTC {
    static constexpr uint32_t RTC_BASE = 0x40002800;

    // time register
    struct _TR : Register<RTC_BASE + 0x0, ReadWrite, _TR> {
        using PM = Field<_TR, 22, 1>; // AM/PM notation
        using HT = Field<_TR, 20, 2>; // Hour tens in BCD format
        using HU = Field<_TR, 16, 4>; // Hour units in BCD format
        using MNT = Field<_TR, 12, 3>; // Minute tens in BCD format
        using MNU = Field<_TR, 8, 4>; // Minute units in BCD format
        using ST = Field<_TR, 4, 3>; // Second tens in BCD format
        using SU = Field<_TR, 0, 4>; // Second units in BCD format
    };

    // date register
    struct _DR : Register<RTC_BASE + 0x4, ReadWrite, _DR> {
        using YT = Field<_DR, 20, 4>; // Year tens in BCD format
        using YU = Field<_DR, 16, 4>; // Year units in BCD format
        using WDU = Field<_DR, 13, 3>; // Week day units
        using MT = Field<_DR, 12, 1>; // Month tens in BCD format
        using MU = Field<_DR, 8, 4>; // Month units in BCD format
        using DT = Field<_DR, 4, 2>; // Date tens in BCD format
        using DU = Field<_DR, 0, 4>; // Date units in BCD format
    };

    // control register
    struct _CR : Register<RTC_BASE + 0x8, ReadWrite, _CR> {
        using WCKSEL = Field<_CR, 0, 3>; // Wakeup clock selection
        using TSEDGE = Field<_CR, 3, 1>; // Time-stamp event active edge
        using REFCKON = Field<_CR, 4, 1>; // Reference clock detection enable (50 or 60 Hz)
        using BYPSHAD = Field<_CR, 5, 1>; // Bypass the shadow registers
        using FMT = Field<_CR, 6, 1>; // Hour format
        using ALRAE = Field<_CR, 8, 1>; // Alarm A enable
        using ALRBE = Field<_CR, 9, 1>; // Alarm B enable
        using WUTE = Field<_CR, 10, 1>; // Wakeup timer enable
        using TSE = Field<_CR, 11, 1>; // Time stamp enable
        using ALRAIE = Field<_CR, 12, 1>; // Alarm A interrupt enable
        using ALRBIE = Field<_CR, 13, 1>; // Alarm B interrupt enable
        using WUTIE = Field<_CR, 14, 1>; // Wakeup timer interrupt enable
        using TSIE = Field<_CR, 15, 1>; // Time-stamp interrupt enable
        using ADD1H = Field<_CR, 16, 1>; // Add 1 hour (summer time change)
        using SUB1H = Field<_CR, 17, 1>; // Subtract 1 hour (winter time change)
        using BKP = Field<_CR, 18, 1>; // Backup
        using COSEL = Field<_CR, 19, 1>; // Calibration output selection
        using POL = Field<_CR, 20, 1>; // Output polarity
        using OSEL = Field<_CR, 21, 2>; // Output selection
        using COE = Field<_CR, 23, 1>; // Calibration output enable
        using ITSE = Field<_CR, 24, 1>; // timestamp on internal event enable
    };

    // initialization and status register
    struct _ISR : Register<RTC_BASE + 0xC, ReadWrite, _ISR> {
        using ALRAWF = Field<_ISR, 0, 1>; // Alarm A write flag
        using ALRBWF = Field<_ISR, 1, 1>; // Alarm B write flag
        using WUTWF = Field<_ISR, 2, 1>; // Wakeup timer write flag
        using SHPF = Field<_ISR, 3, 1>; // Shift operation pending
        using INITS = Field<_ISR, 4, 1>; // Initialization status flag
        using RSF = Field<_ISR, 5, 1>; // Registers synchronization flag
        using INITF = Field<_ISR, 6, 1>; // Initialization flag
        using INIT = Field<_ISR, 7, 1>; // Initialization mode
        using ALRAF = Field<_ISR, 8, 1>; // Alarm A flag
        using ALRBF = Field<_ISR, 9, 1>; // Alarm B flag
        using WUTF = Field<_ISR, 10, 1>; // Wakeup timer flag
        using TSF = Field<_ISR, 11, 1>; // Time-stamp flag
        using TSOVF = Field<_ISR, 12, 1>; // Time-stamp overflow flag
        using TAMP1F = Field<_ISR, 13, 1>; // Tamper detection flag
        using TAMP2F = Field<_ISR, 14, 1>; // RTC_TAMP2 detection flag
        using TAMP3F = Field<_ISR, 15, 1>; // RTC_TAMP3 detection flag
        using RECALPF = Field<_ISR, 16, 1>; // Recalibration pending Flag
    };

    // prescaler register
    struct _PRER : Register<RTC_BASE + 0x10, ReadWrite, _PRER> {
        using PREDIV_A = Field<_PRER, 16, 7>; // Asynchronous prescaler factor
        using PREDIV_S = Field<_PRER, 0, 15>; // Synchronous prescaler factor
    };

    // wakeup timer register
    struct _WUTR : Register<RTC_BASE + 0x14, ReadWrite, _WUTR> {
        using WUT = Field<_WUTR, 0, 16>; // Wakeup auto-reload value bits
    };

    // alarm A register
    struct _ALRMAR : Register<RTC_BASE + 0x1C, ReadWrite, _ALRMAR> {
        using MSK4 = Field<_ALRMAR, 31, 1>; // Alarm A date mask
        using WDSEL = Field<_ALRMAR, 30, 1>; // Week day selection
        using DT = Field<_ALRMAR, 28, 2>; // Date tens in BCD format
        using DU = Field<_ALRMAR, 24, 4>; // Date units or day in BCD format
        using MSK3 = Field<_ALRMAR, 23, 1>; // Alarm A hours mask
        using PM = Field<_ALRMAR, 22, 1>; // AM/PM notation
        using HT = Field<_ALRMAR, 20, 2>; // Hour tens in BCD format
        using HU = Field<_ALRMAR, 16, 4>; // Hour units in BCD format
        using MSK2 = Field<_ALRMAR, 15, 1>; // Alarm A minutes mask
        using MNT = Field<_ALRMAR, 12, 3>; // Minute tens in BCD format
        using MNU = Field<_ALRMAR, 8, 4>; // Minute units in BCD format
        using MSK1 = Field<_ALRMAR, 7, 1>; // Alarm A seconds mask
        using ST = Field<_ALRMAR, 4, 3>; // Second tens in BCD format
        using SU = Field<_ALRMAR, 0, 4>; // Second units in BCD format
    };

    // alarm B register
    struct _ALRMBR : Register<RTC_BASE + 0x20, ReadWrite, _ALRMBR> {
        using MSK4 = Field<_ALRMBR, 31, 1>; // Alarm B date mask
        using WDSEL = Field<_ALRMBR, 30, 1>; // Week day selection
        using DT = Field<_ALRMBR, 28, 2>; // Date tens in BCD format
        using DU = Field<_ALRMBR, 24, 4>; // Date units or day in BCD format
        using MSK3 = Field<_ALRMBR, 23, 1>; // Alarm B hours mask
        using PM = Field<_ALRMBR, 22, 1>; // AM/PM notation
        using HT = Field<_ALRMBR, 20, 2>; // Hour tens in BCD format
        using HU = Field<_ALRMBR, 16, 4>; // Hour units in BCD format
        using MSK2 = Field<_ALRMBR, 15, 1>; // Alarm B minutes mask
        using MNT = Field<_ALRMBR, 12, 3>; // Minute tens in BCD format
        using MNU = Field<_ALRMBR, 8, 4>; // Minute units in BCD format
        using MSK1 = Field<_ALRMBR, 7, 1>; // Alarm B seconds mask
        using ST = Field<_ALRMBR, 4, 3>; // Second tens in BCD format
        using SU = Field<_ALRMBR, 0, 4>; // Second units in BCD format
    };

    // write protection register
    struct _WPR : Register<RTC_BASE + 0x24, WriteOnly, _WPR> {
        using KEY = Field<_WPR, 0, 8>; // Write protection key
    };

    // sub second register
    struct _SSR : Register<RTC_BASE + 0x28, ReadOnly, _SSR> {
        using SS = Field<_SSR, 0, 16>; // Sub second value
    };

    // shift control register
    struct _SHIFTR : Register<RTC_BASE + 0x2C, WriteOnly, _SHIFTR> {
        using ADD1S = Field<_SHIFTR, 31, 1>; // Add one second
        using SUBFS = Field<_SHIFTR, 0, 15>; // Subtract a fraction of a second
    };

    // time stamp time register
    struct _TSTR : Register<RTC_BASE + 0x30, ReadOnly, _TSTR> {
        using SU = Field<_TSTR, 0, 4>; // Second units in BCD format
        using ST = Field<_TSTR, 4, 3>; // Second tens in BCD format
        using MNU = Field<_TSTR, 8, 4>; // Minute units in BCD format
        using MNT = Field<_TSTR, 12, 3>; // Minute tens in BCD format
        using HU = Field<_TSTR, 16, 4>; // Hour units in BCD format
        using HT = Field<_TSTR, 20, 2>; // Hour tens in BCD format
        using PM = Field<_TSTR, 22, 1>; // AM/PM notation
    };

    // time stamp date register
    struct _TSDR : Register<RTC_BASE + 0x34, ReadOnly, _TSDR> {
        using WDU = Field<_TSDR, 13, 3>; // Week day units
        using MT = Field<_TSDR, 12, 1>; // Month tens in BCD format
        using MU = Field<_TSDR, 8, 4>; // Month units in BCD format
        using DT = Field<_TSDR, 4, 2>; // Date tens in BCD format
        using DU = Field<_TSDR, 0, 4>; // Date units in BCD format
    };

    // timestamp sub second register
    struct _TSSSR : Register<RTC_BASE + 0x38, ReadOnly, _TSSSR> {
        using SS = Field<_TSSSR, 0, 16>; // Sub second value
    };

    // calibration register
    struct _CALR : Register<RTC_BASE + 0x3C, ReadWrite, _CALR> {
        using CALP = Field<_CALR, 15, 1>; // Increase frequency of RTC by 488.5 ppm
        using CALW8 = Field<_CALR, 14, 1>; // Use an 8-second calibration cycle period
        using CALW16 = Field<_CALR, 13, 1>; // Use a 16-second calibration cycle period
        using CALM = Field<_CALR, 0, 9>; // Calibration minus
    };

    // tamper configuration register
    struct _TAMPCR : Register<RTC_BASE + 0x40, ReadWrite, _TAMPCR> {
        using TAMP1E = Field<_TAMPCR, 0, 1>; // Tamper 1 detection enable
        using TAMP1TRG = Field<_TAMPCR, 1, 1>; // Active level for tamper 1
        using TAMPIE = Field<_TAMPCR, 2, 1>; // Tamper interrupt enable
        using TAMP2E = Field<_TAMPCR, 3, 1>; // Tamper 2 detection enable
        using TAMP2TRG = Field<_TAMPCR, 4, 1>; // Active level for tamper 2
        using TAMP3E = Field<_TAMPCR, 5, 1>; // Tamper 3 detection enable
        using TAMP3TRG = Field<_TAMPCR, 6, 1>; // Active level for tamper 3
        using TAMPTS = Field<_TAMPCR, 7, 1>; // Activate timestamp on tamper detection event
        using TAMPFREQ = Field<_TAMPCR, 8, 3>; // Tamper sampling frequency
        using TAMPFLT = Field<_TAMPCR, 11, 2>; // Tamper filter count
        using TAMPPRCH = Field<_TAMPCR, 13, 2>; // Tamper precharge duration
        using TAMPPUDIS = Field<_TAMPCR, 15, 1>; // TAMPER pull-up disable
        using TAMP1IE = Field<_TAMPCR, 16, 1>; // Tamper 1 interrupt enable
        using TAMP1NOERASE = Field<_TAMPCR, 17, 1>; // Tamper 1 no erase
        using TAMP1MF = Field<_TAMPCR, 18, 1>; // Tamper 1 mask flag
        using TAMP2IE = Field<_TAMPCR, 19, 1>; // Tamper 2 interrupt enable
        using TAMP2NOERASE = Field<_TAMPCR, 20, 1>; // Tamper 2 no erase
        using TAMP2MF = Field<_TAMPCR, 21, 1>; // Tamper 2 mask flag
        using TAMP3IE = Field<_TAMPCR, 22, 1>; // Tamper 3 interrupt enable
        using TAMP3NOERASE = Field<_TAMPCR, 23, 1>; // Tamper 3 no erase
        using TAMP3MF = Field<_TAMPCR, 24, 1>; // Tamper 3 mask flag
    };

    // alarm A sub second register
    struct _ALRMASSR : Register<RTC_BASE + 0x44, ReadWrite, _ALRMASSR> {
        using MASKSS = Field<_ALRMASSR, 24, 4>; // Mask the most-significant bits starting at this bit
        using SS = Field<_ALRMASSR, 0, 15>; // Sub seconds value
    };

    // alarm B sub second register
    struct _ALRMBSSR : Register<RTC_BASE + 0x48, ReadWrite, _ALRMBSSR> {
        using MASKSS = Field<_ALRMBSSR, 24, 4>; // Mask the most-significant bits starting at this bit
        using SS = Field<_ALRMBSSR, 0, 15>; // Sub seconds value
    };

    // option register
    struct _OR : Register<RTC_BASE + 0x4C, ReadWrite, _OR> {
        using RTC_ALARM_TYPE = Field<_OR, 0, 1>; // RTC_ALARM on PC13 output type
        using RTC_OUT_RMP = Field<_OR, 1, 1>; // RTC_OUT remap
    };

    // backup register
    struct _BKP0R : Register<RTC_BASE + 0x50, ReadWrite, _BKP0R> {
        using BKP = Field<_BKP0R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP1R : Register<RTC_BASE + 0x54, ReadWrite, _BKP1R> {
        using BKP = Field<_BKP1R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP2R : Register<RTC_BASE + 0x58, ReadWrite, _BKP2R> {
        using BKP = Field<_BKP2R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP3R : Register<RTC_BASE + 0x5C, ReadWrite, _BKP3R> {
        using BKP = Field<_BKP3R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP4R : Register<RTC_BASE + 0x60, ReadWrite, _BKP4R> {
        using BKP = Field<_BKP4R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP5R : Register<RTC_BASE + 0x64, ReadWrite, _BKP5R> {
        using BKP = Field<_BKP5R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP6R : Register<RTC_BASE + 0x68, ReadWrite, _BKP6R> {
        using BKP = Field<_BKP6R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP7R : Register<RTC_BASE + 0x6C, ReadWrite, _BKP7R> {
        using BKP = Field<_BKP7R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP8R : Register<RTC_BASE + 0x70, ReadWrite, _BKP8R> {
        using BKP = Field<_BKP8R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP9R : Register<RTC_BASE + 0x74, ReadWrite, _BKP9R> {
        using BKP = Field<_BKP9R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP10R : Register<RTC_BASE + 0x78, ReadWrite, _BKP10R> {
        using BKP = Field<_BKP10R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP11R : Register<RTC_BASE + 0x7C, ReadWrite, _BKP11R> {
        using BKP = Field<_BKP11R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP12R : Register<RTC_BASE + 0x80, ReadWrite, _BKP12R> {
        using BKP = Field<_BKP12R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP13R : Register<RTC_BASE + 0x84, ReadWrite, _BKP13R> {
        using BKP = Field<_BKP13R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP14R : Register<RTC_BASE + 0x88, ReadWrite, _BKP14R> {
        using BKP = Field<_BKP14R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP15R : Register<RTC_BASE + 0x8C, ReadWrite, _BKP15R> {
        using BKP = Field<_BKP15R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP16R : Register<RTC_BASE + 0x90, ReadWrite, _BKP16R> {
        using BKP = Field<_BKP16R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP17R : Register<RTC_BASE + 0x94, ReadWrite, _BKP17R> {
        using BKP = Field<_BKP17R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP18R : Register<RTC_BASE + 0x98, ReadWrite, _BKP18R> {
        using BKP = Field<_BKP18R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP19R : Register<RTC_BASE + 0x9C, ReadWrite, _BKP19R> {
        using BKP = Field<_BKP19R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP20R : Register<RTC_BASE + 0xA0, ReadWrite, _BKP20R> {
        using BKP = Field<_BKP20R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP21R : Register<RTC_BASE + 0xA4, ReadWrite, _BKP21R> {
        using BKP = Field<_BKP21R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP22R : Register<RTC_BASE + 0xA8, ReadWrite, _BKP22R> {
        using BKP = Field<_BKP22R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP23R : Register<RTC_BASE + 0xAC, ReadWrite, _BKP23R> {
        using BKP = Field<_BKP23R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP24R : Register<RTC_BASE + 0xB0, ReadWrite, _BKP24R> {
        using BKP = Field<_BKP24R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP25R : Register<RTC_BASE + 0xB4, ReadWrite, _BKP25R> {
        using BKP = Field<_BKP25R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP26R : Register<RTC_BASE + 0xB8, ReadWrite, _BKP26R> {
        using BKP = Field<_BKP26R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP27R : Register<RTC_BASE + 0xBC, ReadWrite, _BKP27R> {
        using BKP = Field<_BKP27R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP28R : Register<RTC_BASE + 0xC0, ReadWrite, _BKP28R> {
        using BKP = Field<_BKP28R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP29R : Register<RTC_BASE + 0xC4, ReadWrite, _BKP29R> {
        using BKP = Field<_BKP29R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP30R : Register<RTC_BASE + 0xC8, ReadWrite, _BKP30R> {
        using BKP = Field<_BKP30R, 0, 32>; // BKP
    };

    // backup register
    struct _BKP31R : Register<RTC_BASE + 0xCC, ReadWrite, _BKP31R> {
        using BKP = Field<_BKP31R, 0, 32>; // BKP
    };

} // namespace RTC

// --------------------------------------------
// USART6: Universal synchronous asynchronous receiver transmitter
// Base address: 0x40011400
// --------------------------------------------

namespace USART6 {
    static constexpr uint32_t USART6_BASE = 0x40011400;

    // Control register 1
    struct _CR1 : Register<USART6_BASE + 0x0, ReadWrite, _CR1> {
        using M1 = Field<_CR1, 28, 1>; // Word length
        using EOBIE = Field<_CR1, 27, 1>; // End of Block interrupt enable
        using RTOIE = Field<_CR1, 26, 1>; // Receiver timeout interrupt enable
        using DEAT4 = Field<_CR1, 25, 1>; // Driver Enable assertion time
        using DEAT3 = Field<_CR1, 24, 1>; // DEAT3
        using DEAT2 = Field<_CR1, 23, 1>; // DEAT2
        using DEAT1 = Field<_CR1, 22, 1>; // DEAT1
        using DEAT0 = Field<_CR1, 21, 1>; // DEAT0
        using DEDT4 = Field<_CR1, 20, 1>; // Driver Enable de-assertion time
        using DEDT3 = Field<_CR1, 19, 1>; // DEDT3
        using DEDT2 = Field<_CR1, 18, 1>; // DEDT2
        using DEDT1 = Field<_CR1, 17, 1>; // DEDT1
        using DEDT0 = Field<_CR1, 16, 1>; // DEDT0
        using OVER8 = Field<_CR1, 15, 1>; // Oversampling mode
        using CMIE = Field<_CR1, 14, 1>; // Character match interrupt enable
        using MME = Field<_CR1, 13, 1>; // Mute mode enable
        using M0 = Field<_CR1, 12, 1>; // Word length
        using WAKE = Field<_CR1, 11, 1>; // Receiver wakeup method
        using PCE = Field<_CR1, 10, 1>; // Parity control enable
        using PS = Field<_CR1, 9, 1>; // Parity selection
        using PEIE = Field<_CR1, 8, 1>; // PE interrupt enable
        using TXEIE = Field<_CR1, 7, 1>; // interrupt enable
        using TCIE = Field<_CR1, 6, 1>; // Transmission complete interrupt enable
        using RXNEIE = Field<_CR1, 5, 1>; // RXNE interrupt enable
        using IDLEIE = Field<_CR1, 4, 1>; // IDLE interrupt enable
        using TE = Field<_CR1, 3, 1>; // Transmitter enable
        using RE = Field<_CR1, 2, 1>; // Receiver enable
        using UESM = Field<_CR1, 1, 1>; // USART enable in Stop mode
        using UE = Field<_CR1, 0, 1>; // USART enable
    };

    // Control register 2
    struct _CR2 : Register<USART6_BASE + 0x4, ReadWrite, _CR2> {
        using ADD4_7 = Field<_CR2, 28, 4>; // Address of the USART node
        using ADD0_3 = Field<_CR2, 24, 4>; // Address of the USART node
        using RTOEN = Field<_CR2, 23, 1>; // Receiver timeout enable
        using ABRMOD1 = Field<_CR2, 22, 1>; // Auto baud rate mode
        using ABRMOD0 = Field<_CR2, 21, 1>; // ABRMOD0
        using ABREN = Field<_CR2, 20, 1>; // Auto baud rate enable
        using MSBFIRST = Field<_CR2, 19, 1>; // Most significant bit first
        using TAINV = Field<_CR2, 18, 1>; // Binary data inversion
        using TXINV = Field<_CR2, 17, 1>; // TX pin active level inversion
        using RXINV = Field<_CR2, 16, 1>; // RX pin active level inversion
        using SWAP = Field<_CR2, 15, 1>; // Swap TX/RX pins
        using LINEN = Field<_CR2, 14, 1>; // LIN mode enable
        using STOP = Field<_CR2, 12, 2>; // STOP bits
        using CLKEN = Field<_CR2, 11, 1>; // Clock enable
        using CPOL = Field<_CR2, 10, 1>; // Clock polarity
        using CPHA = Field<_CR2, 9, 1>; // Clock phase
        using LBCL = Field<_CR2, 8, 1>; // Last bit clock pulse
        using LBDIE = Field<_CR2, 6, 1>; // LIN break detection interrupt enable
        using LBDL = Field<_CR2, 5, 1>; // LIN break detection length
        using ADDM7 = Field<_CR2, 4, 1>; // 7-bit Address Detection/4-bit Address Detection
    };

    // Control register 3
    struct _CR3 : Register<USART6_BASE + 0x8, ReadWrite, _CR3> {
        using WUFIE = Field<_CR3, 22, 1>; // Wakeup from Stop mode interrupt enable
        using WUS = Field<_CR3, 20, 2>; // Wakeup from Stop mode interrupt flag selection
        using SCARCNT = Field<_CR3, 17, 3>; // Smartcard auto-retry count
        using DEP = Field<_CR3, 15, 1>; // Driver enable polarity selection
        using DEM = Field<_CR3, 14, 1>; // Driver enable mode
        using DDRE = Field<_CR3, 13, 1>; // DMA Disable on Reception Error
        using OVRDIS = Field<_CR3, 12, 1>; // Overrun Disable
        using ONEBIT = Field<_CR3, 11, 1>; // One sample bit method enable
        using CTSIE = Field<_CR3, 10, 1>; // CTS interrupt enable
        using CTSE = Field<_CR3, 9, 1>; // CTS enable
        using RTSE = Field<_CR3, 8, 1>; // RTS enable
        using DMAT = Field<_CR3, 7, 1>; // DMA enable transmitter
        using DMAR = Field<_CR3, 6, 1>; // DMA enable receiver
        using SCEN = Field<_CR3, 5, 1>; // Smartcard mode enable
        using NACK = Field<_CR3, 4, 1>; // Smartcard NACK enable
        using HDSEL = Field<_CR3, 3, 1>; // Half-duplex selection
        using IRLP = Field<_CR3, 2, 1>; // Ir low-power
        using IREN = Field<_CR3, 1, 1>; // Ir mode enable
        using EIE = Field<_CR3, 0, 1>; // Error interrupt enable
    };

    // Baud rate register
    struct _BRR : Register<USART6_BASE + 0xC, ReadWrite, _BRR> {
        using DIV_Mantissa = Field<_BRR, 4, 12>; // DIV_Mantissa
        using DIV_Fraction = Field<_BRR, 0, 4>; // DIV_Fraction
    };

    // Guard time and prescaler register
    struct _GTPR : Register<USART6_BASE + 0x10, ReadWrite, _GTPR> {
        using GT = Field<_GTPR, 8, 8>; // Guard time value
        using PSC = Field<_GTPR, 0, 8>; // Prescaler value
    };

    // Receiver timeout register
    struct _RTOR : Register<USART6_BASE + 0x14, ReadWrite, _RTOR> {
        using BLEN = Field<_RTOR, 24, 8>; // Block Length
        using RTO = Field<_RTOR, 0, 24>; // Receiver timeout value
    };

    // Request register
    struct _RQR : Register<USART6_BASE + 0x18, WriteOnly, _RQR> {
        using TXFRQ = Field<_RQR, 4, 1>; // Transmit data flush request
        using RXFRQ = Field<_RQR, 3, 1>; // Receive data flush request
        using MMRQ = Field<_RQR, 2, 1>; // Mute mode request
        using SBKRQ = Field<_RQR, 1, 1>; // Send break request
        using ABRRQ = Field<_RQR, 0, 1>; // Auto baud rate request
    };

    // Interrupt & status register
    struct _ISR : Register<USART6_BASE + 0x1C, ReadOnly, _ISR> {
        using REACK = Field<_ISR, 22, 1>; // REACK
        using TEACK = Field<_ISR, 21, 1>; // TEACK
        using WUF = Field<_ISR, 20, 1>; // WUF
        using RWU = Field<_ISR, 19, 1>; // RWU
        using SBKF = Field<_ISR, 18, 1>; // SBKF
        using CMF = Field<_ISR, 17, 1>; // CMF
        using BUSY = Field<_ISR, 16, 1>; // BUSY
        using ABRF = Field<_ISR, 15, 1>; // ABRF
        using ABRE = Field<_ISR, 14, 1>; // ABRE
        using EOBF = Field<_ISR, 12, 1>; // EOBF
        using RTOF = Field<_ISR, 11, 1>; // RTOF
        using CTS = Field<_ISR, 10, 1>; // CTS
        using CTSIF = Field<_ISR, 9, 1>; // CTSIF
        using LBDF = Field<_ISR, 8, 1>; // LBDF
        using TXE = Field<_ISR, 7, 1>; // TXE
        using TC = Field<_ISR, 6, 1>; // TC
        using RXNE = Field<_ISR, 5, 1>; // RXNE
        using IDLE = Field<_ISR, 4, 1>; // IDLE
        using ORE = Field<_ISR, 3, 1>; // ORE
        using NF = Field<_ISR, 2, 1>; // NF
        using FE = Field<_ISR, 1, 1>; // FE
        using PE = Field<_ISR, 0, 1>; // PE
    };

    // Interrupt flag clear register
    struct _ICR : Register<USART6_BASE + 0x20, WriteOnly, _ICR> {
        using WUCF = Field<_ICR, 20, 1>; // Wakeup from Stop mode clear flag
        using CMCF = Field<_ICR, 17, 1>; // Character match clear flag
        using EOBCF = Field<_ICR, 12, 1>; // End of block clear flag
        using RTOCF = Field<_ICR, 11, 1>; // Receiver timeout clear flag
        using CTSCF = Field<_ICR, 9, 1>; // CTS clear flag
        using LBDCF = Field<_ICR, 8, 1>; // LIN break detection clear flag
        using TCCF = Field<_ICR, 6, 1>; // Transmission complete clear flag
        using IDLECF = Field<_ICR, 4, 1>; // Idle line detected clear flag
        using ORECF = Field<_ICR, 3, 1>; // Overrun error clear flag
        using NCF = Field<_ICR, 2, 1>; // Noise detected clear flag
        using FECF = Field<_ICR, 1, 1>; // Framing error clear flag
        using PECF = Field<_ICR, 0, 1>; // Parity error clear flag
    };

    // Receive data register
    struct _RDR : Register<USART6_BASE + 0x24, ReadOnly, _RDR> {
        using RDR = Field<_RDR, 0, 9>; // Receive data value
    };

    // Transmit data register
    struct _TDR : Register<USART6_BASE + 0x28, ReadWrite, _TDR> {
        using TDR = Field<_TDR, 0, 9>; // Transmit data value
    };

} // namespace USART6

// --------------------------------------------
// USART1: 
// Base address: 0x40011000
// --------------------------------------------

namespace USART1 {
    static constexpr uint32_t USART1_BASE = 0x40011000;

} // namespace USART1

// --------------------------------------------
// USART3: 
// Base address: 0x40004800
// --------------------------------------------

namespace USART3 {
    static constexpr uint32_t USART3_BASE = 0x40004800;

} // namespace USART3

// --------------------------------------------
// USART2: 
// Base address: 0x40004400
// --------------------------------------------

namespace USART2 {
    static constexpr uint32_t USART2_BASE = 0x40004400;

} // namespace USART2

// --------------------------------------------
// UART5: 
// Base address: 0x40005000
// --------------------------------------------

namespace UART5 {
    static constexpr uint32_t UART5_BASE = 0x40005000;

} // namespace UART5

// --------------------------------------------
// UART4: 
// Base address: 0x40004C00
// --------------------------------------------

namespace UART4 {
    static constexpr uint32_t UART4_BASE = 0x40004C00;

} // namespace UART4

// --------------------------------------------
// UART8: 
// Base address: 0x40007C00
// --------------------------------------------

namespace UART8 {
    static constexpr uint32_t UART8_BASE = 0x40007C00;

} // namespace UART8

// --------------------------------------------
// UART7: 
// Base address: 0x40007800
// --------------------------------------------

namespace UART7 {
    static constexpr uint32_t UART7_BASE = 0x40007800;

} // namespace UART7

// --------------------------------------------
// OTG_FS_GLOBAL: USB on the go full speed
// Base address: 0x50000000
// --------------------------------------------

namespace OTG_FS_GLOBAL {
    static constexpr uint32_t OTG_FS_GLOBAL_BASE = 0x50000000;

    // OTG_FS control and status register (OTG_FS_GOTGCTL)
    struct _OTG_FS_GOTGCTL : Register<OTG_FS_GLOBAL_BASE + 0x0, ReadWrite, _OTG_FS_GOTGCTL> {
        using SRQSCS = Field<_OTG_FS_GOTGCTL, 0, 1>; // Session request success
        using SRQ = Field<_OTG_FS_GOTGCTL, 1, 1>; // Session request
        using HNGSCS = Field<_OTG_FS_GOTGCTL, 8, 1>; // Host negotiation success
        using HNPRQ = Field<_OTG_FS_GOTGCTL, 9, 1>; // HNP request
        using HSHNPEN = Field<_OTG_FS_GOTGCTL, 10, 1>; // Host set HNP enable
        using DHNPEN = Field<_OTG_FS_GOTGCTL, 11, 1>; // Device HNP enabled
        using CIDSTS = Field<_OTG_FS_GOTGCTL, 16, 1>; // Connector ID status
        using DBCT = Field<_OTG_FS_GOTGCTL, 17, 1>; // Long/short debounce time
        using ASVLD = Field<_OTG_FS_GOTGCTL, 18, 1>; // A-session valid
        using BSVLD = Field<_OTG_FS_GOTGCTL, 19, 1>; // B-session valid
        using VBVALOEN = Field<_OTG_FS_GOTGCTL, 2, 1>; // VBUS valid override enable
        using VBVALOVAL = Field<_OTG_FS_GOTGCTL, 3, 1>; // VBUS valid override value
        using AVALOEN = Field<_OTG_FS_GOTGCTL, 4, 1>; // A-peripheral session valid override enable
        using AVALOVAL = Field<_OTG_FS_GOTGCTL, 5, 1>; // A-peripheral session valid override value
        using BVALOEN = Field<_OTG_FS_GOTGCTL, 6, 1>; // B-peripheral session valid override enable
        using BVALOVAL = Field<_OTG_FS_GOTGCTL, 7, 1>; // B-peripheral session valid override value
        using EHEN = Field<_OTG_FS_GOTGCTL, 12, 1>; // Embedded host enable
        using OTGVER = Field<_OTG_FS_GOTGCTL, 20, 1>; // OTG version
    };

    // OTG_FS interrupt register (OTG_FS_GOTGINT)
    struct _OTG_FS_GOTGINT : Register<OTG_FS_GLOBAL_BASE + 0x4, ReadWrite, _OTG_FS_GOTGINT> {
        using SEDET = Field<_OTG_FS_GOTGINT, 2, 1>; // Session end detected
        using SRSSCHG = Field<_OTG_FS_GOTGINT, 8, 1>; // Session request success status change
        using HNSSCHG = Field<_OTG_FS_GOTGINT, 9, 1>; // Host negotiation success status change
        using HNGDET = Field<_OTG_FS_GOTGINT, 17, 1>; // Host negotiation detected
        using ADTOCHG = Field<_OTG_FS_GOTGINT, 18, 1>; // A-device timeout change
        using DBCDNE = Field<_OTG_FS_GOTGINT, 19, 1>; // Debounce done
        using IDCHNG = Field<_OTG_FS_GOTGINT, 20, 1>; // ID input pin changed
    };

    // OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
    struct _OTG_FS_GAHBCFG : Register<OTG_FS_GLOBAL_BASE + 0x8, ReadWrite, _OTG_FS_GAHBCFG> {
        using GINT = Field<_OTG_FS_GAHBCFG, 0, 1>; // Global interrupt mask
        using TXFELVL = Field<_OTG_FS_GAHBCFG, 7, 1>; // TxFIFO empty level
        using PTXFELVL = Field<_OTG_FS_GAHBCFG, 8, 1>; // Periodic TxFIFO empty level
    };

    // OTG_FS USB configuration register (OTG_FS_GUSBCFG)
    struct _OTG_FS_GUSBCFG : Register<OTG_FS_GLOBAL_BASE + 0xC, ReadWrite, _OTG_FS_GUSBCFG> {
        using TOCAL = Field<_OTG_FS_GUSBCFG, 0, 3>; // FS timeout calibration
        using PHYSEL = Field<_OTG_FS_GUSBCFG, 6, 1>; // Full Speed serial transceiver select
        using SRPCAP = Field<_OTG_FS_GUSBCFG, 8, 1>; // SRP-capable
        using HNPCAP = Field<_OTG_FS_GUSBCFG, 9, 1>; // HNP-capable
        using TRDT = Field<_OTG_FS_GUSBCFG, 10, 4>; // USB turnaround time
        using FHMOD = Field<_OTG_FS_GUSBCFG, 29, 1>; // Force host mode
        using FDMOD = Field<_OTG_FS_GUSBCFG, 30, 1>; // Force device mode
    };

    // OTG_FS reset register (OTG_FS_GRSTCTL)
    struct _OTG_FS_GRSTCTL : Register<OTG_FS_GLOBAL_BASE + 0x10, ReadWrite, _OTG_FS_GRSTCTL> {
        using CSRST = Field<_OTG_FS_GRSTCTL, 0, 1>; // Core soft reset
        using HSRST = Field<_OTG_FS_GRSTCTL, 1, 1>; // HCLK soft reset
        using FCRST = Field<_OTG_FS_GRSTCTL, 2, 1>; // Host frame counter reset
        using RXFFLSH = Field<_OTG_FS_GRSTCTL, 4, 1>; // RxFIFO flush
        using TXFFLSH = Field<_OTG_FS_GRSTCTL, 5, 1>; // TxFIFO flush
        using TXFNUM = Field<_OTG_FS_GRSTCTL, 6, 5>; // TxFIFO number
        using AHBIDL = Field<_OTG_FS_GRSTCTL, 31, 1>; // AHB master idle
    };

    // OTG_FS core interrupt register (OTG_FS_GINTSTS)
    struct _OTG_FS_GINTSTS : Register<OTG_FS_GLOBAL_BASE + 0x14, ReadWrite, _OTG_FS_GINTSTS> {
        using CMOD = Field<_OTG_FS_GINTSTS, 0, 1>; // Current mode of operation
        using MMIS = Field<_OTG_FS_GINTSTS, 1, 1>; // Mode mismatch interrupt
        using OTGINT = Field<_OTG_FS_GINTSTS, 2, 1>; // OTG interrupt
        using SOF = Field<_OTG_FS_GINTSTS, 3, 1>; // Start of frame
        using RXFLVL = Field<_OTG_FS_GINTSTS, 4, 1>; // RxFIFO non-empty
        using NPTXFE = Field<_OTG_FS_GINTSTS, 5, 1>; // Non-periodic TxFIFO empty
        using GINAKEFF = Field<_OTG_FS_GINTSTS, 6, 1>; // Global IN non-periodic NAK effective
        using GOUTNAKEFF = Field<_OTG_FS_GINTSTS, 7, 1>; // Global OUT NAK effective
        using ESUSP = Field<_OTG_FS_GINTSTS, 10, 1>; // Early suspend
        using USBSUSP = Field<_OTG_FS_GINTSTS, 11, 1>; // USB suspend
        using USBRST = Field<_OTG_FS_GINTSTS, 12, 1>; // USB reset
        using ENUMDNE = Field<_OTG_FS_GINTSTS, 13, 1>; // Enumeration done
        using ISOODRP = Field<_OTG_FS_GINTSTS, 14, 1>; // Isochronous OUT packet dropped interrupt
        using EOPF = Field<_OTG_FS_GINTSTS, 15, 1>; // End of periodic frame interrupt
        using IEPINT = Field<_OTG_FS_GINTSTS, 18, 1>; // IN endpoint interrupt
        using OEPINT = Field<_OTG_FS_GINTSTS, 19, 1>; // OUT endpoint interrupt
        using IISOIXFR = Field<_OTG_FS_GINTSTS, 20, 1>; // Incomplete isochronous IN transfer
        using IPXFR_INCOMPISOOUT = Field<_OTG_FS_GINTSTS, 21, 1>; // Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)
        using HPRTINT = Field<_OTG_FS_GINTSTS, 24, 1>; // Host port interrupt
        using HCINT = Field<_OTG_FS_GINTSTS, 25, 1>; // Host channels interrupt
        using PTXFE = Field<_OTG_FS_GINTSTS, 26, 1>; // Periodic TxFIFO empty
        using CIDSCHG = Field<_OTG_FS_GINTSTS, 28, 1>; // Connector ID status change
        using DISCINT = Field<_OTG_FS_GINTSTS, 29, 1>; // Disconnect detected interrupt
        using SRQINT = Field<_OTG_FS_GINTSTS, 30, 1>; // Session request/new session detected interrupt
        using WKUPINT = Field<_OTG_FS_GINTSTS, 31, 1>; // Resume/remote wakeup detected interrupt
        using RSTDET = Field<_OTG_FS_GINTSTS, 23, 1>; // Reset detected interrupt
    };

    // OTG_FS interrupt mask register (OTG_FS_GINTMSK)
    struct _OTG_FS_GINTMSK : Register<OTG_FS_GLOBAL_BASE + 0x18, ReadWrite, _OTG_FS_GINTMSK> {
        using MMISM = Field<_OTG_FS_GINTMSK, 1, 1>; // Mode mismatch interrupt mask
        using OTGINT = Field<_OTG_FS_GINTMSK, 2, 1>; // OTG interrupt mask
        using SOFM = Field<_OTG_FS_GINTMSK, 3, 1>; // Start of frame mask
        using RXFLVLM = Field<_OTG_FS_GINTMSK, 4, 1>; // Receive FIFO non-empty mask
        using NPTXFEM = Field<_OTG_FS_GINTMSK, 5, 1>; // Non-periodic TxFIFO empty mask
        using GINAKEFFM = Field<_OTG_FS_GINTMSK, 6, 1>; // Global non-periodic IN NAK effective mask
        using GONAKEFFM = Field<_OTG_FS_GINTMSK, 7, 1>; // Global OUT NAK effective mask
        using ESUSPM = Field<_OTG_FS_GINTMSK, 10, 1>; // Early suspend mask
        using USBSUSPM = Field<_OTG_FS_GINTMSK, 11, 1>; // USB suspend mask
        using USBRST = Field<_OTG_FS_GINTMSK, 12, 1>; // USB reset mask
        using ENUMDNEM = Field<_OTG_FS_GINTMSK, 13, 1>; // Enumeration done mask
        using ISOODRPM = Field<_OTG_FS_GINTMSK, 14, 1>; // Isochronous OUT packet dropped interrupt mask
        using EOPFM = Field<_OTG_FS_GINTMSK, 15, 1>; // End of periodic frame interrupt mask
        using IEPINT = Field<_OTG_FS_GINTMSK, 18, 1>; // IN endpoints interrupt mask
        using OEPINT = Field<_OTG_FS_GINTMSK, 19, 1>; // OUT endpoints interrupt mask
        using IISOIXFRM = Field<_OTG_FS_GINTMSK, 20, 1>; // Incomplete isochronous IN transfer mask
        using IPXFRM_IISOOXFRM = Field<_OTG_FS_GINTMSK, 21, 1>; // Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)
        using PRTIM = Field<_OTG_FS_GINTMSK, 24, 1>; // Host port interrupt mask
        using HCIM = Field<_OTG_FS_GINTMSK, 25, 1>; // Host channels interrupt mask
        using PTXFEM = Field<_OTG_FS_GINTMSK, 26, 1>; // Periodic TxFIFO empty mask
        using CIDSCHGM = Field<_OTG_FS_GINTMSK, 28, 1>; // Connector ID status change mask
        using DISCINT = Field<_OTG_FS_GINTMSK, 29, 1>; // Disconnect detected interrupt mask
        using SRQIM = Field<_OTG_FS_GINTMSK, 30, 1>; // Session request/new session detected interrupt mask
        using WUIM = Field<_OTG_FS_GINTMSK, 31, 1>; // Resume/remote wakeup detected interrupt mask
        using RSTDETM = Field<_OTG_FS_GINTMSK, 23, 1>; // Reset detected interrupt mask
        using LPMIN = Field<_OTG_FS_GINTMSK, 27, 1>; // LPM interrupt mask
    };

    // OTG_FS Receive status debug read(Device mode)
    struct _OTG_FS_GRXSTSR_Device : Register<OTG_FS_GLOBAL_BASE + 0x1C, ReadOnly, _OTG_FS_GRXSTSR_Device> {
        using EPNUM = Field<_OTG_FS_GRXSTSR_Device, 0, 4>; // Endpoint number
        using BCNT = Field<_OTG_FS_GRXSTSR_Device, 4, 11>; // Byte count
        using DPID = Field<_OTG_FS_GRXSTSR_Device, 15, 2>; // Data PID
        using PKTSTS = Field<_OTG_FS_GRXSTSR_Device, 17, 4>; // Packet status
        using FRMNUM = Field<_OTG_FS_GRXSTSR_Device, 21, 4>; // Frame number
    };

    // OTG_FS Receive status debug read(Host mode)
    struct _OTG_FS_GRXSTSR_Host : Register<OTG_FS_GLOBAL_BASE + 0x1C, ReadOnly, _OTG_FS_GRXSTSR_Host> {
        using CHNUM = Field<_OTG_FS_GRXSTSR_Host, 0, 4>; // Endpoint number
        using BCNT = Field<_OTG_FS_GRXSTSR_Host, 4, 11>; // Byte count
        using DPID = Field<_OTG_FS_GRXSTSR_Host, 15, 2>; // Data PID
        using PKTSTS = Field<_OTG_FS_GRXSTSR_Host, 17, 4>; // Packet status
    };

    // OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
    struct _OTG_FS_GRXFSIZ : Register<OTG_FS_GLOBAL_BASE + 0x24, ReadWrite, _OTG_FS_GRXFSIZ> {
        using RXFD = Field<_OTG_FS_GRXFSIZ, 0, 16>; // RxFIFO depth
    };

    // OTG_FS Endpoint 0 Transmit FIFO size
    struct _OTG_FS_DIEPTXF0_Device : Register<OTG_FS_GLOBAL_BASE + 0x28, ReadWrite, _OTG_FS_DIEPTXF0_Device> {
        using TX0FSA = Field<_OTG_FS_DIEPTXF0_Device, 0, 16>; // Endpoint 0 transmit RAM start address
        using TX0FD = Field<_OTG_FS_DIEPTXF0_Device, 16, 16>; // Endpoint 0 TxFIFO depth
    };

    // OTG_FS Host non-periodic transmit FIFO size register
    struct _OTG_FS_HNPTXFSIZ_Host : Register<OTG_FS_GLOBAL_BASE + 0x28, ReadWrite, _OTG_FS_HNPTXFSIZ_Host> {
        using NPTXFSA = Field<_OTG_FS_HNPTXFSIZ_Host, 0, 16>; // Non-periodic transmit RAM start address
        using NPTXFD = Field<_OTG_FS_HNPTXFSIZ_Host, 16, 16>; // Non-periodic TxFIFO depth
    };

    // OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
    struct _OTG_FS_HNPTXSTS : Register<OTG_FS_GLOBAL_BASE + 0x2C, ReadOnly, _OTG_FS_HNPTXSTS> {
        using NPTXFSAV = Field<_OTG_FS_HNPTXSTS, 0, 16>; // Non-periodic TxFIFO space available
        using NPTQXSAV = Field<_OTG_FS_HNPTXSTS, 16, 8>; // Non-periodic transmit request queue space available
        using NPTXQTOP = Field<_OTG_FS_HNPTXSTS, 24, 7>; // Top of the non-periodic transmit request queue
    };

    // OTG_FS general core configuration register (OTG_FS_GCCFG)
    struct _OTG_FS_GCCFG : Register<OTG_FS_GLOBAL_BASE + 0x38, ReadWrite, _OTG_FS_GCCFG> {
        using PWRDWN = Field<_OTG_FS_GCCFG, 16, 1>; // Power down
        using BCDEN = Field<_OTG_FS_GCCFG, 17, 1>; // Battery charging detector (BCD) enable
        using DCDEN = Field<_OTG_FS_GCCFG, 18, 1>; // Data contact detection (DCD) mode enable
        using PDEN = Field<_OTG_FS_GCCFG, 19, 1>; // Primary detection (PD) mode enable
        using SDEN = Field<_OTG_FS_GCCFG, 20, 1>; // Secondary detection (SD) mode enable
        using VBDEN = Field<_OTG_FS_GCCFG, 21, 1>; // USB VBUS detection enable
        using DCDET = Field<_OTG_FS_GCCFG, 0, 1>; // Data contact detection (DCD) status
        using PDET = Field<_OTG_FS_GCCFG, 1, 1>; // Primary detection (PD) status
        using SDET = Field<_OTG_FS_GCCFG, 2, 1>; // Secondary detection (SD) status
        using PS2DET = Field<_OTG_FS_GCCFG, 3, 1>; // DM pull-up detection status
    };

    // core ID register
    struct _OTG_FS_CID : Register<OTG_FS_GLOBAL_BASE + 0x3C, ReadWrite, _OTG_FS_CID> {
        using PRODUCT_ID = Field<_OTG_FS_CID, 0, 32>; // Product ID field
    };

    // OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
    struct _OTG_FS_HPTXFSIZ : Register<OTG_FS_GLOBAL_BASE + 0x100, ReadWrite, _OTG_FS_HPTXFSIZ> {
        using PTXSA = Field<_OTG_FS_HPTXFSIZ, 0, 16>; // Host periodic TxFIFO start address
        using PTXFSIZ = Field<_OTG_FS_HPTXFSIZ, 16, 16>; // Host periodic TxFIFO depth
    };

    // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF1)
    struct _OTG_FS_DIEPTXF1 : Register<OTG_FS_GLOBAL_BASE + 0x104, ReadWrite, _OTG_FS_DIEPTXF1> {
        using INEPTXSA = Field<_OTG_FS_DIEPTXF1, 0, 16>; // IN endpoint FIFO2 transmit RAM start address
        using INEPTXFD = Field<_OTG_FS_DIEPTXF1, 16, 16>; // IN endpoint TxFIFO depth
    };

    // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF2)
    struct _OTG_FS_DIEPTXF2 : Register<OTG_FS_GLOBAL_BASE + 0x108, ReadWrite, _OTG_FS_DIEPTXF2> {
        using INEPTXSA = Field<_OTG_FS_DIEPTXF2, 0, 16>; // IN endpoint FIFO3 transmit RAM start address
        using INEPTXFD = Field<_OTG_FS_DIEPTXF2, 16, 16>; // IN endpoint TxFIFO depth
    };

    // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF3)
    struct _OTG_FS_DIEPTXF3 : Register<OTG_FS_GLOBAL_BASE + 0x10C, ReadWrite, _OTG_FS_DIEPTXF3> {
        using INEPTXSA = Field<_OTG_FS_DIEPTXF3, 0, 16>; // IN endpoint FIFO4 transmit RAM start address
        using INEPTXFD = Field<_OTG_FS_DIEPTXF3, 16, 16>; // IN endpoint TxFIFO depth
    };

    // OTG status read and pop register (Device mode)
    struct _OTG_FS_GRXSTSP_Device : Register<OTG_FS_GLOBAL_BASE + 0x20, ReadOnly, _OTG_FS_GRXSTSP_Device> {
        using EPNUM = Field<_OTG_FS_GRXSTSP_Device, 0, 4>; // Endpoint number
        using BCNT = Field<_OTG_FS_GRXSTSP_Device, 4, 11>; // Byte count
        using DPID = Field<_OTG_FS_GRXSTSP_Device, 15, 2>; // Data PID
        using PKTSTS = Field<_OTG_FS_GRXSTSP_Device, 17, 4>; // Packet status
        using FRMNUM = Field<_OTG_FS_GRXSTSP_Device, 21, 4>; // Frame number
    };

    // OTG status read and pop register (Host mode)
    struct _OTG_FS_GRXSTSP_Host : Register<OTG_FS_GLOBAL_BASE + 0x20, ReadOnly, _OTG_FS_GRXSTSP_Host> {
        using CHNUM = Field<_OTG_FS_GRXSTSP_Host, 0, 4>; // Channel number
        using BCNT = Field<_OTG_FS_GRXSTSP_Host, 4, 11>; // Byte count
        using DPID = Field<_OTG_FS_GRXSTSP_Host, 15, 2>; // Data PID
        using PKTSTS = Field<_OTG_FS_GRXSTSP_Host, 17, 4>; // Packet status
    };

    // OTG I2C access register
    struct _OTG_FS_GI2CCTL : Register<OTG_FS_GLOBAL_BASE + 0x30, ReadWrite, _OTG_FS_GI2CCTL> {
        using RWDATA = Field<_OTG_FS_GI2CCTL, 0, 8>; // I2C Read/Write Data
        using REGADDR = Field<_OTG_FS_GI2CCTL, 8, 8>; // I2C Register Address
        using ADDR = Field<_OTG_FS_GI2CCTL, 16, 7>; // I2C Address
        using I2CEN = Field<_OTG_FS_GI2CCTL, 23, 1>; // I2C Enable
        using ACK = Field<_OTG_FS_GI2CCTL, 24, 1>; // I2C ACK
        using I2CDEVADR = Field<_OTG_FS_GI2CCTL, 26, 2>; // I2C Device Address
        using I2CDATSE0 = Field<_OTG_FS_GI2CCTL, 28, 1>; // I2C DatSe0 USB mode
        using RW = Field<_OTG_FS_GI2CCTL, 30, 1>; // Read/Write Indicator
        using BSYDNE = Field<_OTG_FS_GI2CCTL, 31, 1>; // I2C Busy/Done
    };

    // OTG power down register
    struct _OTG_FS_GPWRDN : Register<OTG_FS_GLOBAL_BASE + 0x58, ReadWrite, _OTG_FS_GPWRDN> {
        using ADPMEN = Field<_OTG_FS_GPWRDN, 0, 1>; // ADP module enable
        using ADPIF = Field<_OTG_FS_GPWRDN, 23, 1>; // ADP interrupt flag
    };

    // OTG ADP timer, control and status register
    struct _OTG_FS_GADPCTL : Register<OTG_FS_GLOBAL_BASE + 0x60, ReadWrite, _OTG_FS_GADPCTL> {
        using PRBDSCHG = Field<_OTG_FS_GADPCTL, 0, 2>; // Probe discharge
        using PRBDELTA = Field<_OTG_FS_GADPCTL, 2, 2>; // Probe delta
        using PRBPER = Field<_OTG_FS_GADPCTL, 4, 2>; // Probe period
        using RTIM = Field<_OTG_FS_GADPCTL, 6, 11>; // Ramp time
        using ENAPRB = Field<_OTG_FS_GADPCTL, 17, 1>; // Enable probe
        using ENASNS = Field<_OTG_FS_GADPCTL, 18, 1>; // Enable sense
        using ADPRST = Field<_OTG_FS_GADPCTL, 19, 1>; // ADP reset
        using ADPEN = Field<_OTG_FS_GADPCTL, 20, 1>; // ADP enable
        using ADPPRBIF = Field<_OTG_FS_GADPCTL, 21, 1>; // ADP probe interrupt flag
        using ADPSNSIF = Field<_OTG_FS_GADPCTL, 22, 1>; // ADP sense interrupt flag
        using ADPTOIF = Field<_OTG_FS_GADPCTL, 23, 1>; // ADP timeout interrupt flag
        using ADPPRBIM = Field<_OTG_FS_GADPCTL, 24, 1>; // ADP probe interrupt mask
        using ADPSNSIM = Field<_OTG_FS_GADPCTL, 25, 1>; // ADP sense interrupt mask
        using ADPTOIM = Field<_OTG_FS_GADPCTL, 26, 1>; // ADP timeout interrupt mask
        using AR = Field<_OTG_FS_GADPCTL, 27, 2>; // Access request
    };

    // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF4)
    struct _OTG_FS_DIEPTXF4 : Register<OTG_FS_GLOBAL_BASE + 0x110, ReadWrite, _OTG_FS_DIEPTXF4> {
        using INEPTXSA = Field<_OTG_FS_DIEPTXF4, 0, 16>; // IN endpoint FIFOx transmit RAM start address
        using INEPTXFD = Field<_OTG_FS_DIEPTXF4, 16, 16>; // IN endpoint Tx FIFO depth
    };

    // OTG_FS device IN endpoint transmit FIFO size register (OTG_FS_DIEPTXF5)
    struct _OTG_FS_DIEPTXF5 : Register<OTG_FS_GLOBAL_BASE + 0x114, ReadWrite, _OTG_FS_DIEPTXF5> {
        using INEPTXSA = Field<_OTG_FS_DIEPTXF5, 0, 16>; // IN endpoint FIFOx transmit RAM start address
        using INEPTXFD = Field<_OTG_FS_DIEPTXF5, 16, 16>; // IN endpoint Tx FIFO depth
    };

    // OTG core LPM configuration register
    struct _OTG_FS_GLPMCFG : Register<OTG_FS_GLOBAL_BASE + 0x54, ReadWrite, _OTG_FS_GLPMCFG> {
        using LPMEN = Field<_OTG_FS_GLPMCFG, 0, 1>; // LPM support enable
        using LPMACK = Field<_OTG_FS_GLPMCFG, 1, 1>; // LPM token acknowledge enable
        using BESL = Field<_OTG_FS_GLPMCFG, 2, 4>; // Best effort service latency
        using REMWAKE = Field<_OTG_FS_GLPMCFG, 6, 1>; // bRemoteWake value
        using L1SSEN = Field<_OTG_FS_GLPMCFG, 7, 1>; // L1 Shallow Sleep enable
        using BESLTHRS = Field<_OTG_FS_GLPMCFG, 8, 4>; // BESL threshold
        using L1DSEN = Field<_OTG_FS_GLPMCFG, 12, 1>; // L1 deep sleep enable
        using LPMRST = Field<_OTG_FS_GLPMCFG, 13, 2>; // LPM response
        using SLPSTS = Field<_OTG_FS_GLPMCFG, 15, 1>; // Port sleep status
        using L1RSMOK = Field<_OTG_FS_GLPMCFG, 16, 1>; // Sleep State Resume OK
        using LPMCHIDX = Field<_OTG_FS_GLPMCFG, 17, 4>; // LPM Channel Index
        using LPMRCNT = Field<_OTG_FS_GLPMCFG, 21, 3>; // LPM retry count
        using SNDLPM = Field<_OTG_FS_GLPMCFG, 24, 1>; // Send LPM transaction
        using LPMRCNTSTS = Field<_OTG_FS_GLPMCFG, 25, 3>; // LPM retry count status
        using ENBESL = Field<_OTG_FS_GLPMCFG, 28, 1>; // Enable best effort service latency
    };

} // namespace OTG_FS_GLOBAL

// --------------------------------------------
// OTG_HS_GLOBAL: USB on the go high speed
// Base address: 0x40040000
// --------------------------------------------

namespace OTG_HS_GLOBAL {
    static constexpr uint32_t OTG_HS_GLOBAL_BASE = 0x40040000;

    // OTG_HS control and status register
    struct _OTG_HS_GOTGCTL : Register<OTG_HS_GLOBAL_BASE + 0x0, ReadWrite, _OTG_HS_GOTGCTL> {
        using SRQSCS = Field<_OTG_HS_GOTGCTL, 0, 1>; // Session request success
        using SRQ = Field<_OTG_HS_GOTGCTL, 1, 1>; // Session request
        using HNGSCS = Field<_OTG_HS_GOTGCTL, 8, 1>; // Host negotiation success
        using HNPRQ = Field<_OTG_HS_GOTGCTL, 9, 1>; // HNP request
        using HSHNPEN = Field<_OTG_HS_GOTGCTL, 10, 1>; // Host set HNP enable
        using DHNPEN = Field<_OTG_HS_GOTGCTL, 11, 1>; // Device HNP enabled
        using CIDSTS = Field<_OTG_HS_GOTGCTL, 16, 1>; // Connector ID status
        using DBCT = Field<_OTG_HS_GOTGCTL, 17, 1>; // Long/short debounce time
        using ASVLD = Field<_OTG_HS_GOTGCTL, 18, 1>; // A-session valid
        using BSVLD = Field<_OTG_HS_GOTGCTL, 19, 1>; // B-session valid
        using EHEN = Field<_OTG_HS_GOTGCTL, 12, 1>; // Embedded host enable
    };

    // OTG_HS interrupt register
    struct _OTG_HS_GOTGINT : Register<OTG_HS_GLOBAL_BASE + 0x4, ReadWrite, _OTG_HS_GOTGINT> {
        using SEDET = Field<_OTG_HS_GOTGINT, 2, 1>; // Session end detected
        using SRSSCHG = Field<_OTG_HS_GOTGINT, 8, 1>; // Session request success status change
        using HNSSCHG = Field<_OTG_HS_GOTGINT, 9, 1>; // Host negotiation success status change
        using HNGDET = Field<_OTG_HS_GOTGINT, 17, 1>; // Host negotiation detected
        using ADTOCHG = Field<_OTG_HS_GOTGINT, 18, 1>; // A-device timeout change
        using DBCDNE = Field<_OTG_HS_GOTGINT, 19, 1>; // Debounce done
        using IDCHNG = Field<_OTG_HS_GOTGINT, 20, 1>; // ID input pin changed
    };

    // OTG_HS AHB configuration register
    struct _OTG_HS_GAHBCFG : Register<OTG_HS_GLOBAL_BASE + 0x8, ReadWrite, _OTG_HS_GAHBCFG> {
        using GINT = Field<_OTG_HS_GAHBCFG, 0, 1>; // Global interrupt mask
        using HBSTLEN = Field<_OTG_HS_GAHBCFG, 1, 4>; // Burst length/type
        using DMAEN = Field<_OTG_HS_GAHBCFG, 5, 1>; // DMA enable
        using TXFELVL = Field<_OTG_HS_GAHBCFG, 7, 1>; // TxFIFO empty level
        using PTXFELVL = Field<_OTG_HS_GAHBCFG, 8, 1>; // Periodic TxFIFO empty level
    };

    // OTG_HS USB configuration register
    struct _OTG_HS_GUSBCFG : Register<OTG_HS_GLOBAL_BASE + 0xC, ReadWrite, _OTG_HS_GUSBCFG> {
        using TOCAL = Field<_OTG_HS_GUSBCFG, 0, 3>; // FS timeout calibration
        using PHYSEL = Field<_OTG_HS_GUSBCFG, 6, 1>; // USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
        using SRPCAP = Field<_OTG_HS_GUSBCFG, 8, 1>; // SRP-capable
        using HNPCAP = Field<_OTG_HS_GUSBCFG, 9, 1>; // HNP-capable
        using TRDT = Field<_OTG_HS_GUSBCFG, 10, 4>; // USB turnaround time
        using PHYLPCS = Field<_OTG_HS_GUSBCFG, 15, 1>; // PHY Low-power clock select
        using ULPIFSLS = Field<_OTG_HS_GUSBCFG, 17, 1>; // ULPI FS/LS select
        using ULPIAR = Field<_OTG_HS_GUSBCFG, 18, 1>; // ULPI Auto-resume
        using ULPICSM = Field<_OTG_HS_GUSBCFG, 19, 1>; // ULPI Clock SuspendM
        using ULPIEVBUSD = Field<_OTG_HS_GUSBCFG, 20, 1>; // ULPI External VBUS Drive
        using ULPIEVBUSI = Field<_OTG_HS_GUSBCFG, 21, 1>; // ULPI external VBUS indicator
        using TSDPS = Field<_OTG_HS_GUSBCFG, 22, 1>; // TermSel DLine pulsing selection
        using PCCI = Field<_OTG_HS_GUSBCFG, 23, 1>; // Indicator complement
        using PTCI = Field<_OTG_HS_GUSBCFG, 24, 1>; // Indicator pass through
        using ULPIIPD = Field<_OTG_HS_GUSBCFG, 25, 1>; // ULPI interface protect disable
        using FHMOD = Field<_OTG_HS_GUSBCFG, 29, 1>; // Forced host mode
        using FDMOD = Field<_OTG_HS_GUSBCFG, 30, 1>; // Forced peripheral mode
    };

    // OTG_HS reset register
    struct _OTG_HS_GRSTCTL : Register<OTG_HS_GLOBAL_BASE + 0x10, ReadWrite, _OTG_HS_GRSTCTL> {
        using CSRST = Field<_OTG_HS_GRSTCTL, 0, 1>; // Core soft reset
        using HSRST = Field<_OTG_HS_GRSTCTL, 1, 1>; // HCLK soft reset
        using FCRST = Field<_OTG_HS_GRSTCTL, 2, 1>; // Host frame counter reset
        using RXFFLSH = Field<_OTG_HS_GRSTCTL, 4, 1>; // RxFIFO flush
        using TXFFLSH = Field<_OTG_HS_GRSTCTL, 5, 1>; // TxFIFO flush
        using TXFNUM = Field<_OTG_HS_GRSTCTL, 6, 5>; // TxFIFO number
        using AHBIDL = Field<_OTG_HS_GRSTCTL, 31, 1>; // AHB master idle
        using DMAREQ = Field<_OTG_HS_GRSTCTL, 30, 1>; // DMA request signal enabled for USB OTG HS
    };

    // OTG_HS core interrupt register
    struct _OTG_HS_GINTSTS : Register<OTG_HS_GLOBAL_BASE + 0x14, ReadWrite, _OTG_HS_GINTSTS> {
        using CMOD = Field<_OTG_HS_GINTSTS, 0, 1>; // Current mode of operation
        using MMIS = Field<_OTG_HS_GINTSTS, 1, 1>; // Mode mismatch interrupt
        using OTGINT = Field<_OTG_HS_GINTSTS, 2, 1>; // OTG interrupt
        using SOF = Field<_OTG_HS_GINTSTS, 3, 1>; // Start of frame
        using RXFLVL = Field<_OTG_HS_GINTSTS, 4, 1>; // RxFIFO nonempty
        using NPTXFE = Field<_OTG_HS_GINTSTS, 5, 1>; // Nonperiodic TxFIFO empty
        using GINAKEFF = Field<_OTG_HS_GINTSTS, 6, 1>; // Global IN nonperiodic NAK effective
        using BOUTNAKEFF = Field<_OTG_HS_GINTSTS, 7, 1>; // Global OUT NAK effective
        using ESUSP = Field<_OTG_HS_GINTSTS, 10, 1>; // Early suspend
        using USBSUSP = Field<_OTG_HS_GINTSTS, 11, 1>; // USB suspend
        using USBRST = Field<_OTG_HS_GINTSTS, 12, 1>; // USB reset
        using ENUMDNE = Field<_OTG_HS_GINTSTS, 13, 1>; // Enumeration done
        using ISOODRP = Field<_OTG_HS_GINTSTS, 14, 1>; // Isochronous OUT packet dropped interrupt
        using EOPF = Field<_OTG_HS_GINTSTS, 15, 1>; // End of periodic frame interrupt
        using IEPINT = Field<_OTG_HS_GINTSTS, 18, 1>; // IN endpoint interrupt
        using OEPINT = Field<_OTG_HS_GINTSTS, 19, 1>; // OUT endpoint interrupt
        using IISOIXFR = Field<_OTG_HS_GINTSTS, 20, 1>; // Incomplete isochronous IN transfer
        using PXFR_INCOMPISOOUT = Field<_OTG_HS_GINTSTS, 21, 1>; // Incomplete periodic transfer
        using DATAFSUSP = Field<_OTG_HS_GINTSTS, 22, 1>; // Data fetch suspended
        using HPRTINT = Field<_OTG_HS_GINTSTS, 24, 1>; // Host port interrupt
        using HCINT = Field<_OTG_HS_GINTSTS, 25, 1>; // Host channels interrupt
        using PTXFE = Field<_OTG_HS_GINTSTS, 26, 1>; // Periodic TxFIFO empty
        using CIDSCHG = Field<_OTG_HS_GINTSTS, 28, 1>; // Connector ID status change
        using DISCINT = Field<_OTG_HS_GINTSTS, 29, 1>; // Disconnect detected interrupt
        using SRQINT = Field<_OTG_HS_GINTSTS, 30, 1>; // Session request/new session detected interrupt
        using WKUINT = Field<_OTG_HS_GINTSTS, 31, 1>; // Resume/remote wakeup detected interrupt
    };

    // OTG_HS interrupt mask register
    struct _OTG_HS_GINTMSK : Register<OTG_HS_GLOBAL_BASE + 0x18, ReadWrite, _OTG_HS_GINTMSK> {
        using MMISM = Field<_OTG_HS_GINTMSK, 1, 1>; // Mode mismatch interrupt mask
        using OTGINT = Field<_OTG_HS_GINTMSK, 2, 1>; // OTG interrupt mask
        using SOFM = Field<_OTG_HS_GINTMSK, 3, 1>; // Start of frame mask
        using RXFLVLM = Field<_OTG_HS_GINTMSK, 4, 1>; // Receive FIFO nonempty mask
        using NPTXFEM = Field<_OTG_HS_GINTMSK, 5, 1>; // Nonperiodic TxFIFO empty mask
        using GINAKEFFM = Field<_OTG_HS_GINTMSK, 6, 1>; // Global nonperiodic IN NAK effective mask
        using GONAKEFFM = Field<_OTG_HS_GINTMSK, 7, 1>; // Global OUT NAK effective mask
        using ESUSPM = Field<_OTG_HS_GINTMSK, 10, 1>; // Early suspend mask
        using USBSUSPM = Field<_OTG_HS_GINTMSK, 11, 1>; // USB suspend mask
        using USBRST = Field<_OTG_HS_GINTMSK, 12, 1>; // USB reset mask
        using ENUMDNEM = Field<_OTG_HS_GINTMSK, 13, 1>; // Enumeration done mask
        using ISOODRPM = Field<_OTG_HS_GINTMSK, 14, 1>; // Isochronous OUT packet dropped interrupt mask
        using EOPFM = Field<_OTG_HS_GINTMSK, 15, 1>; // End of periodic frame interrupt mask
        using IEPINT = Field<_OTG_HS_GINTMSK, 18, 1>; // IN endpoints interrupt mask
        using OEPINT = Field<_OTG_HS_GINTMSK, 19, 1>; // OUT endpoints interrupt mask
        using IISOIXFRM = Field<_OTG_HS_GINTMSK, 20, 1>; // Incomplete isochronous IN transfer mask
        using PXFRM_IISOOXFRM = Field<_OTG_HS_GINTMSK, 21, 1>; // Incomplete periodic transfer mask
        using FSUSPM = Field<_OTG_HS_GINTMSK, 22, 1>; // Data fetch suspended mask
        using PRTIM = Field<_OTG_HS_GINTMSK, 24, 1>; // Host port interrupt mask
        using HCIM = Field<_OTG_HS_GINTMSK, 25, 1>; // Host channels interrupt mask
        using PTXFEM = Field<_OTG_HS_GINTMSK, 26, 1>; // Periodic TxFIFO empty mask
        using CIDSCHGM = Field<_OTG_HS_GINTMSK, 28, 1>; // Connector ID status change mask
        using DISCINT = Field<_OTG_HS_GINTMSK, 29, 1>; // Disconnect detected interrupt mask
        using SRQIM = Field<_OTG_HS_GINTMSK, 30, 1>; // Session request/new session detected interrupt mask
        using WUIM = Field<_OTG_HS_GINTMSK, 31, 1>; // Resume/remote wakeup detected interrupt mask
        using RSTDE = Field<_OTG_HS_GINTMSK, 23, 1>; // Reset detected interrupt mask
        using LPMINTM = Field<_OTG_HS_GINTMSK, 27, 1>; // LPM interrupt mask
    };

    // OTG_HS Receive status debug read register (host mode)
    struct _OTG_HS_GRXSTSR_Host : Register<OTG_HS_GLOBAL_BASE + 0x1C, ReadOnly, _OTG_HS_GRXSTSR_Host> {
        using CHNUM = Field<_OTG_HS_GRXSTSR_Host, 0, 4>; // Channel number
        using BCNT = Field<_OTG_HS_GRXSTSR_Host, 4, 11>; // Byte count
        using DPID = Field<_OTG_HS_GRXSTSR_Host, 15, 2>; // Data PID
        using PKTSTS = Field<_OTG_HS_GRXSTSR_Host, 17, 4>; // Packet status
    };

    // OTG_HS status read and pop register (host mode)
    struct _OTG_HS_GRXSTSP_Host : Register<OTG_HS_GLOBAL_BASE + 0x20, ReadOnly, _OTG_HS_GRXSTSP_Host> {
        using CHNUM = Field<_OTG_HS_GRXSTSP_Host, 0, 4>; // Channel number
        using BCNT = Field<_OTG_HS_GRXSTSP_Host, 4, 11>; // Byte count
        using DPID = Field<_OTG_HS_GRXSTSP_Host, 15, 2>; // Data PID
        using PKTSTS = Field<_OTG_HS_GRXSTSP_Host, 17, 4>; // Packet status
    };

    // OTG_HS Receive FIFO size register
    struct _OTG_HS_GRXFSIZ : Register<OTG_HS_GLOBAL_BASE + 0x24, ReadWrite, _OTG_HS_GRXFSIZ> {
        using RXFD = Field<_OTG_HS_GRXFSIZ, 0, 16>; // RxFIFO depth
    };

    // OTG_HS nonperiodic transmit FIFO size register (host mode)
    struct _OTG_HS_HNPTXFSIZ_Host : Register<OTG_HS_GLOBAL_BASE + 0x28, ReadWrite, _OTG_HS_HNPTXFSIZ_Host> {
        using NPTXFSA = Field<_OTG_HS_HNPTXFSIZ_Host, 0, 16>; // Nonperiodic transmit RAM start address
        using NPTXFD = Field<_OTG_HS_HNPTXFSIZ_Host, 16, 16>; // Nonperiodic TxFIFO depth
    };

    // Endpoint 0 transmit FIFO size (peripheral mode)
    struct _OTG_HS_DIEPTXF0_Device : Register<OTG_HS_GLOBAL_BASE + 0x28, ReadWrite, _OTG_HS_DIEPTXF0_Device> {
        using TX0FSA = Field<_OTG_HS_DIEPTXF0_Device, 0, 16>; // Endpoint 0 transmit RAM start address
        using TX0FD = Field<_OTG_HS_DIEPTXF0_Device, 16, 16>; // Endpoint 0 TxFIFO depth
    };

    // OTG_HS nonperiodic transmit FIFO/queue status register
    struct _OTG_HS_GNPTXSTS : Register<OTG_HS_GLOBAL_BASE + 0x2C, ReadOnly, _OTG_HS_GNPTXSTS> {
        using NPTXFSAV = Field<_OTG_HS_GNPTXSTS, 0, 16>; // Nonperiodic TxFIFO space available
        using NPTQXSAV = Field<_OTG_HS_GNPTXSTS, 16, 8>; // Nonperiodic transmit request queue space available
        using NPTXQTOP = Field<_OTG_HS_GNPTXSTS, 24, 7>; // Top of the nonperiodic transmit request queue
    };

    // OTG_HS general core configuration register
    struct _OTG_HS_GCCFG : Register<OTG_HS_GLOBAL_BASE + 0x38, ReadWrite, _OTG_HS_GCCFG> {
        using PWRDWN = Field<_OTG_HS_GCCFG, 16, 1>; // Power down
        using BCDEN = Field<_OTG_HS_GCCFG, 17, 1>; // Battery charging detector (BCD) enable
        using DCDEN = Field<_OTG_HS_GCCFG, 18, 1>; // Data contact detection (DCD) mode enable
        using PDEN = Field<_OTG_HS_GCCFG, 19, 1>; // Primary detection (PD) mode enable
        using SDEN = Field<_OTG_HS_GCCFG, 20, 1>; // Secondary detection (SD) mode enable
        using VBDEN = Field<_OTG_HS_GCCFG, 21, 1>; // USB VBUS detection enable
        using DCDET = Field<_OTG_HS_GCCFG, 0, 1>; // Data contact detection (DCD) status
        using PDET = Field<_OTG_HS_GCCFG, 1, 1>; // Primary detection (PD) status
        using SDET = Field<_OTG_HS_GCCFG, 2, 1>; // Secondary detection (SD) status
        using PS2DET = Field<_OTG_HS_GCCFG, 3, 1>; // DM pull-up detection status
    };

    // OTG_HS core ID register
    struct _OTG_HS_CID : Register<OTG_HS_GLOBAL_BASE + 0x3C, ReadWrite, _OTG_HS_CID> {
        using PRODUCT_ID = Field<_OTG_HS_CID, 0, 32>; // Product ID field
    };

    // OTG_HS Host periodic transmit FIFO size register
    struct _OTG_HS_HPTXFSIZ : Register<OTG_HS_GLOBAL_BASE + 0x100, ReadWrite, _OTG_HS_HPTXFSIZ> {
        using PTXSA = Field<_OTG_HS_HPTXFSIZ, 0, 16>; // Host periodic TxFIFO start address
        using PTXFD = Field<_OTG_HS_HPTXFSIZ, 16, 16>; // Host periodic TxFIFO depth
    };

    // OTG_HS device IN endpoint transmit FIFO size register
    struct _OTG_HS_DIEPTXF1 : Register<OTG_HS_GLOBAL_BASE + 0x104, ReadWrite, _OTG_HS_DIEPTXF1> {
        using INEPTXSA = Field<_OTG_HS_DIEPTXF1, 0, 16>; // IN endpoint FIFOx transmit RAM start address
        using INEPTXFD = Field<_OTG_HS_DIEPTXF1, 16, 16>; // IN endpoint TxFIFO depth
    };

    // OTG_HS device IN endpoint transmit FIFO size register
    struct _OTG_HS_DIEPTXF2 : Register<OTG_HS_GLOBAL_BASE + 0x108, ReadWrite, _OTG_HS_DIEPTXF2> {
        using INEPTXSA = Field<_OTG_HS_DIEPTXF2, 0, 16>; // IN endpoint FIFOx transmit RAM start address
        using INEPTXFD = Field<_OTG_HS_DIEPTXF2, 16, 16>; // IN endpoint TxFIFO depth
    };

    // OTG_HS device IN endpoint transmit FIFO size register
    struct _OTG_HS_DIEPTXF3 : Register<OTG_HS_GLOBAL_BASE + 0x10C, ReadWrite, _OTG_HS_DIEPTXF3> {
        using INEPTXSA = Field<_OTG_HS_DIEPTXF3, 0, 16>; // IN endpoint FIFOx transmit RAM start address
        using INEPTXFD = Field<_OTG_HS_DIEPTXF3, 16, 16>; // IN endpoint TxFIFO depth
    };

    // OTG_HS device IN endpoint transmit FIFO size register
    struct _OTG_HS_DIEPTXF4 : Register<OTG_HS_GLOBAL_BASE + 0x110, ReadWrite, _OTG_HS_DIEPTXF4> {
        using INEPTXSA = Field<_OTG_HS_DIEPTXF4, 0, 16>; // IN endpoint FIFOx transmit RAM start address
        using INEPTXFD = Field<_OTG_HS_DIEPTXF4, 16, 16>; // IN endpoint TxFIFO depth
    };

    // OTG_HS device IN endpoint transmit FIFO size register
    struct _OTG_HS_DIEPTXF5 : Register<OTG_HS_GLOBAL_BASE + 0x114, ReadWrite, _OTG_HS_DIEPTXF5> {
        using INEPTXSA = Field<_OTG_HS_DIEPTXF5, 0, 16>; // IN endpoint FIFOx transmit RAM start address
        using INEPTXFD = Field<_OTG_HS_DIEPTXF5, 16, 16>; // IN endpoint TxFIFO depth
    };

    // OTG_HS device IN endpoint transmit FIFO size register
    struct _OTG_HS_DIEPTXF6 : Register<OTG_HS_GLOBAL_BASE + 0x118, ReadWrite, _OTG_HS_DIEPTXF6> {
        using INEPTXSA = Field<_OTG_HS_DIEPTXF6, 0, 16>; // IN endpoint FIFOx transmit RAM start address
        using INEPTXFD = Field<_OTG_HS_DIEPTXF6, 16, 16>; // IN endpoint TxFIFO depth
    };

    // OTG_HS device IN endpoint transmit FIFO size register
    struct _OTG_HS_DIEPTXF7 : Register<OTG_HS_GLOBAL_BASE + 0x11C, ReadWrite, _OTG_HS_DIEPTXF7> {
        using INEPTXSA = Field<_OTG_HS_DIEPTXF7, 0, 16>; // IN endpoint FIFOx transmit RAM start address
        using INEPTXFD = Field<_OTG_HS_DIEPTXF7, 16, 16>; // IN endpoint TxFIFO depth
    };

    struct _OTG_DIEPTXF8 : Register<OTG_HS_GLOBAL_BASE + 0x120, ReadWrite, _OTG_DIEPTXF8> {
        using INEPTXSA = Field<_OTG_DIEPTXF8, 0, 16>; // IN endpoint FIFOx transmit RAM start address This field contains the memory start address for IN endpoint transmit FIFOx. The address must be aligned with a 32-bit memory location.
        using INEPTXFD = Field<_OTG_DIEPTXF8, 16, 16>; // IN endpoint Tx FIFO depth This value is in terms of 32-bit words. Minimum value is 16
    };

    // OTG_HS Receive status debug read register (peripheral mode mode)
    struct _OTG_HS_GRXSTSR_Device : Register<OTG_HS_GLOBAL_BASE + 0x1C, ReadOnly, _OTG_HS_GRXSTSR_Device> {
        using EPNUM = Field<_OTG_HS_GRXSTSR_Device, 0, 4>; // Endpoint number
        using BCNT = Field<_OTG_HS_GRXSTSR_Device, 4, 11>; // Byte count
        using DPID = Field<_OTG_HS_GRXSTSR_Device, 15, 2>; // Data PID
        using PKTSTS = Field<_OTG_HS_GRXSTSR_Device, 17, 4>; // Packet status
        using FRMNUM = Field<_OTG_HS_GRXSTSR_Device, 21, 4>; // Frame number
    };

    // OTG_HS status read and pop register (peripheral mode)
    struct _OTG_HS_GRXSTSP_Device : Register<OTG_HS_GLOBAL_BASE + 0x20, ReadOnly, _OTG_HS_GRXSTSP_Device> {
        using EPNUM = Field<_OTG_HS_GRXSTSP_Device, 0, 4>; // Endpoint number
        using BCNT = Field<_OTG_HS_GRXSTSP_Device, 4, 11>; // Byte count
        using DPID = Field<_OTG_HS_GRXSTSP_Device, 15, 2>; // Data PID
        using PKTSTS = Field<_OTG_HS_GRXSTSP_Device, 17, 4>; // Packet status
        using FRMNUM = Field<_OTG_HS_GRXSTSP_Device, 21, 4>; // Frame number
    };

    // OTG core LPM configuration register
    struct _OTG_HS_GLPMCFG : Register<OTG_HS_GLOBAL_BASE + 0x54, ReadWrite, _OTG_HS_GLPMCFG> {
        using LPMEN = Field<_OTG_HS_GLPMCFG, 0, 1>; // LPM support enable
        using LPMACK = Field<_OTG_HS_GLPMCFG, 1, 1>; // LPM token acknowledge enable
        using BESL = Field<_OTG_HS_GLPMCFG, 2, 4>; // Best effort service latency
        using REMWAKE = Field<_OTG_HS_GLPMCFG, 6, 1>; // bRemoteWake value
        using L1SSEN = Field<_OTG_HS_GLPMCFG, 7, 1>; // L1 Shallow Sleep enable
        using BESLTHRS = Field<_OTG_HS_GLPMCFG, 8, 4>; // BESL threshold
        using L1DSEN = Field<_OTG_HS_GLPMCFG, 12, 1>; // L1 deep sleep enable
        using LPMRST = Field<_OTG_HS_GLPMCFG, 13, 2>; // LPM response
        using SLPSTS = Field<_OTG_HS_GLPMCFG, 15, 1>; // Port sleep status
        using L1RSMOK = Field<_OTG_HS_GLPMCFG, 16, 1>; // Sleep State Resume OK
        using LPMCHIDX = Field<_OTG_HS_GLPMCFG, 17, 4>; // LPM Channel Index
        using LPMRCNT = Field<_OTG_HS_GLPMCFG, 21, 3>; // LPM retry count
        using SNDLPM = Field<_OTG_HS_GLPMCFG, 24, 1>; // Send LPM transaction
        using LPMRCNTSTS = Field<_OTG_HS_GLPMCFG, 25, 3>; // LPM retry count status
        using ENBESL = Field<_OTG_HS_GLPMCFG, 28, 1>; // Enable best effort service latency
    };

} // namespace OTG_HS_GLOBAL

// --------------------------------------------
// MDIOS: Management data input/output slave
// Base address: 0x40017800
// --------------------------------------------

namespace MDIOS {
    static constexpr uint32_t MDIOS_BASE = 0x40017800;

    // MDIOS configuration register
    struct _MDIOS_CR : Register<MDIOS_BASE + 0x0, ReadWrite, _MDIOS_CR> {
        using EN = Field<_MDIOS_CR, 0, 1>; // Peripheral enable
        using WRIE = Field<_MDIOS_CR, 1, 1>; // Register write interrupt enable
        using RDIE = Field<_MDIOS_CR, 2, 1>; // Register Read Interrupt Enable
        using EIE = Field<_MDIOS_CR, 3, 1>; // Error interrupt enable
        using DPC = Field<_MDIOS_CR, 7, 1>; // Disable Preamble Check
        using PORT_ADDRESS = Field<_MDIOS_CR, 8, 5>; // Slaves's address
    };

    // MDIOS write flag register
    struct _MDIOS_WRFR : Register<MDIOS_BASE + 0x4, ReadOnly, _MDIOS_WRFR> {
        using WRF = Field<_MDIOS_WRFR, 0, 32>; // Write flags for MDIO registers 0 to 31
    };

    // MDIOS clear write flag register
    struct _MDIOS_CWRFR : Register<MDIOS_BASE + 0x8, ReadWrite, _MDIOS_CWRFR> {
        using CWRF = Field<_MDIOS_CWRFR, 0, 32>; // Clear the write flag
    };

    // MDIOS read flag register
    struct _MDIOS_RDFR : Register<MDIOS_BASE + 0xC, ReadOnly, _MDIOS_RDFR> {
        using RDF = Field<_MDIOS_RDFR, 0, 32>; // Read flags for MDIO registers 0 to 31
    };

    // MDIOS clear read flag register
    struct _MDIOS_CRDFR : Register<MDIOS_BASE + 0x10, ReadWrite, _MDIOS_CRDFR> {
        using CRDF = Field<_MDIOS_CRDFR, 0, 32>; // Clear the read flag
    };

    // MDIOS status register
    struct _MDIOS_SR : Register<MDIOS_BASE + 0x14, ReadOnly, _MDIOS_SR> {
        using PERF = Field<_MDIOS_SR, 0, 1>; // Preamble error flag
        using SERF = Field<_MDIOS_SR, 1, 1>; // Start error flag
        using TERF = Field<_MDIOS_SR, 2, 1>; // Turnaround error flag
    };

    // MDIOS clear flag register
    struct _MDIOS_CLRFR : Register<MDIOS_BASE + 0x18, ReadWrite, _MDIOS_CLRFR> {
        using CPERF = Field<_MDIOS_CLRFR, 0, 1>; // Clear the preamble error flag
        using CSERF = Field<_MDIOS_CLRFR, 1, 1>; // Clear the start error flag
        using CTERF = Field<_MDIOS_CLRFR, 2, 1>; // Clear the turnaround error flag
    };

    // MDIOS input data register 0
    struct _MDIOS_DINR0 : Register<MDIOS_BASE + 0x1C, ReadOnly, _MDIOS_DINR0> {
        using DIN0 = Field<_MDIOS_DINR0, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 1
    struct _MDIOS_DINR1 : Register<MDIOS_BASE + 0x20, ReadOnly, _MDIOS_DINR1> {
        using DIN1 = Field<_MDIOS_DINR1, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 2
    struct _MDIOS_DINR2 : Register<MDIOS_BASE + 0x24, ReadOnly, _MDIOS_DINR2> {
        using DIN2 = Field<_MDIOS_DINR2, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 3
    struct _MDIOS_DINR3 : Register<MDIOS_BASE + 0x28, ReadOnly, _MDIOS_DINR3> {
        using DIN3 = Field<_MDIOS_DINR3, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 4
    struct _MDIOS_DINR4 : Register<MDIOS_BASE + 0x2C, ReadOnly, _MDIOS_DINR4> {
        using DIN4 = Field<_MDIOS_DINR4, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 5
    struct _MDIOS_DINR5 : Register<MDIOS_BASE + 0x30, ReadOnly, _MDIOS_DINR5> {
        using DIN5 = Field<_MDIOS_DINR5, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 6
    struct _MDIOS_DINR6 : Register<MDIOS_BASE + 0x34, ReadOnly, _MDIOS_DINR6> {
        using DIN6 = Field<_MDIOS_DINR6, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 7
    struct _MDIOS_DINR7 : Register<MDIOS_BASE + 0x38, ReadOnly, _MDIOS_DINR7> {
        using DIN7 = Field<_MDIOS_DINR7, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 8
    struct _MDIOS_DINR8 : Register<MDIOS_BASE + 0x3C, ReadOnly, _MDIOS_DINR8> {
        using DIN8 = Field<_MDIOS_DINR8, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 9
    struct _MDIOS_DINR9 : Register<MDIOS_BASE + 0x40, ReadOnly, _MDIOS_DINR9> {
        using DIN9 = Field<_MDIOS_DINR9, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 10
    struct _MDIOS_DINR10 : Register<MDIOS_BASE + 0x44, ReadOnly, _MDIOS_DINR10> {
        using DIN10 = Field<_MDIOS_DINR10, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 11
    struct _MDIOS_DINR11 : Register<MDIOS_BASE + 0x48, ReadOnly, _MDIOS_DINR11> {
        using DIN11 = Field<_MDIOS_DINR11, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 12
    struct _MDIOS_DINR12 : Register<MDIOS_BASE + 0x4C, ReadOnly, _MDIOS_DINR12> {
        using DIN12 = Field<_MDIOS_DINR12, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 13
    struct _MDIOS_DINR13 : Register<MDIOS_BASE + 0x50, ReadOnly, _MDIOS_DINR13> {
        using DIN13 = Field<_MDIOS_DINR13, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 14
    struct _MDIOS_DINR14 : Register<MDIOS_BASE + 0x54, ReadOnly, _MDIOS_DINR14> {
        using DIN14 = Field<_MDIOS_DINR14, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 15
    struct _MDIOS_DINR15 : Register<MDIOS_BASE + 0x58, ReadOnly, _MDIOS_DINR15> {
        using DIN15 = Field<_MDIOS_DINR15, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 16
    struct _MDIOS_DINR16 : Register<MDIOS_BASE + 0x5C, ReadOnly, _MDIOS_DINR16> {
        using DIN16 = Field<_MDIOS_DINR16, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 17
    struct _MDIOS_DINR17 : Register<MDIOS_BASE + 0x60, ReadOnly, _MDIOS_DINR17> {
        using DIN17 = Field<_MDIOS_DINR17, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 18
    struct _MDIOS_DINR18 : Register<MDIOS_BASE + 0x64, ReadOnly, _MDIOS_DINR18> {
        using DIN18 = Field<_MDIOS_DINR18, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 19
    struct _MDIOS_DINR19 : Register<MDIOS_BASE + 0x68, ReadOnly, _MDIOS_DINR19> {
        using DIN19 = Field<_MDIOS_DINR19, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 20
    struct _MDIOS_DINR20 : Register<MDIOS_BASE + 0x6C, ReadOnly, _MDIOS_DINR20> {
        using DIN20 = Field<_MDIOS_DINR20, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 21
    struct _MDIOS_DINR21 : Register<MDIOS_BASE + 0x70, ReadOnly, _MDIOS_DINR21> {
        using DIN21 = Field<_MDIOS_DINR21, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 22
    struct _MDIOS_DINR22 : Register<MDIOS_BASE + 0x74, ReadOnly, _MDIOS_DINR22> {
        using DIN22 = Field<_MDIOS_DINR22, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 23
    struct _MDIOS_DINR23 : Register<MDIOS_BASE + 0x78, ReadOnly, _MDIOS_DINR23> {
        using DIN23 = Field<_MDIOS_DINR23, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 24
    struct _MDIOS_DINR24 : Register<MDIOS_BASE + 0x7C, ReadOnly, _MDIOS_DINR24> {
        using DIN24 = Field<_MDIOS_DINR24, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 25
    struct _MDIOS_DINR25 : Register<MDIOS_BASE + 0x80, ReadOnly, _MDIOS_DINR25> {
        using DIN25 = Field<_MDIOS_DINR25, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 26
    struct _MDIOS_DINR26 : Register<MDIOS_BASE + 0x84, ReadOnly, _MDIOS_DINR26> {
        using DIN26 = Field<_MDIOS_DINR26, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 27
    struct _MDIOS_DINR27 : Register<MDIOS_BASE + 0x88, ReadOnly, _MDIOS_DINR27> {
        using DIN27 = Field<_MDIOS_DINR27, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 28
    struct _MDIOS_DINR28 : Register<MDIOS_BASE + 0x8C, ReadOnly, _MDIOS_DINR28> {
        using DIN28 = Field<_MDIOS_DINR28, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 29
    struct _MDIOS_DINR29 : Register<MDIOS_BASE + 0x90, ReadOnly, _MDIOS_DINR29> {
        using DIN29 = Field<_MDIOS_DINR29, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 30
    struct _MDIOS_DINR30 : Register<MDIOS_BASE + 0x94, ReadOnly, _MDIOS_DINR30> {
        using DIN30 = Field<_MDIOS_DINR30, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS input data register 31
    struct _MDIOS_DINR31 : Register<MDIOS_BASE + 0x98, ReadOnly, _MDIOS_DINR31> {
        using DIN31 = Field<_MDIOS_DINR31, 0, 16>; // Input data received from MDIO Master during write frames
    };

    // MDIOS output data register 0
    struct _MDIOS_DOUTR0 : Register<MDIOS_BASE + 0x9C, ReadWrite, _MDIOS_DOUTR0> {
        using DOUT0 = Field<_MDIOS_DOUTR0, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 1
    struct _MDIOS_DOUTR1 : Register<MDIOS_BASE + 0xA0, ReadWrite, _MDIOS_DOUTR1> {
        using DOUT1 = Field<_MDIOS_DOUTR1, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 2
    struct _MDIOS_DOUTR2 : Register<MDIOS_BASE + 0xA4, ReadWrite, _MDIOS_DOUTR2> {
        using DOUT2 = Field<_MDIOS_DOUTR2, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 3
    struct _MDIOS_DOUTR3 : Register<MDIOS_BASE + 0xA8, ReadWrite, _MDIOS_DOUTR3> {
        using DOUT3 = Field<_MDIOS_DOUTR3, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 4
    struct _MDIOS_DOUTR4 : Register<MDIOS_BASE + 0xAC, ReadWrite, _MDIOS_DOUTR4> {
        using DOUT4 = Field<_MDIOS_DOUTR4, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 5
    struct _MDIOS_DOUTR5 : Register<MDIOS_BASE + 0xB0, ReadWrite, _MDIOS_DOUTR5> {
        using DOUT5 = Field<_MDIOS_DOUTR5, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 6
    struct _MDIOS_DOUTR6 : Register<MDIOS_BASE + 0xB4, ReadWrite, _MDIOS_DOUTR6> {
        using DOUT6 = Field<_MDIOS_DOUTR6, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 7
    struct _MDIOS_DOUTR7 : Register<MDIOS_BASE + 0xB8, ReadWrite, _MDIOS_DOUTR7> {
        using DOUT7 = Field<_MDIOS_DOUTR7, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 8
    struct _MDIOS_DOUTR8 : Register<MDIOS_BASE + 0xBC, ReadWrite, _MDIOS_DOUTR8> {
        using DOUT8 = Field<_MDIOS_DOUTR8, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 9
    struct _MDIOS_DOUTR9 : Register<MDIOS_BASE + 0xC0, ReadWrite, _MDIOS_DOUTR9> {
        using DOUT9 = Field<_MDIOS_DOUTR9, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 10
    struct _MDIOS_DOUTR10 : Register<MDIOS_BASE + 0xC4, ReadWrite, _MDIOS_DOUTR10> {
        using DOUT10 = Field<_MDIOS_DOUTR10, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 11
    struct _MDIOS_DOUTR11 : Register<MDIOS_BASE + 0xC8, ReadWrite, _MDIOS_DOUTR11> {
        using DOUT11 = Field<_MDIOS_DOUTR11, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 12
    struct _MDIOS_DOUTR12 : Register<MDIOS_BASE + 0xCC, ReadWrite, _MDIOS_DOUTR12> {
        using DOUT12 = Field<_MDIOS_DOUTR12, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 13
    struct _MDIOS_DOUTR13 : Register<MDIOS_BASE + 0xD0, ReadWrite, _MDIOS_DOUTR13> {
        using DOUT13 = Field<_MDIOS_DOUTR13, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 14
    struct _MDIOS_DOUTR14 : Register<MDIOS_BASE + 0xD4, ReadWrite, _MDIOS_DOUTR14> {
        using DOUT14 = Field<_MDIOS_DOUTR14, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 15
    struct _MDIOS_DOUTR15 : Register<MDIOS_BASE + 0xD8, ReadWrite, _MDIOS_DOUTR15> {
        using DOUT15 = Field<_MDIOS_DOUTR15, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 16
    struct _MDIOS_DOUTR16 : Register<MDIOS_BASE + 0xDC, ReadWrite, _MDIOS_DOUTR16> {
        using DOUT16 = Field<_MDIOS_DOUTR16, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 17
    struct _MDIOS_DOUTR17 : Register<MDIOS_BASE + 0xE0, ReadWrite, _MDIOS_DOUTR17> {
        using DOUT17 = Field<_MDIOS_DOUTR17, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 18
    struct _MDIOS_DOUTR18 : Register<MDIOS_BASE + 0xE4, ReadWrite, _MDIOS_DOUTR18> {
        using DOUT18 = Field<_MDIOS_DOUTR18, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 19
    struct _MDIOS_DOUTR19 : Register<MDIOS_BASE + 0xE8, ReadWrite, _MDIOS_DOUTR19> {
        using DOUT19 = Field<_MDIOS_DOUTR19, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 20
    struct _MDIOS_DOUTR20 : Register<MDIOS_BASE + 0xEC, ReadWrite, _MDIOS_DOUTR20> {
        using DOUT20 = Field<_MDIOS_DOUTR20, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 21
    struct _MDIOS_DOUTR21 : Register<MDIOS_BASE + 0xF0, ReadWrite, _MDIOS_DOUTR21> {
        using DOUT21 = Field<_MDIOS_DOUTR21, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 22
    struct _MDIOS_DOUTR22 : Register<MDIOS_BASE + 0xF4, ReadWrite, _MDIOS_DOUTR22> {
        using DOUT22 = Field<_MDIOS_DOUTR22, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 23
    struct _MDIOS_DOUTR23 : Register<MDIOS_BASE + 0xF8, ReadWrite, _MDIOS_DOUTR23> {
        using DOUT23 = Field<_MDIOS_DOUTR23, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 24
    struct _MDIOS_DOUTR24 : Register<MDIOS_BASE + 0xFC, ReadWrite, _MDIOS_DOUTR24> {
        using DOUT24 = Field<_MDIOS_DOUTR24, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 25
    struct _MDIOS_DOUTR25 : Register<MDIOS_BASE + 0x100, ReadWrite, _MDIOS_DOUTR25> {
        using DOUT25 = Field<_MDIOS_DOUTR25, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 26
    struct _MDIOS_DOUTR26 : Register<MDIOS_BASE + 0x104, ReadWrite, _MDIOS_DOUTR26> {
        using DOUT26 = Field<_MDIOS_DOUTR26, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 27
    struct _MDIOS_DOUTR27 : Register<MDIOS_BASE + 0x108, ReadWrite, _MDIOS_DOUTR27> {
        using DOUT27 = Field<_MDIOS_DOUTR27, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 28
    struct _MDIOS_DOUTR28 : Register<MDIOS_BASE + 0x10C, ReadWrite, _MDIOS_DOUTR28> {
        using DOUT28 = Field<_MDIOS_DOUTR28, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 29
    struct _MDIOS_DOUTR29 : Register<MDIOS_BASE + 0x110, ReadWrite, _MDIOS_DOUTR29> {
        using DOUT29 = Field<_MDIOS_DOUTR29, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 30
    struct _MDIOS_DOUTR30 : Register<MDIOS_BASE + 0x114, ReadWrite, _MDIOS_DOUTR30> {
        using DOUT30 = Field<_MDIOS_DOUTR30, 0, 16>; // Output data sent to MDIO Master during read frames
    };

    // MDIOS output data register 31
    struct _MDIOS_DOUTR31 : Register<MDIOS_BASE + 0x118, ReadWrite, _MDIOS_DOUTR31> {
        using DOUT31 = Field<_MDIOS_DOUTR31, 0, 16>; // Output data sent to MDIO Master during read frames
    };

} // namespace MDIOS

// --------------------------------------------
// DFSDM: Digital filter for sigma delta modulators
// Base address: 0x40017400
// --------------------------------------------

namespace DFSDM {
    static constexpr uint32_t DFSDM_BASE = 0x40017400;

    // DFSDM channel configuration 0 register 1
    struct _DFSDM_CHCFG0R1 : Register<DFSDM_BASE + 0x0, ReadWrite, _DFSDM_CHCFG0R1> {
        using SITP = Field<_DFSDM_CHCFG0R1, 0, 2>; // Serial interface type for channel 0
        using SPICKSEL = Field<_DFSDM_CHCFG0R1, 2, 2>; // SPI clock select for channel 0
        using SCDEN = Field<_DFSDM_CHCFG0R1, 5, 1>; // Short-circuit detector enable on channel 0
        using CKABEN = Field<_DFSDM_CHCFG0R1, 6, 1>; // Clock absence detector enable on channel 0
        using CHEN = Field<_DFSDM_CHCFG0R1, 7, 1>; // Channel 0 enable
        using CHINSEL = Field<_DFSDM_CHCFG0R1, 8, 1>; // Channel inputs selection
        using DATMPX = Field<_DFSDM_CHCFG0R1, 12, 2>; // Input data multiplexer for channel 0
        using DATPACK = Field<_DFSDM_CHCFG0R1, 14, 2>; // Data packing mode in DFSDM_CHDATINyR register
        using CKOUTDIV = Field<_DFSDM_CHCFG0R1, 16, 8>; // Output serial clock divider
        using CKOUTSRC = Field<_DFSDM_CHCFG0R1, 30, 1>; // Output serial clock source selection
        using DFSDMEN = Field<_DFSDM_CHCFG0R1, 31, 1>; // Global enable for DFSDM interface
    };

    // DFSDM channel configuration 1 register 1
    struct _DFSDM_CHCFG1R1 : Register<DFSDM_BASE + 0x20, ReadWrite, _DFSDM_CHCFG1R1> {
        using SITP = Field<_DFSDM_CHCFG1R1, 0, 2>; // Serial interface type for channel 1
        using SPICKSEL = Field<_DFSDM_CHCFG1R1, 2, 2>; // SPI clock select for channel 1
        using SCDEN = Field<_DFSDM_CHCFG1R1, 5, 1>; // Short-circuit detector enable on channel 1
        using CKABEN = Field<_DFSDM_CHCFG1R1, 6, 1>; // Clock absence detector enable on channel 1
        using CHEN = Field<_DFSDM_CHCFG1R1, 7, 1>; // Channel 1 enable
        using CHINSEL = Field<_DFSDM_CHCFG1R1, 8, 1>; // Channel inputs selection
        using DATMPX = Field<_DFSDM_CHCFG1R1, 12, 2>; // Input data multiplexer for channel 1
        using DATPACK = Field<_DFSDM_CHCFG1R1, 14, 2>; // Data packing mode in DFSDM_CHDATINyR register
        using CKOUTDIV = Field<_DFSDM_CHCFG1R1, 16, 8>; // Output serial clock divider
        using CKOUTSRC = Field<_DFSDM_CHCFG1R1, 30, 1>; // Output serial clock source selection
        using DFSDMEN = Field<_DFSDM_CHCFG1R1, 31, 1>; // Global enable for DFSDM interface
    };

    // DFSDM channel configuration 2 register 1
    struct _DFSDM_CHCFG2R1 : Register<DFSDM_BASE + 0x40, ReadWrite, _DFSDM_CHCFG2R1> {
        using SITP = Field<_DFSDM_CHCFG2R1, 0, 2>; // Serial interface type for channel 2
        using SPICKSEL = Field<_DFSDM_CHCFG2R1, 2, 2>; // SPI clock select for channel 2
        using SCDEN = Field<_DFSDM_CHCFG2R1, 5, 1>; // Short-circuit detector enable on channel 2
        using CKABEN = Field<_DFSDM_CHCFG2R1, 6, 1>; // Clock absence detector enable on channel 2
        using CHEN = Field<_DFSDM_CHCFG2R1, 7, 1>; // Channel 2 enable
        using CHINSEL = Field<_DFSDM_CHCFG2R1, 8, 1>; // Channel inputs selection
        using DATMPX = Field<_DFSDM_CHCFG2R1, 12, 2>; // Input data multiplexer for channel 2
        using DATPACK = Field<_DFSDM_CHCFG2R1, 14, 2>; // Data packing mode in DFSDM_CHDATINyR register
        using CKOUTDIV = Field<_DFSDM_CHCFG2R1, 16, 8>; // Output serial clock divider
        using CKOUTSRC = Field<_DFSDM_CHCFG2R1, 30, 1>; // Output serial clock source selection
        using DFSDMEN = Field<_DFSDM_CHCFG2R1, 31, 1>; // Global enable for DFSDM interface
    };

    // DFSDM channel configuration 3 register 1
    struct _DFSDM_CHCFG3R1 : Register<DFSDM_BASE + 0x60, ReadWrite, _DFSDM_CHCFG3R1> {
        using SITP = Field<_DFSDM_CHCFG3R1, 0, 2>; // Serial interface type for channel 3
        using SPICKSEL = Field<_DFSDM_CHCFG3R1, 2, 2>; // SPI clock select for channel 3
        using SCDEN = Field<_DFSDM_CHCFG3R1, 5, 1>; // Short-circuit detector enable on channel 3
        using CKABEN = Field<_DFSDM_CHCFG3R1, 6, 1>; // Clock absence detector enable on channel 3
        using CHEN = Field<_DFSDM_CHCFG3R1, 7, 1>; // Channel 3 enable
        using CHINSEL = Field<_DFSDM_CHCFG3R1, 8, 1>; // Channel inputs selection
        using DATMPX = Field<_DFSDM_CHCFG3R1, 12, 2>; // Input data multiplexer for channel 3
        using DATPACK = Field<_DFSDM_CHCFG3R1, 14, 2>; // Data packing mode in DFSDM_CHDATINyR register
        using CKOUTDIV = Field<_DFSDM_CHCFG3R1, 16, 8>; // Output serial clock divider
        using CKOUTSRC = Field<_DFSDM_CHCFG3R1, 30, 1>; // Output serial clock source selection
        using DFSDMEN = Field<_DFSDM_CHCFG3R1, 31, 1>; // Global enable for DFSDM interface
    };

    // DFSDM channel configuration 4 register 1
    struct _DFSDM_CHCFG4R1 : Register<DFSDM_BASE + 0x80, ReadWrite, _DFSDM_CHCFG4R1> {
        using SITP = Field<_DFSDM_CHCFG4R1, 0, 2>; // Serial interface type for channel 4
        using SPICKSEL = Field<_DFSDM_CHCFG4R1, 2, 2>; // SPI clock select for channel 4
        using SCDEN = Field<_DFSDM_CHCFG4R1, 5, 1>; // Short-circuit detector enable on channel 4
        using CKABEN = Field<_DFSDM_CHCFG4R1, 6, 1>; // Clock absence detector enable on channel 4
        using CHEN = Field<_DFSDM_CHCFG4R1, 7, 1>; // Channel 4 enable
        using CHINSEL = Field<_DFSDM_CHCFG4R1, 8, 1>; // Channel inputs selection
        using DATMPX = Field<_DFSDM_CHCFG4R1, 12, 2>; // Input data multiplexer for channel 4
        using DATPACK = Field<_DFSDM_CHCFG4R1, 14, 2>; // Data packing mode in DFSDM_CHDATINyR register
        using CKOUTDIV = Field<_DFSDM_CHCFG4R1, 16, 8>; // Output serial clock divider
        using CKOUTSRC = Field<_DFSDM_CHCFG4R1, 30, 1>; // Output serial clock source selection
        using DFSDMEN = Field<_DFSDM_CHCFG4R1, 31, 1>; // Global enable for DFSDM interface
    };

    // DFSDM channel configuration 5 register 1
    struct _DFSDM_CHCFG5R1 : Register<DFSDM_BASE + 0xA0, ReadWrite, _DFSDM_CHCFG5R1> {
        using SITP = Field<_DFSDM_CHCFG5R1, 0, 2>; // Serial interface type for channel 5
        using SPICKSEL = Field<_DFSDM_CHCFG5R1, 2, 2>; // SPI clock select for channel 5
        using SCDEN = Field<_DFSDM_CHCFG5R1, 5, 1>; // Short-circuit detector enable on channel 5
        using CKABEN = Field<_DFSDM_CHCFG5R1, 6, 1>; // Clock absence detector enable on channel 5
        using CHEN = Field<_DFSDM_CHCFG5R1, 7, 1>; // Channel 5 enable
        using CHINSEL = Field<_DFSDM_CHCFG5R1, 8, 1>; // Channel inputs selection
        using DATMPX = Field<_DFSDM_CHCFG5R1, 12, 2>; // Input data multiplexer for channel 5
        using DATPACK = Field<_DFSDM_CHCFG5R1, 14, 2>; // Data packing mode in DFSDM_CHDATINyR register
        using CKOUTDIV = Field<_DFSDM_CHCFG5R1, 16, 8>; // Output serial clock divider
        using CKOUTSRC = Field<_DFSDM_CHCFG5R1, 30, 1>; // Output serial clock source selection
        using DFSDMEN = Field<_DFSDM_CHCFG5R1, 31, 1>; // Global enable for DFSDM interface
    };

    // DFSDM channel configuration 6 register 1
    struct _DFSDM_CHCFG6R1 : Register<DFSDM_BASE + 0xC0, ReadWrite, _DFSDM_CHCFG6R1> {
        using SITP = Field<_DFSDM_CHCFG6R1, 0, 2>; // Serial interface type for channel 6
        using SPICKSEL = Field<_DFSDM_CHCFG6R1, 2, 2>; // SPI clock select for channel 6
        using SCDEN = Field<_DFSDM_CHCFG6R1, 5, 1>; // Short-circuit detector enable on channel 6
        using CKABEN = Field<_DFSDM_CHCFG6R1, 6, 1>; // Clock absence detector enable on channel 6
        using CHEN = Field<_DFSDM_CHCFG6R1, 7, 1>; // Channel 6 enable
        using CHINSEL = Field<_DFSDM_CHCFG6R1, 8, 1>; // Channel inputs selection
        using DATMPX = Field<_DFSDM_CHCFG6R1, 12, 2>; // Input data multiplexer for channel 6
        using DATPACK = Field<_DFSDM_CHCFG6R1, 14, 2>; // Data packing mode in DFSDM_CHDATINyR register
        using CKOUTDIV = Field<_DFSDM_CHCFG6R1, 16, 8>; // Output serial clock divider
        using CKOUTSRC = Field<_DFSDM_CHCFG6R1, 30, 1>; // Output serial clock source selection
        using DFSDMEN = Field<_DFSDM_CHCFG6R1, 31, 1>; // Global enable for DFSDM interface
    };

    // DFSDM channel configuration 7 register 1
    struct _DFSDM_CHCFG7R1 : Register<DFSDM_BASE + 0xE0, ReadWrite, _DFSDM_CHCFG7R1> {
        using SITP = Field<_DFSDM_CHCFG7R1, 0, 2>; // Serial interface type for channel 7
        using SPICKSEL = Field<_DFSDM_CHCFG7R1, 2, 2>; // SPI clock select for channel 7
        using SCDEN = Field<_DFSDM_CHCFG7R1, 5, 1>; // Short-circuit detector enable on channel 7
        using CKABEN = Field<_DFSDM_CHCFG7R1, 6, 1>; // Clock absence detector enable on channel 7
        using CHEN = Field<_DFSDM_CHCFG7R1, 7, 1>; // Channel 7 enable
        using CHINSEL = Field<_DFSDM_CHCFG7R1, 8, 1>; // Channel inputs selection
        using DATMPX = Field<_DFSDM_CHCFG7R1, 12, 2>; // Input data multiplexer for channel 7
        using DATPACK = Field<_DFSDM_CHCFG7R1, 14, 2>; // Data packing mode in DFSDM_CHDATINyR register
        using CKOUTDIV = Field<_DFSDM_CHCFG7R1, 16, 8>; // Output serial clock divider
        using CKOUTSRC = Field<_DFSDM_CHCFG7R1, 30, 1>; // Output serial clock source selection
        using DFSDMEN = Field<_DFSDM_CHCFG7R1, 31, 1>; // Global enable for DFSDM interface
    };

    // DFSDM channel configuration 0 register 2
    struct _DFSDM_CHCFG0R2 : Register<DFSDM_BASE + 0x4, ReadWrite, _DFSDM_CHCFG0R2> {
        using DTRBS = Field<_DFSDM_CHCFG0R2, 3, 5>; // Data right bit-shift for channel 0
        using OFFSET = Field<_DFSDM_CHCFG0R2, 8, 24>; // 24-bit calibration offset for channel 0
    };

    // DFSDM channel configuration 1 register 2
    struct _DFSDM_CHCFG1R2 : Register<DFSDM_BASE + 0x24, ReadWrite, _DFSDM_CHCFG1R2> {
        using DTRBS = Field<_DFSDM_CHCFG1R2, 3, 5>; // Data right bit-shift for channel 1
        using OFFSET = Field<_DFSDM_CHCFG1R2, 8, 24>; // 24-bit calibration offset for channel 1
    };

    // DFSDM channel configuration 2 register 2
    struct _DFSDM_CHCFG2R2 : Register<DFSDM_BASE + 0x44, ReadWrite, _DFSDM_CHCFG2R2> {
        using DTRBS = Field<_DFSDM_CHCFG2R2, 3, 5>; // Data right bit-shift for channel 2
        using OFFSET = Field<_DFSDM_CHCFG2R2, 8, 24>; // 24-bit calibration offset for channel 2
    };

    // DFSDM channel configuration 3 register 2
    struct _DFSDM_CHCFG3R2 : Register<DFSDM_BASE + 0x64, ReadWrite, _DFSDM_CHCFG3R2> {
        using DTRBS = Field<_DFSDM_CHCFG3R2, 3, 5>; // Data right bit-shift for channel 3
        using OFFSET = Field<_DFSDM_CHCFG3R2, 8, 24>; // 24-bit calibration offset for channel 3
    };

    // DFSDM channel configuration 4 register 2
    struct _DFSDM_CHCFG4R2 : Register<DFSDM_BASE + 0x84, ReadWrite, _DFSDM_CHCFG4R2> {
        using DTRBS = Field<_DFSDM_CHCFG4R2, 3, 5>; // Data right bit-shift for channel 4
        using OFFSET = Field<_DFSDM_CHCFG4R2, 8, 24>; // 24-bit calibration offset for channel 4
    };

    // DFSDM channel configuration 5 register 2
    struct _DFSDM_CHCFG5R2 : Register<DFSDM_BASE + 0xA4, ReadWrite, _DFSDM_CHCFG5R2> {
        using DTRBS = Field<_DFSDM_CHCFG5R2, 3, 5>; // Data right bit-shift for channel 5
        using OFFSET = Field<_DFSDM_CHCFG5R2, 8, 24>; // 24-bit calibration offset for channel 5
    };

    // DFSDM channel configuration 6 register 2
    struct _DFSDM_CHCFG6R2 : Register<DFSDM_BASE + 0xC4, ReadWrite, _DFSDM_CHCFG6R2> {
        using DTRBS = Field<_DFSDM_CHCFG6R2, 3, 5>; // Data right bit-shift for channel 6
        using OFFSET = Field<_DFSDM_CHCFG6R2, 8, 24>; // 24-bit calibration offset for channel 6
    };

    // DFSDM channel configuration 7 register 2
    struct _DFSDM_CHCFG7R2 : Register<DFSDM_BASE + 0xE4, ReadWrite, _DFSDM_CHCFG7R2> {
        using DTRBS = Field<_DFSDM_CHCFG7R2, 3, 5>; // Data right bit-shift for channel 7
        using OFFSET = Field<_DFSDM_CHCFG7R2, 8, 24>; // 24-bit calibration offset for channel 7
    };

    // DFSDM analog watchdog and short-circuit detector register
    struct _DFSDM_AWSCD0R : Register<DFSDM_BASE + 0x8, ReadWrite, _DFSDM_AWSCD0R> {
        using SCDT = Field<_DFSDM_AWSCD0R, 0, 8>; // short-circuit detector threshold for channel 0
        using BKSCD = Field<_DFSDM_AWSCD0R, 12, 4>; // Break signal assignment for short-circuit detector on channel 0
        using AWFOSR = Field<_DFSDM_AWSCD0R, 16, 5>; // Analog watchdog filter oversampling ratio (decimation rate) on channel 0
        using AWFORD = Field<_DFSDM_AWSCD0R, 22, 2>; // Analog watchdog Sinc filter order on channel 0
    };

    // DFSDM analog watchdog and short-circuit detector register
    struct _DFSDM_AWSCD1R : Register<DFSDM_BASE + 0x28, ReadWrite, _DFSDM_AWSCD1R> {
        using SCDT = Field<_DFSDM_AWSCD1R, 0, 8>; // short-circuit detector threshold for channel 1
        using BKSCD = Field<_DFSDM_AWSCD1R, 12, 4>; // Break signal assignment for short-circuit detector on channel 1
        using AWFOSR = Field<_DFSDM_AWSCD1R, 16, 5>; // Analog watchdog filter oversampling ratio (decimation rate) on channel 1
        using AWFORD = Field<_DFSDM_AWSCD1R, 22, 2>; // Analog watchdog Sinc filter order on channel 1
    };

    // DFSDM analog watchdog and short-circuit detector register
    struct _DFSDM_AWSCD2R : Register<DFSDM_BASE + 0x48, ReadWrite, _DFSDM_AWSCD2R> {
        using SCDT = Field<_DFSDM_AWSCD2R, 0, 8>; // short-circuit detector threshold for channel 2
        using BKSCD = Field<_DFSDM_AWSCD2R, 12, 4>; // Break signal assignment for short-circuit detector on channel 2
        using AWFOSR = Field<_DFSDM_AWSCD2R, 16, 5>; // Analog watchdog filter oversampling ratio (decimation rate) on channel 2
        using AWFORD = Field<_DFSDM_AWSCD2R, 22, 2>; // Analog watchdog Sinc filter order on channel 2
    };

    // DFSDM analog watchdog and short-circuit detector register
    struct _DFSDM_AWSCD3R : Register<DFSDM_BASE + 0x68, ReadWrite, _DFSDM_AWSCD3R> {
        using SCDT = Field<_DFSDM_AWSCD3R, 0, 8>; // short-circuit detector threshold for channel 3
        using BKSCD = Field<_DFSDM_AWSCD3R, 12, 4>; // Break signal assignment for short-circuit detector on channel 3
        using AWFOSR = Field<_DFSDM_AWSCD3R, 16, 5>; // Analog watchdog filter oversampling ratio (decimation rate) on channel 3
        using AWFORD = Field<_DFSDM_AWSCD3R, 22, 2>; // Analog watchdog Sinc filter order on channel 3
    };

    // DFSDM analog watchdog and short-circuit detector register
    struct _DFSDM_AWSCD4R : Register<DFSDM_BASE + 0x88, ReadWrite, _DFSDM_AWSCD4R> {
        using SCDT = Field<_DFSDM_AWSCD4R, 0, 8>; // short-circuit detector threshold for channel 4
        using BKSCD = Field<_DFSDM_AWSCD4R, 12, 4>; // Break signal assignment for short-circuit detector on channel 4
        using AWFOSR = Field<_DFSDM_AWSCD4R, 16, 5>; // Analog watchdog filter oversampling ratio (decimation rate) on channel 4
        using AWFORD = Field<_DFSDM_AWSCD4R, 22, 2>; // Analog watchdog Sinc filter order on channel 4
    };

    // DFSDM analog watchdog and short-circuit detector register
    struct _DFSDM_AWSCD5R : Register<DFSDM_BASE + 0xA8, ReadWrite, _DFSDM_AWSCD5R> {
        using SCDT = Field<_DFSDM_AWSCD5R, 0, 8>; // short-circuit detector threshold for channel 5
        using BKSCD = Field<_DFSDM_AWSCD5R, 12, 4>; // Break signal assignment for short-circuit detector on channel 5
        using AWFOSR = Field<_DFSDM_AWSCD5R, 16, 5>; // Analog watchdog filter oversampling ratio (decimation rate) on channel 5
        using AWFORD = Field<_DFSDM_AWSCD5R, 22, 2>; // Analog watchdog Sinc filter order on channel 5
    };

    // DFSDM analog watchdog and short-circuit detector register
    struct _DFSDM_AWSCD6R : Register<DFSDM_BASE + 0xC8, ReadWrite, _DFSDM_AWSCD6R> {
        using SCDT = Field<_DFSDM_AWSCD6R, 0, 8>; // short-circuit detector threshold for channel 6
        using BKSCD = Field<_DFSDM_AWSCD6R, 12, 4>; // Break signal assignment for short-circuit detector on channel 6
        using AWFOSR = Field<_DFSDM_AWSCD6R, 16, 5>; // Analog watchdog filter oversampling ratio (decimation rate) on channel 6
        using AWFORD = Field<_DFSDM_AWSCD6R, 22, 2>; // Analog watchdog Sinc filter order on channel 6
    };

    // DFSDM analog watchdog and short-circuit detector register
    struct _DFSDM_AWSCD7R : Register<DFSDM_BASE + 0xE8, ReadWrite, _DFSDM_AWSCD7R> {
        using SCDT = Field<_DFSDM_AWSCD7R, 0, 8>; // short-circuit detector threshold for channel 7
        using BKSCD = Field<_DFSDM_AWSCD7R, 12, 4>; // Break signal assignment for short-circuit detector on channel 7
        using AWFOSR = Field<_DFSDM_AWSCD7R, 16, 5>; // Analog watchdog filter oversampling ratio (decimation rate) on channel 7
        using AWFORD = Field<_DFSDM_AWSCD7R, 22, 2>; // Analog watchdog Sinc filter order on channel 7
    };

    // DFSDM channel watchdog filter data register
    struct _DFSDM_CHWDAT0R : Register<DFSDM_BASE + 0xC, ReadOnly, _DFSDM_CHWDAT0R> {
        using WDATA = Field<_DFSDM_CHWDAT0R, 0, 16>; // Input channel y watchdog data
    };

    // DFSDM channel watchdog filter data register
    struct _DFSDM_CHWDAT1R : Register<DFSDM_BASE + 0x2C, ReadOnly, _DFSDM_CHWDAT1R> {
        using WDATA = Field<_DFSDM_CHWDAT1R, 0, 16>; // Input channel y watchdog data
    };

    // DFSDM channel watchdog filter data register
    struct _DFSDM_CHWDAT2R : Register<DFSDM_BASE + 0x4C, ReadOnly, _DFSDM_CHWDAT2R> {
        using WDATA = Field<_DFSDM_CHWDAT2R, 0, 16>; // Input channel y watchdog data
    };

    // DFSDM channel watchdog filter data register
    struct _DFSDM_CHWDAT3R : Register<DFSDM_BASE + 0x6C, ReadOnly, _DFSDM_CHWDAT3R> {
        using WDATA = Field<_DFSDM_CHWDAT3R, 0, 16>; // Input channel y watchdog data
    };

    // DFSDM channel watchdog filter data register
    struct _DFSDM_CHWDAT4R : Register<DFSDM_BASE + 0x8C, ReadOnly, _DFSDM_CHWDAT4R> {
        using WDATA = Field<_DFSDM_CHWDAT4R, 0, 16>; // Input channel y watchdog data
    };

    // DFSDM channel watchdog filter data register
    struct _DFSDM_CHWDAT5R : Register<DFSDM_BASE + 0xAC, ReadOnly, _DFSDM_CHWDAT5R> {
        using WDATA = Field<_DFSDM_CHWDAT5R, 0, 16>; // Input channel y watchdog data
    };

    // DFSDM channel watchdog filter data register
    struct _DFSDM_CHWDAT6R : Register<DFSDM_BASE + 0xCC, ReadOnly, _DFSDM_CHWDAT6R> {
        using WDATA = Field<_DFSDM_CHWDAT6R, 0, 16>; // Input channel y watchdog data
    };

    // DFSDM channel watchdog filter data register
    struct _DFSDM_CHWDAT7R : Register<DFSDM_BASE + 0xEC, ReadOnly, _DFSDM_CHWDAT7R> {
        using WDATA = Field<_DFSDM_CHWDAT7R, 0, 16>; // Input channel y watchdog data
    };

    // DFSDM channel data input register
    struct _DFSDM_CHDATIN0R : Register<DFSDM_BASE + 0x10, ReadWrite, _DFSDM_CHDATIN0R> {
        using INDAT0 = Field<_DFSDM_CHDATIN0R, 0, 16>; // Input data for channel 0
        using INDAT1 = Field<_DFSDM_CHDATIN0R, 16, 16>; // Input data for channel 1
    };

    // DFSDM channel data input register
    struct _DFSDM_CHDATIN1R : Register<DFSDM_BASE + 0x30, ReadWrite, _DFSDM_CHDATIN1R> {
        using INDAT0 = Field<_DFSDM_CHDATIN1R, 0, 16>; // Input data for channel 1
        using INDAT1 = Field<_DFSDM_CHDATIN1R, 16, 16>; // Input data for channel 2
    };

    // DFSDM channel data input register
    struct _DFSDM_CHDATIN2R : Register<DFSDM_BASE + 0x50, ReadWrite, _DFSDM_CHDATIN2R> {
        using INDAT0 = Field<_DFSDM_CHDATIN2R, 0, 16>; // Input data for channel 2
        using INDAT1 = Field<_DFSDM_CHDATIN2R, 16, 16>; // Input data for channel 3
    };

    // DFSDM channel data input register
    struct _DFSDM_CHDATIN3R : Register<DFSDM_BASE + 0x70, ReadWrite, _DFSDM_CHDATIN3R> {
        using INDAT0 = Field<_DFSDM_CHDATIN3R, 0, 16>; // Input data for channel 3
        using INDAT1 = Field<_DFSDM_CHDATIN3R, 16, 16>; // Input data for channel 4
    };

    // DFSDM channel data input register
    struct _DFSDM_CHDATIN4R : Register<DFSDM_BASE + 0x90, ReadWrite, _DFSDM_CHDATIN4R> {
        using INDAT0 = Field<_DFSDM_CHDATIN4R, 0, 16>; // Input data for channel 4
        using INDAT1 = Field<_DFSDM_CHDATIN4R, 16, 16>; // Input data for channel 5
    };

    // DFSDM channel data input register
    struct _DFSDM_CHDATIN5R : Register<DFSDM_BASE + 0xB0, ReadWrite, _DFSDM_CHDATIN5R> {
        using INDAT0 = Field<_DFSDM_CHDATIN5R, 0, 16>; // Input data for channel 5
        using INDAT1 = Field<_DFSDM_CHDATIN5R, 16, 16>; // Input data for channel 6
    };

    // DFSDM channel data input register
    struct _DFSDM_CHDATIN6R : Register<DFSDM_BASE + 0xD0, ReadWrite, _DFSDM_CHDATIN6R> {
        using INDAT0 = Field<_DFSDM_CHDATIN6R, 0, 16>; // Input data for channel 6
        using INDAT1 = Field<_DFSDM_CHDATIN6R, 16, 16>; // Input data for channel 7
    };

    // DFSDM channel data input register
    struct _DFSDM_CHDATIN7R : Register<DFSDM_BASE + 0xF0, ReadWrite, _DFSDM_CHDATIN7R> {
        using INDAT0 = Field<_DFSDM_CHDATIN7R, 0, 16>; // Input data for channel 7
        using INDAT1 = Field<_DFSDM_CHDATIN7R, 16, 16>; // Input data for channel 8
    };

    // DFSDM control register 1
    struct _DFSDM0_CR1 : Register<DFSDM_BASE + 0x100, ReadWrite, _DFSDM0_CR1> {
        using DFEN = Field<_DFSDM0_CR1, 0, 1>; // DFSDM enable
        using JSWSTART = Field<_DFSDM0_CR1, 1, 1>; // Start a conversion of the injected group of channels
        using JSYNC = Field<_DFSDM0_CR1, 3, 1>; // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        using JSCAN = Field<_DFSDM0_CR1, 4, 1>; // Scanning conversion mode for injected conversions
        using JDMAEN = Field<_DFSDM0_CR1, 5, 1>; // DMA channel enabled to read data for the injected channel group
        using JEXTSEL = Field<_DFSDM0_CR1, 8, 5>; // Trigger signal selection for launching injected conversions
        using JEXTEN = Field<_DFSDM0_CR1, 13, 2>; // Trigger enable and trigger edge selection for injected conversions
        using RSWSTART = Field<_DFSDM0_CR1, 17, 1>; // Software start of a conversion on the regular channel
        using RCONT = Field<_DFSDM0_CR1, 18, 1>; // Continuous mode selection for regular conversions
        using RSYNC = Field<_DFSDM0_CR1, 19, 1>; // Launch regular conversion synchronously with DFSDM0
        using RDMAEN = Field<_DFSDM0_CR1, 21, 1>; // DMA channel enabled to read data for the regular conversion
        using RCH = Field<_DFSDM0_CR1, 24, 3>; // Regular channel selection
        using FAST = Field<_DFSDM0_CR1, 29, 1>; // Fast conversion mode selection for regular conversions
        using AWFSEL = Field<_DFSDM0_CR1, 30, 1>; // Analog watchdog fast mode select
    };

    // DFSDM control register 1
    struct _DFSDM1_CR1 : Register<DFSDM_BASE + 0x180, ReadWrite, _DFSDM1_CR1> {
        using DFEN = Field<_DFSDM1_CR1, 0, 1>; // DFSDM enable
        using JSWSTART = Field<_DFSDM1_CR1, 1, 1>; // Start a conversion of the injected group of channels
        using JSYNC = Field<_DFSDM1_CR1, 3, 1>; // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        using JSCAN = Field<_DFSDM1_CR1, 4, 1>; // Scanning conversion mode for injected conversions
        using JDMAEN = Field<_DFSDM1_CR1, 5, 1>; // DMA channel enabled to read data for the injected channel group
        using JEXTSEL = Field<_DFSDM1_CR1, 8, 5>; // Trigger signal selection for launching injected conversions
        using JEXTEN = Field<_DFSDM1_CR1, 13, 2>; // Trigger enable and trigger edge selection for injected conversions
        using RSWSTART = Field<_DFSDM1_CR1, 17, 1>; // Software start of a conversion on the regular channel
        using RCONT = Field<_DFSDM1_CR1, 18, 1>; // Continuous mode selection for regular conversions
        using RSYNC = Field<_DFSDM1_CR1, 19, 1>; // Launch regular conversion synchronously with DFSDM0
        using RDMAEN = Field<_DFSDM1_CR1, 21, 1>; // DMA channel enabled to read data for the regular conversion
        using RCH = Field<_DFSDM1_CR1, 24, 3>; // Regular channel selection
        using FAST = Field<_DFSDM1_CR1, 29, 1>; // Fast conversion mode selection for regular conversions
        using AWFSEL = Field<_DFSDM1_CR1, 30, 1>; // Analog watchdog fast mode select
    };

    // DFSDM control register 1
    struct _DFSDM2_CR1 : Register<DFSDM_BASE + 0x200, ReadWrite, _DFSDM2_CR1> {
        using DFEN = Field<_DFSDM2_CR1, 0, 1>; // DFSDM enable
        using JSWSTART = Field<_DFSDM2_CR1, 1, 1>; // Start a conversion of the injected group of channels
        using JSYNC = Field<_DFSDM2_CR1, 3, 1>; // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        using JSCAN = Field<_DFSDM2_CR1, 4, 1>; // Scanning conversion mode for injected conversions
        using JDMAEN = Field<_DFSDM2_CR1, 5, 1>; // DMA channel enabled to read data for the injected channel group
        using JEXTSEL = Field<_DFSDM2_CR1, 8, 5>; // Trigger signal selection for launching injected conversions
        using JEXTEN = Field<_DFSDM2_CR1, 13, 2>; // Trigger enable and trigger edge selection for injected conversions
        using RSWSTART = Field<_DFSDM2_CR1, 17, 1>; // Software start of a conversion on the regular channel
        using RCONT = Field<_DFSDM2_CR1, 18, 1>; // Continuous mode selection for regular conversions
        using RSYNC = Field<_DFSDM2_CR1, 19, 1>; // Launch regular conversion synchronously with DFSDM0
        using RDMAEN = Field<_DFSDM2_CR1, 21, 1>; // DMA channel enabled to read data for the regular conversion
        using RCH = Field<_DFSDM2_CR1, 24, 3>; // Regular channel selection
        using FAST = Field<_DFSDM2_CR1, 29, 1>; // Fast conversion mode selection for regular conversions
        using AWFSEL = Field<_DFSDM2_CR1, 30, 1>; // Analog watchdog fast mode select
    };

    // DFSDM control register 1
    struct _DFSDM3_CR1 : Register<DFSDM_BASE + 0x380, ReadWrite, _DFSDM3_CR1> {
        using DFEN = Field<_DFSDM3_CR1, 0, 1>; // DFSDM enable
        using JSWSTART = Field<_DFSDM3_CR1, 1, 1>; // Start a conversion of the injected group of channels
        using JSYNC = Field<_DFSDM3_CR1, 3, 1>; // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
        using JSCAN = Field<_DFSDM3_CR1, 4, 1>; // Scanning conversion mode for injected conversions
        using JDMAEN = Field<_DFSDM3_CR1, 5, 1>; // DMA channel enabled to read data for the injected channel group
        using JEXTSEL = Field<_DFSDM3_CR1, 8, 5>; // Trigger signal selection for launching injected conversions
        using JEXTEN = Field<_DFSDM3_CR1, 13, 2>; // Trigger enable and trigger edge selection for injected conversions
        using RSWSTART = Field<_DFSDM3_CR1, 17, 1>; // Software start of a conversion on the regular channel
        using RCONT = Field<_DFSDM3_CR1, 18, 1>; // Continuous mode selection for regular conversions
        using RSYNC = Field<_DFSDM3_CR1, 19, 1>; // Launch regular conversion synchronously with DFSDM0
        using RDMAEN = Field<_DFSDM3_CR1, 21, 1>; // DMA channel enabled to read data for the regular conversion
        using RCH = Field<_DFSDM3_CR1, 24, 3>; // Regular channel selection
        using FAST = Field<_DFSDM3_CR1, 29, 1>; // Fast conversion mode selection for regular conversions
        using AWFSEL = Field<_DFSDM3_CR1, 30, 1>; // Analog watchdog fast mode select
    };

    // DFSDM control register 2
    struct _DFSDM0_CR2 : Register<DFSDM_BASE + 0x104, ReadWrite, _DFSDM0_CR2> {
        using JEOCIE = Field<_DFSDM0_CR2, 0, 1>; // Injected end of conversion interrupt enable
        using REOCIE = Field<_DFSDM0_CR2, 1, 1>; // Regular end of conversion interrupt enable
        using JOVRIE = Field<_DFSDM0_CR2, 2, 1>; // Injected data overrun interrupt enable
        using ROVRIE = Field<_DFSDM0_CR2, 3, 1>; // Regular data overrun interrupt enable
        using AWDIE = Field<_DFSDM0_CR2, 4, 1>; // Analog watchdog interrupt enable
        using SCDIE = Field<_DFSDM0_CR2, 5, 1>; // Short-circuit detector interrupt enable
        using CKABIE = Field<_DFSDM0_CR2, 6, 1>; // Clock absence interrupt enable
        using EXCH = Field<_DFSDM0_CR2, 8, 8>; // Extremes detector channel selection
        using AWDCH = Field<_DFSDM0_CR2, 16, 8>; // Analog watchdog channel selection
    };

    // DFSDM control register 2
    struct _DFSDM1_CR2 : Register<DFSDM_BASE + 0x184, ReadWrite, _DFSDM1_CR2> {
        using JEOCIE = Field<_DFSDM1_CR2, 0, 1>; // Injected end of conversion interrupt enable
        using REOCIE = Field<_DFSDM1_CR2, 1, 1>; // Regular end of conversion interrupt enable
        using JOVRIE = Field<_DFSDM1_CR2, 2, 1>; // Injected data overrun interrupt enable
        using ROVRIE = Field<_DFSDM1_CR2, 3, 1>; // Regular data overrun interrupt enable
        using AWDIE = Field<_DFSDM1_CR2, 4, 1>; // Analog watchdog interrupt enable
        using SCDIE = Field<_DFSDM1_CR2, 5, 1>; // Short-circuit detector interrupt enable
        using CKABIE = Field<_DFSDM1_CR2, 6, 1>; // Clock absence interrupt enable
        using EXCH = Field<_DFSDM1_CR2, 8, 8>; // Extremes detector channel selection
        using AWDCH = Field<_DFSDM1_CR2, 16, 8>; // Analog watchdog channel selection
    };

    // DFSDM control register 2
    struct _DFSDM2_CR2 : Register<DFSDM_BASE + 0x204, ReadWrite, _DFSDM2_CR2> {
        using JEOCIE = Field<_DFSDM2_CR2, 0, 1>; // Injected end of conversion interrupt enable
        using REOCIE = Field<_DFSDM2_CR2, 1, 1>; // Regular end of conversion interrupt enable
        using JOVRIE = Field<_DFSDM2_CR2, 2, 1>; // Injected data overrun interrupt enable
        using ROVRIE = Field<_DFSDM2_CR2, 3, 1>; // Regular data overrun interrupt enable
        using AWDIE = Field<_DFSDM2_CR2, 4, 1>; // Analog watchdog interrupt enable
        using SCDIE = Field<_DFSDM2_CR2, 5, 1>; // Short-circuit detector interrupt enable
        using CKABIE = Field<_DFSDM2_CR2, 6, 1>; // Clock absence interrupt enable
        using EXCH = Field<_DFSDM2_CR2, 8, 8>; // Extremes detector channel selection
        using AWDCH = Field<_DFSDM2_CR2, 16, 8>; // Analog watchdog channel selection
    };

    // DFSDM control register 2
    struct _DFSDM3_CR2 : Register<DFSDM_BASE + 0x384, ReadWrite, _DFSDM3_CR2> {
        using JEOCIE = Field<_DFSDM3_CR2, 0, 1>; // Injected end of conversion interrupt enable
        using REOCIE = Field<_DFSDM3_CR2, 1, 1>; // Regular end of conversion interrupt enable
        using JOVRIE = Field<_DFSDM3_CR2, 2, 1>; // Injected data overrun interrupt enable
        using ROVRIE = Field<_DFSDM3_CR2, 3, 1>; // Regular data overrun interrupt enable
        using AWDIE = Field<_DFSDM3_CR2, 4, 1>; // Analog watchdog interrupt enable
        using SCDIE = Field<_DFSDM3_CR2, 5, 1>; // Short-circuit detector interrupt enable
        using CKABIE = Field<_DFSDM3_CR2, 6, 1>; // Clock absence interrupt enable
        using EXCH = Field<_DFSDM3_CR2, 8, 8>; // Extremes detector channel selection
        using AWDCH = Field<_DFSDM3_CR2, 16, 8>; // Analog watchdog channel selection
    };

    // DFSDM interrupt and status register
    struct _DFSDM0_ISR : Register<DFSDM_BASE + 0x108, ReadOnly, _DFSDM0_ISR> {
        using JEOCF = Field<_DFSDM0_ISR, 0, 1>; // End of injected conversion flag
        using REOCF = Field<_DFSDM0_ISR, 1, 1>; // End of regular conversion flag
        using JOVRF = Field<_DFSDM0_ISR, 2, 1>; // Injected conversion overrun flag
        using ROVRF = Field<_DFSDM0_ISR, 3, 1>; // Regular conversion overrun flag
        using AWDF = Field<_DFSDM0_ISR, 4, 1>; // Analog watchdog
        using JCIP = Field<_DFSDM0_ISR, 13, 1>; // Injected conversion in progress status
        using RCIP = Field<_DFSDM0_ISR, 14, 1>; // Regular conversion in progress status
        using CKABF = Field<_DFSDM0_ISR, 16, 8>; // Clock absence flag
        using SCDF = Field<_DFSDM0_ISR, 24, 8>; // short-circuit detector flag
    };

    // DFSDM interrupt and status register
    struct _DFSDM1_ISR : Register<DFSDM_BASE + 0x188, ReadOnly, _DFSDM1_ISR> {
        using JEOCF = Field<_DFSDM1_ISR, 0, 1>; // End of injected conversion flag
        using REOCF = Field<_DFSDM1_ISR, 1, 1>; // End of regular conversion flag
        using JOVRF = Field<_DFSDM1_ISR, 2, 1>; // Injected conversion overrun flag
        using ROVRF = Field<_DFSDM1_ISR, 3, 1>; // Regular conversion overrun flag
        using AWDF = Field<_DFSDM1_ISR, 4, 1>; // Analog watchdog
        using JCIP = Field<_DFSDM1_ISR, 13, 1>; // Injected conversion in progress status
        using RCIP = Field<_DFSDM1_ISR, 14, 1>; // Regular conversion in progress status
        using CKABF = Field<_DFSDM1_ISR, 16, 8>; // Clock absence flag
        using SCDF = Field<_DFSDM1_ISR, 24, 8>; // short-circuit detector flag
    };

    // DFSDM interrupt and status register
    struct _DFSDM2_ISR : Register<DFSDM_BASE + 0x208, ReadOnly, _DFSDM2_ISR> {
        using JEOCF = Field<_DFSDM2_ISR, 0, 1>; // End of injected conversion flag
        using REOCF = Field<_DFSDM2_ISR, 1, 1>; // End of regular conversion flag
        using JOVRF = Field<_DFSDM2_ISR, 2, 1>; // Injected conversion overrun flag
        using ROVRF = Field<_DFSDM2_ISR, 3, 1>; // Regular conversion overrun flag
        using AWDF = Field<_DFSDM2_ISR, 4, 1>; // Analog watchdog
        using JCIP = Field<_DFSDM2_ISR, 13, 1>; // Injected conversion in progress status
        using RCIP = Field<_DFSDM2_ISR, 14, 1>; // Regular conversion in progress status
        using CKABF = Field<_DFSDM2_ISR, 16, 8>; // Clock absence flag
        using SCDF = Field<_DFSDM2_ISR, 24, 8>; // short-circuit detector flag
    };

    // DFSDM interrupt and status register
    struct _DFSDM3_ISR : Register<DFSDM_BASE + 0x388, ReadOnly, _DFSDM3_ISR> {
        using JEOCF = Field<_DFSDM3_ISR, 0, 1>; // End of injected conversion flag
        using REOCF = Field<_DFSDM3_ISR, 1, 1>; // End of regular conversion flag
        using JOVRF = Field<_DFSDM3_ISR, 2, 1>; // Injected conversion overrun flag
        using ROVRF = Field<_DFSDM3_ISR, 3, 1>; // Regular conversion overrun flag
        using AWDF = Field<_DFSDM3_ISR, 4, 1>; // Analog watchdog
        using JCIP = Field<_DFSDM3_ISR, 13, 1>; // Injected conversion in progress status
        using RCIP = Field<_DFSDM3_ISR, 14, 1>; // Regular conversion in progress status
        using CKABF = Field<_DFSDM3_ISR, 16, 8>; // Clock absence flag
        using SCDF = Field<_DFSDM3_ISR, 24, 8>; // short-circuit detector flag
    };

    // DFSDM interrupt flag clear register
    struct _DFSDM0_ICR : Register<DFSDM_BASE + 0x10C, ReadWrite, _DFSDM0_ICR> {
        using CLRJOVRF = Field<_DFSDM0_ICR, 2, 1>; // Clear the injected conversion overrun flag
        using CLRROVRF = Field<_DFSDM0_ICR, 3, 1>; // Clear the regular conversion overrun flag
        using CLRCKABF = Field<_DFSDM0_ICR, 16, 8>; // Clear the clock absence flag
        using CLRSCDF = Field<_DFSDM0_ICR, 24, 8>; // Clear the short-circuit detector flag
    };

    // DFSDM interrupt flag clear register
    struct _DFSDM1_ICR : Register<DFSDM_BASE + 0x18C, ReadWrite, _DFSDM1_ICR> {
        using CLRJOVRF = Field<_DFSDM1_ICR, 2, 1>; // Clear the injected conversion overrun flag
        using CLRROVRF = Field<_DFSDM1_ICR, 3, 1>; // Clear the regular conversion overrun flag
        using CLRCKABF = Field<_DFSDM1_ICR, 16, 8>; // Clear the clock absence flag
        using CLRSCDF = Field<_DFSDM1_ICR, 24, 8>; // Clear the short-circuit detector flag
    };

    // DFSDM interrupt flag clear register
    struct _DFSDM2_ICR : Register<DFSDM_BASE + 0x20C, ReadWrite, _DFSDM2_ICR> {
        using CLRJOVRF = Field<_DFSDM2_ICR, 2, 1>; // Clear the injected conversion overrun flag
        using CLRROVRF = Field<_DFSDM2_ICR, 3, 1>; // Clear the regular conversion overrun flag
        using CLRCKABF = Field<_DFSDM2_ICR, 16, 8>; // Clear the clock absence flag
        using CLRSCDF = Field<_DFSDM2_ICR, 24, 8>; // Clear the short-circuit detector flag
    };

    // DFSDM interrupt flag clear register
    struct _DFSDM3_ICR : Register<DFSDM_BASE + 0x38C, ReadWrite, _DFSDM3_ICR> {
        using CLRJOVRF = Field<_DFSDM3_ICR, 2, 1>; // Clear the injected conversion overrun flag
        using CLRROVRF = Field<_DFSDM3_ICR, 3, 1>; // Clear the regular conversion overrun flag
        using CLRCKABF = Field<_DFSDM3_ICR, 16, 8>; // Clear the clock absence flag
        using CLRSCDF = Field<_DFSDM3_ICR, 24, 8>; // Clear the short-circuit detector flag
    };

    // DFSDM injected channel group selection register
    struct _DFSDM0_JCHGR : Register<DFSDM_BASE + 0x110, ReadWrite, _DFSDM0_JCHGR> {
        using JCHG = Field<_DFSDM0_JCHGR, 0, 8>; // Injected channel group selection
    };

    // DFSDM injected channel group selection register
    struct _DFSDM1_JCHGR : Register<DFSDM_BASE + 0x190, ReadWrite, _DFSDM1_JCHGR> {
        using JCHG = Field<_DFSDM1_JCHGR, 0, 8>; // Injected channel group selection
    };

    // DFSDM injected channel group selection register
    struct _DFSDM2_JCHGR : Register<DFSDM_BASE + 0x210, ReadWrite, _DFSDM2_JCHGR> {
        using JCHG = Field<_DFSDM2_JCHGR, 0, 8>; // Injected channel group selection
    };

    // DFSDM injected channel group selection register
    struct _DFSDM3_JCHGR : Register<DFSDM_BASE + 0x310, ReadWrite, _DFSDM3_JCHGR> {
        using JCHG = Field<_DFSDM3_JCHGR, 0, 8>; // Injected channel group selection
    };

    // DFSDM filter control register
    struct _DFSDM0_FCR : Register<DFSDM_BASE + 0x114, ReadWrite, _DFSDM0_FCR> {
        using IOSR = Field<_DFSDM0_FCR, 0, 8>; // Integrator oversampling ratio (averaging length)
        using FOSR = Field<_DFSDM0_FCR, 16, 10>; // Sinc filter oversampling ratio (decimation rate)
        using FORD = Field<_DFSDM0_FCR, 29, 3>; // Sinc filter order
    };

    // DFSDM filter control register
    struct _DFSDM1_FCR : Register<DFSDM_BASE + 0x194, ReadWrite, _DFSDM1_FCR> {
        using IOSR = Field<_DFSDM1_FCR, 0, 8>; // Integrator oversampling ratio (averaging length)
        using FOSR = Field<_DFSDM1_FCR, 16, 10>; // Sinc filter oversampling ratio (decimation rate)
        using FORD = Field<_DFSDM1_FCR, 29, 3>; // Sinc filter order
    };

    // DFSDM filter control register
    struct _DFSDM2_FCR : Register<DFSDM_BASE + 0x214, ReadWrite, _DFSDM2_FCR> {
        using IOSR = Field<_DFSDM2_FCR, 0, 8>; // Integrator oversampling ratio (averaging length)
        using FOSR = Field<_DFSDM2_FCR, 16, 10>; // Sinc filter oversampling ratio (decimation rate)
        using FORD = Field<_DFSDM2_FCR, 29, 3>; // Sinc filter order
    };

    // DFSDM filter control register
    struct _DFSDM3_FCR : Register<DFSDM_BASE + 0x314, ReadWrite, _DFSDM3_FCR> {
        using IOSR = Field<_DFSDM3_FCR, 0, 8>; // Integrator oversampling ratio (averaging length)
        using FOSR = Field<_DFSDM3_FCR, 16, 10>; // Sinc filter oversampling ratio (decimation rate)
        using FORD = Field<_DFSDM3_FCR, 29, 3>; // Sinc filter order
    };

    // DFSDM data register for injected group
    struct _DFSDM0_JDATAR : Register<DFSDM_BASE + 0x118, ReadOnly, _DFSDM0_JDATAR> {
        using JDATACH = Field<_DFSDM0_JDATAR, 0, 3>; // Injected channel most recently converted
        using JDATA = Field<_DFSDM0_JDATAR, 8, 24>; // Injected group conversion data
    };

    // DFSDM data register for injected group
    struct _DFSDM1_JDATAR : Register<DFSDM_BASE + 0x198, ReadOnly, _DFSDM1_JDATAR> {
        using JDATACH = Field<_DFSDM1_JDATAR, 0, 3>; // Injected channel most recently converted
        using JDATA = Field<_DFSDM1_JDATAR, 8, 24>; // Injected group conversion data
    };

    // DFSDM data register for injected group
    struct _DFSDM2_JDATAR : Register<DFSDM_BASE + 0x218, ReadOnly, _DFSDM2_JDATAR> {
        using JDATACH = Field<_DFSDM2_JDATAR, 0, 3>; // Injected channel most recently converted
        using JDATA = Field<_DFSDM2_JDATAR, 8, 24>; // Injected group conversion data
    };

    // DFSDM data register for injected group
    struct _DFSDM3_JDATAR : Register<DFSDM_BASE + 0x318, ReadOnly, _DFSDM3_JDATAR> {
        using JDATACH = Field<_DFSDM3_JDATAR, 0, 3>; // Injected channel most recently converted
        using JDATA = Field<_DFSDM3_JDATAR, 8, 24>; // Injected group conversion data
    };

    // DFSDM data register for the regular channel
    struct _DFSDM0_RDATAR : Register<DFSDM_BASE + 0x11C, ReadOnly, _DFSDM0_RDATAR> {
        using RDATACH = Field<_DFSDM0_RDATAR, 0, 3>; // Regular channel most recently converted
        using RPEND = Field<_DFSDM0_RDATAR, 4, 1>; // Regular channel pending data
        using RDATA = Field<_DFSDM0_RDATAR, 8, 24>; // Regular channel conversion data
    };

    // DFSDM data register for the regular channel
    struct _DFSDM1_RDATAR : Register<DFSDM_BASE + 0x198, ReadOnly, _DFSDM1_RDATAR> {
        using RDATACH = Field<_DFSDM1_RDATAR, 0, 3>; // Regular channel most recently converted
        using RPEND = Field<_DFSDM1_RDATAR, 4, 1>; // Regular channel pending data
        using RDATA = Field<_DFSDM1_RDATAR, 8, 24>; // Regular channel conversion data
    };

    // DFSDM data register for the regular channel
    struct _DFSDM2_RDATAR : Register<DFSDM_BASE + 0x218, ReadOnly, _DFSDM2_RDATAR> {
        using RDATACH = Field<_DFSDM2_RDATAR, 0, 3>; // Regular channel most recently converted
        using RPEND = Field<_DFSDM2_RDATAR, 4, 1>; // Regular channel pending data
        using RDATA = Field<_DFSDM2_RDATAR, 8, 24>; // Regular channel conversion data
    };

    // DFSDM data register for the regular channel
    struct _DFSDM3_RDATAR : Register<DFSDM_BASE + 0x318, ReadOnly, _DFSDM3_RDATAR> {
        using RDATACH = Field<_DFSDM3_RDATAR, 0, 3>; // Regular channel most recently converted
        using RPEND = Field<_DFSDM3_RDATAR, 4, 1>; // Regular channel pending data
        using RDATA = Field<_DFSDM3_RDATAR, 8, 24>; // Regular channel conversion data
    };

    // DFSDM analog watchdog high threshold register
    struct _DFSDM0_AWHTR : Register<DFSDM_BASE + 0x120, ReadWrite, _DFSDM0_AWHTR> {
        using BKAWH = Field<_DFSDM0_AWHTR, 0, 4>; // Break signal assignment to analog watchdog high threshold event
        using AWHT = Field<_DFSDM0_AWHTR, 8, 24>; // Analog watchdog high threshold
    };

    // DFSDM analog watchdog high threshold register
    struct _DFSDM1_AWHTR : Register<DFSDM_BASE + 0x1A0, ReadWrite, _DFSDM1_AWHTR> {
        using BKAWH = Field<_DFSDM1_AWHTR, 0, 4>; // Break signal assignment to analog watchdog high threshold event
        using AWHT = Field<_DFSDM1_AWHTR, 8, 24>; // Analog watchdog high threshold
    };

    // DFSDM analog watchdog high threshold register
    struct _DFSDM2_AWHTR : Register<DFSDM_BASE + 0x220, ReadWrite, _DFSDM2_AWHTR> {
        using BKAWH = Field<_DFSDM2_AWHTR, 0, 4>; // Break signal assignment to analog watchdog high threshold event
        using AWHT = Field<_DFSDM2_AWHTR, 8, 24>; // Analog watchdog high threshold
    };

    // DFSDM analog watchdog high threshold register
    struct _DFSDM3_AWHTR : Register<DFSDM_BASE + 0x2A0, ReadWrite, _DFSDM3_AWHTR> {
        using BKAWH = Field<_DFSDM3_AWHTR, 0, 4>; // Break signal assignment to analog watchdog high threshold event
        using AWHT = Field<_DFSDM3_AWHTR, 8, 24>; // Analog watchdog high threshold
    };

    // DFSDM analog watchdog low threshold register
    struct _DFSDM0_AWLTR : Register<DFSDM_BASE + 0x124, ReadWrite, _DFSDM0_AWLTR> {
        using BKAWL = Field<_DFSDM0_AWLTR, 0, 4>; // Break signal assignment to analog watchdog low threshold event
        using AWLT = Field<_DFSDM0_AWLTR, 8, 24>; // Analog watchdog low threshold
    };

    // DFSDM analog watchdog low threshold register
    struct _DFSDM1_AWLTR : Register<DFSDM_BASE + 0x1A4, ReadWrite, _DFSDM1_AWLTR> {
        using BKAWL = Field<_DFSDM1_AWLTR, 0, 4>; // Break signal assignment to analog watchdog low threshold event
        using AWLT = Field<_DFSDM1_AWLTR, 8, 24>; // Analog watchdog low threshold
    };

    // DFSDM analog watchdog low threshold register
    struct _DFSDM2_AWLTR : Register<DFSDM_BASE + 0x224, ReadWrite, _DFSDM2_AWLTR> {
        using BKAWL = Field<_DFSDM2_AWLTR, 0, 4>; // Break signal assignment to analog watchdog low threshold event
        using AWLT = Field<_DFSDM2_AWLTR, 8, 24>; // Analog watchdog low threshold
    };

    // DFSDM analog watchdog low threshold register
    struct _DFSDM3_AWLTR : Register<DFSDM_BASE + 0x2A4, ReadWrite, _DFSDM3_AWLTR> {
        using BKAWL = Field<_DFSDM3_AWLTR, 0, 4>; // Break signal assignment to analog watchdog low threshold event
        using AWLT = Field<_DFSDM3_AWLTR, 8, 24>; // Analog watchdog low threshold
    };

    // DFSDM analog watchdog status register
    struct _DFSDM0_AWSR : Register<DFSDM_BASE + 0x128, ReadOnly, _DFSDM0_AWSR> {
        using AWLTF = Field<_DFSDM0_AWSR, 0, 8>; // Analog watchdog low threshold flag
        using AWHTF = Field<_DFSDM0_AWSR, 8, 8>; // Analog watchdog high threshold flag
    };

    // DFSDM analog watchdog status register
    struct _DFSDM1_AWSR : Register<DFSDM_BASE + 0x1A8, ReadOnly, _DFSDM1_AWSR> {
        using AWLTF = Field<_DFSDM1_AWSR, 0, 8>; // Analog watchdog low threshold flag
        using AWHTF = Field<_DFSDM1_AWSR, 8, 8>; // Analog watchdog high threshold flag
    };

    // DFSDM analog watchdog status register
    struct _DFSDM2_AWSR : Register<DFSDM_BASE + 0x228, ReadOnly, _DFSDM2_AWSR> {
        using AWLTF = Field<_DFSDM2_AWSR, 0, 8>; // Analog watchdog low threshold flag
        using AWHTF = Field<_DFSDM2_AWSR, 8, 8>; // Analog watchdog high threshold flag
    };

    // DFSDM analog watchdog status register
    struct _DFSDM3_AWSR : Register<DFSDM_BASE + 0x2A8, ReadOnly, _DFSDM3_AWSR> {
        using AWLTF = Field<_DFSDM3_AWSR, 0, 8>; // Analog watchdog low threshold flag
        using AWHTF = Field<_DFSDM3_AWSR, 8, 8>; // Analog watchdog high threshold flag
    };

    // DFSDM analog watchdog clear flag register
    struct _DFSDM0_AWCFR : Register<DFSDM_BASE + 0x12C, ReadWrite, _DFSDM0_AWCFR> {
        using CLRAWLTF = Field<_DFSDM0_AWCFR, 0, 8>; // Clear the analog watchdog low threshold flag
        using CLRAWHTF = Field<_DFSDM0_AWCFR, 8, 8>; // Clear the analog watchdog high threshold flag
    };

    // DFSDM analog watchdog clear flag register
    struct _DFSDM1_AWCFR : Register<DFSDM_BASE + 0x1AC, ReadWrite, _DFSDM1_AWCFR> {
        using CLRAWLTF = Field<_DFSDM1_AWCFR, 0, 8>; // Clear the analog watchdog low threshold flag
        using CLRAWHTF = Field<_DFSDM1_AWCFR, 8, 8>; // Clear the analog watchdog high threshold flag
    };

    // DFSDM analog watchdog clear flag register
    struct _DFSDM2_AWCFR : Register<DFSDM_BASE + 0x22C, ReadWrite, _DFSDM2_AWCFR> {
        using CLRAWLTF = Field<_DFSDM2_AWCFR, 0, 8>; // Clear the analog watchdog low threshold flag
        using CLRAWHTF = Field<_DFSDM2_AWCFR, 8, 8>; // Clear the analog watchdog high threshold flag
    };

    // DFSDM analog watchdog clear flag register
    struct _DFSDM3_AWCFR : Register<DFSDM_BASE + 0x2AC, ReadWrite, _DFSDM3_AWCFR> {
        using CLRAWLTF = Field<_DFSDM3_AWCFR, 0, 8>; // Clear the analog watchdog low threshold flag
        using CLRAWHTF = Field<_DFSDM3_AWCFR, 8, 8>; // Clear the analog watchdog high threshold flag
    };

    // DFSDM Extremes detector maximum register
    struct _DFSDM0_EXMAX : Register<DFSDM_BASE + 0x130, ReadOnly, _DFSDM0_EXMAX> {
        using EXMAXCH = Field<_DFSDM0_EXMAX, 0, 3>; // Extremes detector maximum data channel
        using EXMAX = Field<_DFSDM0_EXMAX, 8, 24>; // Extremes detector maximum value
    };

    // DFSDM Extremes detector maximum register
    struct _DFSDM1_EXMAX : Register<DFSDM_BASE + 0x1B0, ReadOnly, _DFSDM1_EXMAX> {
        using EXMAXCH = Field<_DFSDM1_EXMAX, 0, 3>; // Extremes detector maximum data channel
        using EXMAX = Field<_DFSDM1_EXMAX, 8, 24>; // Extremes detector maximum value
    };

    // DFSDM Extremes detector maximum register
    struct _DFSDM2_EXMAX : Register<DFSDM_BASE + 0x230, ReadOnly, _DFSDM2_EXMAX> {
        using EXMAXCH = Field<_DFSDM2_EXMAX, 0, 3>; // Extremes detector maximum data channel
        using EXMAX = Field<_DFSDM2_EXMAX, 8, 24>; // Extremes detector maximum value
    };

    // DFSDM Extremes detector maximum register
    struct _DFSDM3_EXMAX : Register<DFSDM_BASE + 0x2B0, ReadOnly, _DFSDM3_EXMAX> {
        using EXMAXCH = Field<_DFSDM3_EXMAX, 0, 3>; // Extremes detector maximum data channel
        using EXMAX = Field<_DFSDM3_EXMAX, 8, 24>; // Extremes detector maximum value
    };

    // DFSDM Extremes detector minimum register
    struct _DFSDM0_EXMIN : Register<DFSDM_BASE + 0x134, ReadOnly, _DFSDM0_EXMIN> {
        using EXMINCH = Field<_DFSDM0_EXMIN, 0, 3>; // Extremes detector minimum data channel
        using EXMIN = Field<_DFSDM0_EXMIN, 8, 24>; // Extremes detector minimum value
    };

    // DFSDM Extremes detector minimum register
    struct _DFSDM1_EXMIN : Register<DFSDM_BASE + 0x1B4, ReadOnly, _DFSDM1_EXMIN> {
        using EXMINCH = Field<_DFSDM1_EXMIN, 0, 3>; // Extremes detector minimum data channel
        using EXMIN = Field<_DFSDM1_EXMIN, 8, 24>; // Extremes detector minimum value
    };

    // DFSDM Extremes detector minimum register
    struct _DFSDM2_EXMIN : Register<DFSDM_BASE + 0x234, ReadOnly, _DFSDM2_EXMIN> {
        using EXMINCH = Field<_DFSDM2_EXMIN, 0, 3>; // Extremes detector minimum data channel
        using EXMIN = Field<_DFSDM2_EXMIN, 8, 24>; // Extremes detector minimum value
    };

    // DFSDM Extremes detector minimum register
    struct _DFSDM3_EXMIN : Register<DFSDM_BASE + 0x2B4, ReadOnly, _DFSDM3_EXMIN> {
        using EXMINCH = Field<_DFSDM3_EXMIN, 0, 3>; // Extremes detector minimum data channel
        using EXMIN = Field<_DFSDM3_EXMIN, 8, 24>; // Extremes detector minimum value
    };

    // DFSDM conversion timer register
    struct _DFSDM0_CNVTIMR : Register<DFSDM_BASE + 0x138, ReadOnly, _DFSDM0_CNVTIMR> {
        using CNVCNT = Field<_DFSDM0_CNVTIMR, 4, 28>; // 28-bit timer counting conversion time
    };

    // DFSDM conversion timer register
    struct _DFSDM1_CNVTIMR : Register<DFSDM_BASE + 0x1B8, ReadOnly, _DFSDM1_CNVTIMR> {
        using CNVCNT = Field<_DFSDM1_CNVTIMR, 4, 28>; // 28-bit timer counting conversion time
    };

    // DFSDM conversion timer register
    struct _DFSDM2_CNVTIMR : Register<DFSDM_BASE + 0x238, ReadOnly, _DFSDM2_CNVTIMR> {
        using CNVCNT = Field<_DFSDM2_CNVTIMR, 4, 28>; // 28-bit timer counting conversion time
    };

    // DFSDM conversion timer register
    struct _DFSDM3_CNVTIMR : Register<DFSDM_BASE + 0x2B8, ReadOnly, _DFSDM3_CNVTIMR> {
        using CNVCNT = Field<_DFSDM3_CNVTIMR, 4, 28>; // 28-bit timer counting conversion time
    };

} // namespace DFSDM

// --------------------------------------------
// JPEG: JPEG codec
// Base address: 0x50051000
// --------------------------------------------

namespace JPEG {
    static constexpr uint32_t JPEG_BASE = 0x50051000;

    // JPEG codec configuration register 0
    struct _JPEG_CONFR0 : Register<JPEG_BASE + 0x0, WriteOnly, _JPEG_CONFR0> {
        using START = Field<_JPEG_CONFR0, 0, 1>; // Start
    };

    // JPEG codec configuration register 1
    struct _JPEG_CONFR1 : Register<JPEG_BASE + 0x4, ReadWrite, _JPEG_CONFR1> {
        using NF = Field<_JPEG_CONFR1, 0, 2>; // Number of color components
        using DE = Field<_JPEG_CONFR1, 3, 1>; // Decoding Enable
        using COLORSPACE = Field<_JPEG_CONFR1, 4, 2>; // Color Space
        using NS = Field<_JPEG_CONFR1, 6, 2>; // Number of components for Scan
        using HDR = Field<_JPEG_CONFR1, 8, 1>; // Header Processing
        using YSIZE = Field<_JPEG_CONFR1, 16, 16>; // Y Size
    };

    // JPEG codec configuration register 2
    struct _JPEG_CONFR2 : Register<JPEG_BASE + 0x8, ReadWrite, _JPEG_CONFR2> {
        using NMCU = Field<_JPEG_CONFR2, 0, 26>; // Number of MCU
    };

    // JPEG codec configuration register 3
    struct _JPEG_CONFR3 : Register<JPEG_BASE + 0xC, ReadWrite, _JPEG_CONFR3> {
        using XSIZE = Field<_JPEG_CONFR3, 16, 16>; // X size
    };

    // JPEG codec configuration register 4
    struct _JPEG_CONFR4 : Register<JPEG_BASE + 0x10, ReadWrite, _JPEG_CONFR4> {
        using HD = Field<_JPEG_CONFR4, 0, 1>; // Huffman DC
        using HA = Field<_JPEG_CONFR4, 1, 1>; // Huffman AC
        using QT = Field<_JPEG_CONFR4, 2, 2>; // Quantization Table
        using NB = Field<_JPEG_CONFR4, 4, 4>; // Number of Block
        using VSF = Field<_JPEG_CONFR4, 8, 4>; // Vertical Sampling Factor
        using HSF = Field<_JPEG_CONFR4, 12, 4>; // Horizontal Sampling Factor
    };

    // JPEG codec configuration register 5
    struct _JPEG_CONFR5 : Register<JPEG_BASE + 0x14, ReadWrite, _JPEG_CONFR5> {
        using HD = Field<_JPEG_CONFR5, 0, 1>; // Huffman DC
        using HA = Field<_JPEG_CONFR5, 1, 1>; // Huffman AC
        using QT = Field<_JPEG_CONFR5, 2, 2>; // Quantization Table
        using NB = Field<_JPEG_CONFR5, 4, 4>; // Number of Block
        using VSF = Field<_JPEG_CONFR5, 8, 4>; // Vertical Sampling Factor
        using HSF = Field<_JPEG_CONFR5, 12, 4>; // Horizontal Sampling Factor
    };

    // JPEG codec configuration register 6
    struct _JPEG_CONFR6 : Register<JPEG_BASE + 0x18, ReadWrite, _JPEG_CONFR6> {
        using HD = Field<_JPEG_CONFR6, 0, 1>; // Huffman DC
        using HA = Field<_JPEG_CONFR6, 1, 1>; // Huffman AC
        using QT = Field<_JPEG_CONFR6, 2, 2>; // Quantization Table
        using NB = Field<_JPEG_CONFR6, 4, 4>; // Number of Block
        using VSF = Field<_JPEG_CONFR6, 8, 4>; // Vertical Sampling Factor
        using HSF = Field<_JPEG_CONFR6, 12, 4>; // Horizontal Sampling Factor
    };

    // JPEG codec configuration register 7
    struct _JPEG_CONFR7 : Register<JPEG_BASE + 0x1C, ReadWrite, _JPEG_CONFR7> {
        using HD = Field<_JPEG_CONFR7, 0, 1>; // Huffman DC
        using HA = Field<_JPEG_CONFR7, 1, 1>; // Huffman AC
        using QT = Field<_JPEG_CONFR7, 2, 2>; // Quantization Table
        using NB = Field<_JPEG_CONFR7, 4, 4>; // Number of Block
        using VSF = Field<_JPEG_CONFR7, 8, 4>; // Vertical Sampling Factor
        using HSF = Field<_JPEG_CONFR7, 12, 4>; // Horizontal Sampling Factor
    };

    // JPEG control register
    struct _JPEG_CR : Register<JPEG_BASE + 0x30, ReadWrite, _JPEG_CR> {
        using JCEN = Field<_JPEG_CR, 0, 1>; // JPEG Core Enable
        using IFTIE = Field<_JPEG_CR, 1, 1>; // Input FIFO Threshold Interrupt Enable
        using IFNFIE = Field<_JPEG_CR, 2, 1>; // Input FIFO Not Full Interrupt Enable
        using OFTIE = Field<_JPEG_CR, 3, 1>; // Output FIFO Threshold Interrupt Enable
        using OFNEIE = Field<_JPEG_CR, 4, 1>; // Output FIFO Not Empty Interrupt Enable
        using EOCIE = Field<_JPEG_CR, 5, 1>; // End of Conversion Interrupt Enable
        using HPDIE = Field<_JPEG_CR, 6, 1>; // Header Parsing Done Interrupt Enable
        using IDMAEN = Field<_JPEG_CR, 11, 1>; // Input DMA Enable
        using ODMAEN = Field<_JPEG_CR, 12, 1>; // Output DMA Enable
        using IFF = Field<_JPEG_CR, 13, 1>; // Input FIFO Flush
        using OFF = Field<_JPEG_CR, 14, 1>; // Output FIFO Flush
    };

    // JPEG status register
    struct _JPEG_SR : Register<JPEG_BASE + 0x34, ReadOnly, _JPEG_SR> {
        using IFTF = Field<_JPEG_SR, 1, 1>; // Input FIFO Threshold Flag
        using IFNFF = Field<_JPEG_SR, 2, 1>; // Input FIFO Not Full Flag
        using OFTF = Field<_JPEG_SR, 3, 1>; // Output FIFO Threshold Flag
        using OFNEF = Field<_JPEG_SR, 4, 1>; // Output FIFO Not Empty Flag
        using EOCF = Field<_JPEG_SR, 5, 1>; // End of Conversion Flag
        using HPDF = Field<_JPEG_SR, 6, 1>; // Header Parsing Done Flag
        using COF = Field<_JPEG_SR, 7, 1>; // Codec Operation Flag
    };

    // JPEG clear flag register
    struct _JPEG_CFR : Register<JPEG_BASE + 0x38, WriteOnly, _JPEG_CFR> {
        using CEOCF = Field<_JPEG_CFR, 5, 1>; // Clear End of Conversion Flag
        using CHPDF = Field<_JPEG_CFR, 6, 1>; // Clear Header Parsing Done Flag
    };

    // JPEG data input register
    struct _JPEG_DIR : Register<JPEG_BASE + 0x40, WriteOnly, _JPEG_DIR> {
        using DATAIN = Field<_JPEG_DIR, 0, 32>; // Data Input FIFO
    };

    // JPEG data output register
    struct _JPEG_DOR : Register<JPEG_BASE + 0x44, ReadOnly, _JPEG_DOR> {
        using DATAOUT = Field<_JPEG_DOR, 0, 32>; // Data Output FIFO
    };

    // JPEG quantization tables
    struct _QMEM0_0 : Register<JPEG_BASE + 0x50, ReadWrite, _QMEM0_0> {
        using QMem_RAM = Field<_QMEM0_0, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_1 : Register<JPEG_BASE + 0x54, ReadWrite, _QMEM0_1> {
        using QMem_RAM = Field<_QMEM0_1, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_2 : Register<JPEG_BASE + 0x58, ReadWrite, _QMEM0_2> {
        using QMem_RAM = Field<_QMEM0_2, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_3 : Register<JPEG_BASE + 0x5C, ReadWrite, _QMEM0_3> {
        using QMem_RAM = Field<_QMEM0_3, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_4 : Register<JPEG_BASE + 0x60, ReadWrite, _QMEM0_4> {
        using QMem_RAM = Field<_QMEM0_4, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_5 : Register<JPEG_BASE + 0x64, ReadWrite, _QMEM0_5> {
        using QMem_RAM = Field<_QMEM0_5, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_6 : Register<JPEG_BASE + 0x68, ReadWrite, _QMEM0_6> {
        using QMem_RAM = Field<_QMEM0_6, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_7 : Register<JPEG_BASE + 0x6C, ReadWrite, _QMEM0_7> {
        using QMem_RAM = Field<_QMEM0_7, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_8 : Register<JPEG_BASE + 0x70, ReadWrite, _QMEM0_8> {
        using QMem_RAM = Field<_QMEM0_8, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_9 : Register<JPEG_BASE + 0x74, ReadWrite, _QMEM0_9> {
        using QMem_RAM = Field<_QMEM0_9, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_10 : Register<JPEG_BASE + 0x78, ReadWrite, _QMEM0_10> {
        using QMem_RAM = Field<_QMEM0_10, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_11 : Register<JPEG_BASE + 0x7C, ReadWrite, _QMEM0_11> {
        using QMem_RAM = Field<_QMEM0_11, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_12 : Register<JPEG_BASE + 0x80, ReadWrite, _QMEM0_12> {
        using QMem_RAM = Field<_QMEM0_12, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_13 : Register<JPEG_BASE + 0x84, ReadWrite, _QMEM0_13> {
        using QMem_RAM = Field<_QMEM0_13, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_14 : Register<JPEG_BASE + 0x88, ReadWrite, _QMEM0_14> {
        using QMem_RAM = Field<_QMEM0_14, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM0_15 : Register<JPEG_BASE + 0x8C, ReadWrite, _QMEM0_15> {
        using QMem_RAM = Field<_QMEM0_15, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_0 : Register<JPEG_BASE + 0x90, ReadWrite, _QMEM1_0> {
        using QMem_RAM = Field<_QMEM1_0, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_1 : Register<JPEG_BASE + 0x94, ReadWrite, _QMEM1_1> {
        using QMem_RAM = Field<_QMEM1_1, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_2 : Register<JPEG_BASE + 0x98, ReadWrite, _QMEM1_2> {
        using QMem_RAM = Field<_QMEM1_2, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_3 : Register<JPEG_BASE + 0x9C, ReadWrite, _QMEM1_3> {
        using QMem_RAM = Field<_QMEM1_3, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_4 : Register<JPEG_BASE + 0xA0, ReadWrite, _QMEM1_4> {
        using QMem_RAM = Field<_QMEM1_4, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_5 : Register<JPEG_BASE + 0xA4, ReadWrite, _QMEM1_5> {
        using QMem_RAM = Field<_QMEM1_5, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_6 : Register<JPEG_BASE + 0xA8, ReadWrite, _QMEM1_6> {
        using QMem_RAM = Field<_QMEM1_6, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_7 : Register<JPEG_BASE + 0xAC, ReadWrite, _QMEM1_7> {
        using QMem_RAM = Field<_QMEM1_7, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_8 : Register<JPEG_BASE + 0xB0, ReadWrite, _QMEM1_8> {
        using QMem_RAM = Field<_QMEM1_8, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_9 : Register<JPEG_BASE + 0xB4, ReadWrite, _QMEM1_9> {
        using QMem_RAM = Field<_QMEM1_9, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_10 : Register<JPEG_BASE + 0xB8, ReadWrite, _QMEM1_10> {
        using QMem_RAM = Field<_QMEM1_10, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_11 : Register<JPEG_BASE + 0xBC, ReadWrite, _QMEM1_11> {
        using QMem_RAM = Field<_QMEM1_11, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_12 : Register<JPEG_BASE + 0xC0, ReadWrite, _QMEM1_12> {
        using QMem_RAM = Field<_QMEM1_12, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_13 : Register<JPEG_BASE + 0xC4, ReadWrite, _QMEM1_13> {
        using QMem_RAM = Field<_QMEM1_13, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_14 : Register<JPEG_BASE + 0xC8, ReadWrite, _QMEM1_14> {
        using QMem_RAM = Field<_QMEM1_14, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM1_15 : Register<JPEG_BASE + 0xCC, ReadWrite, _QMEM1_15> {
        using QMem_RAM = Field<_QMEM1_15, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_0 : Register<JPEG_BASE + 0xD0, ReadWrite, _QMEM2_0> {
        using QMem_RAM = Field<_QMEM2_0, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_1 : Register<JPEG_BASE + 0xD4, ReadWrite, _QMEM2_1> {
        using QMem_RAM = Field<_QMEM2_1, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_2 : Register<JPEG_BASE + 0xD8, ReadWrite, _QMEM2_2> {
        using QMem_RAM = Field<_QMEM2_2, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_3 : Register<JPEG_BASE + 0xDC, ReadWrite, _QMEM2_3> {
        using QMem_RAM = Field<_QMEM2_3, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_4 : Register<JPEG_BASE + 0xE0, ReadWrite, _QMEM2_4> {
        using QMem_RAM = Field<_QMEM2_4, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_5 : Register<JPEG_BASE + 0xE4, ReadWrite, _QMEM2_5> {
        using QMem_RAM = Field<_QMEM2_5, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_6 : Register<JPEG_BASE + 0xE8, ReadWrite, _QMEM2_6> {
        using QMem_RAM = Field<_QMEM2_6, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_7 : Register<JPEG_BASE + 0xEC, ReadWrite, _QMEM2_7> {
        using QMem_RAM = Field<_QMEM2_7, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_8 : Register<JPEG_BASE + 0xF0, ReadWrite, _QMEM2_8> {
        using QMem_RAM = Field<_QMEM2_8, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_9 : Register<JPEG_BASE + 0xF4, ReadWrite, _QMEM2_9> {
        using QMem_RAM = Field<_QMEM2_9, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_10 : Register<JPEG_BASE + 0xF8, ReadWrite, _QMEM2_10> {
        using QMem_RAM = Field<_QMEM2_10, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_11 : Register<JPEG_BASE + 0xFC, ReadWrite, _QMEM2_11> {
        using QMem_RAM = Field<_QMEM2_11, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_12 : Register<JPEG_BASE + 0x100, ReadWrite, _QMEM2_12> {
        using QMem_RAM = Field<_QMEM2_12, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_13 : Register<JPEG_BASE + 0x104, ReadWrite, _QMEM2_13> {
        using QMem_RAM = Field<_QMEM2_13, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_14 : Register<JPEG_BASE + 0x108, ReadWrite, _QMEM2_14> {
        using QMem_RAM = Field<_QMEM2_14, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM2_15 : Register<JPEG_BASE + 0x10C, ReadWrite, _QMEM2_15> {
        using QMem_RAM = Field<_QMEM2_15, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_0 : Register<JPEG_BASE + 0x110, ReadWrite, _QMEM3_0> {
        using QMem_RAM = Field<_QMEM3_0, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_1 : Register<JPEG_BASE + 0x114, ReadWrite, _QMEM3_1> {
        using QMem_RAM = Field<_QMEM3_1, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_2 : Register<JPEG_BASE + 0x118, ReadWrite, _QMEM3_2> {
        using QMem_RAM = Field<_QMEM3_2, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_3 : Register<JPEG_BASE + 0x11C, ReadWrite, _QMEM3_3> {
        using QMem_RAM = Field<_QMEM3_3, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_4 : Register<JPEG_BASE + 0x120, ReadWrite, _QMEM3_4> {
        using QMem_RAM = Field<_QMEM3_4, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_5 : Register<JPEG_BASE + 0x124, ReadWrite, _QMEM3_5> {
        using QMem_RAM = Field<_QMEM3_5, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_6 : Register<JPEG_BASE + 0x128, ReadWrite, _QMEM3_6> {
        using QMem_RAM = Field<_QMEM3_6, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_7 : Register<JPEG_BASE + 0x12C, ReadWrite, _QMEM3_7> {
        using QMem_RAM = Field<_QMEM3_7, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_8 : Register<JPEG_BASE + 0x130, ReadWrite, _QMEM3_8> {
        using QMem_RAM = Field<_QMEM3_8, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_9 : Register<JPEG_BASE + 0x134, ReadWrite, _QMEM3_9> {
        using QMem_RAM = Field<_QMEM3_9, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_10 : Register<JPEG_BASE + 0x138, ReadWrite, _QMEM3_10> {
        using QMem_RAM = Field<_QMEM3_10, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_11 : Register<JPEG_BASE + 0x13C, ReadWrite, _QMEM3_11> {
        using QMem_RAM = Field<_QMEM3_11, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_12 : Register<JPEG_BASE + 0x140, ReadWrite, _QMEM3_12> {
        using QMem_RAM = Field<_QMEM3_12, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_13 : Register<JPEG_BASE + 0x144, ReadWrite, _QMEM3_13> {
        using QMem_RAM = Field<_QMEM3_13, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_14 : Register<JPEG_BASE + 0x148, ReadWrite, _QMEM3_14> {
        using QMem_RAM = Field<_QMEM3_14, 0, 32>; // QMem RAM
    };

    // JPEG quantization tables
    struct _QMEM3_15 : Register<JPEG_BASE + 0x14C, ReadWrite, _QMEM3_15> {
        using QMem_RAM = Field<_QMEM3_15, 0, 32>; // QMem RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_0 : Register<JPEG_BASE + 0x150, ReadWrite, _HUFFMIN_0> {
        using HuffMin_RAM = Field<_HUFFMIN_0, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_1 : Register<JPEG_BASE + 0x154, ReadWrite, _HUFFMIN_1> {
        using HuffMin_RAM = Field<_HUFFMIN_1, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_2 : Register<JPEG_BASE + 0x158, ReadWrite, _HUFFMIN_2> {
        using HuffMin_RAM = Field<_HUFFMIN_2, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_3 : Register<JPEG_BASE + 0x15C, ReadWrite, _HUFFMIN_3> {
        using HuffMin_RAM = Field<_HUFFMIN_3, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_4 : Register<JPEG_BASE + 0x160, ReadWrite, _HUFFMIN_4> {
        using HuffMin_RAM = Field<_HUFFMIN_4, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_5 : Register<JPEG_BASE + 0x164, ReadWrite, _HUFFMIN_5> {
        using HuffMin_RAM = Field<_HUFFMIN_5, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_6 : Register<JPEG_BASE + 0x168, ReadWrite, _HUFFMIN_6> {
        using HuffMin_RAM = Field<_HUFFMIN_6, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_7 : Register<JPEG_BASE + 0x16C, ReadWrite, _HUFFMIN_7> {
        using HuffMin_RAM = Field<_HUFFMIN_7, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_8 : Register<JPEG_BASE + 0x170, ReadWrite, _HUFFMIN_8> {
        using HuffMin_RAM = Field<_HUFFMIN_8, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_9 : Register<JPEG_BASE + 0x174, ReadWrite, _HUFFMIN_9> {
        using HuffMin_RAM = Field<_HUFFMIN_9, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_10 : Register<JPEG_BASE + 0x178, ReadWrite, _HUFFMIN_10> {
        using HuffMin_RAM = Field<_HUFFMIN_10, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_11 : Register<JPEG_BASE + 0x17C, ReadWrite, _HUFFMIN_11> {
        using HuffMin_RAM = Field<_HUFFMIN_11, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_12 : Register<JPEG_BASE + 0x180, ReadWrite, _HUFFMIN_12> {
        using HuffMin_RAM = Field<_HUFFMIN_12, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_13 : Register<JPEG_BASE + 0x184, ReadWrite, _HUFFMIN_13> {
        using HuffMin_RAM = Field<_HUFFMIN_13, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_14 : Register<JPEG_BASE + 0x188, ReadWrite, _HUFFMIN_14> {
        using HuffMin_RAM = Field<_HUFFMIN_14, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffMin tables
    struct _HUFFMIN_15 : Register<JPEG_BASE + 0x18C, ReadWrite, _HUFFMIN_15> {
        using HuffMin_RAM = Field<_HUFFMIN_15, 0, 32>; // HuffMin RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE0 : Register<JPEG_BASE + 0x190, ReadWrite, _HUFFBASE0> {
        using HuffBase_RAM_0 = Field<_HUFFBASE0, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE0, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE1 : Register<JPEG_BASE + 0x194, ReadWrite, _HUFFBASE1> {
        using HuffBase_RAM_0 = Field<_HUFFBASE1, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE1, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE2 : Register<JPEG_BASE + 0x198, ReadWrite, _HUFFBASE2> {
        using HuffBase_RAM_0 = Field<_HUFFBASE2, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE2, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE3 : Register<JPEG_BASE + 0x19C, ReadWrite, _HUFFBASE3> {
        using HuffBase_RAM_0 = Field<_HUFFBASE3, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE3, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE4 : Register<JPEG_BASE + 0x1A0, ReadWrite, _HUFFBASE4> {
        using HuffBase_RAM_0 = Field<_HUFFBASE4, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE4, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE5 : Register<JPEG_BASE + 0x1A4, ReadWrite, _HUFFBASE5> {
        using HuffBase_RAM_0 = Field<_HUFFBASE5, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE5, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE6 : Register<JPEG_BASE + 0x1A8, ReadWrite, _HUFFBASE6> {
        using HuffBase_RAM_0 = Field<_HUFFBASE6, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE6, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE7 : Register<JPEG_BASE + 0x1AC, ReadWrite, _HUFFBASE7> {
        using HuffBase_RAM_0 = Field<_HUFFBASE7, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE7, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE8 : Register<JPEG_BASE + 0x1B0, ReadWrite, _HUFFBASE8> {
        using HuffBase_RAM_0 = Field<_HUFFBASE8, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE8, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE9 : Register<JPEG_BASE + 0x1B4, ReadWrite, _HUFFBASE9> {
        using HuffBase_RAM_0 = Field<_HUFFBASE9, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE9, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE10 : Register<JPEG_BASE + 0x1B8, ReadWrite, _HUFFBASE10> {
        using HuffBase_RAM_0 = Field<_HUFFBASE10, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE10, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE11 : Register<JPEG_BASE + 0x1BC, ReadWrite, _HUFFBASE11> {
        using HuffBase_RAM_0 = Field<_HUFFBASE11, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE11, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE12 : Register<JPEG_BASE + 0x1C0, ReadWrite, _HUFFBASE12> {
        using HuffBase_RAM_0 = Field<_HUFFBASE12, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE12, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE13 : Register<JPEG_BASE + 0x1C4, ReadWrite, _HUFFBASE13> {
        using HuffBase_RAM_0 = Field<_HUFFBASE13, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE13, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE14 : Register<JPEG_BASE + 0x1C8, ReadWrite, _HUFFBASE14> {
        using HuffBase_RAM_0 = Field<_HUFFBASE14, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE14, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE15 : Register<JPEG_BASE + 0x1CC, ReadWrite, _HUFFBASE15> {
        using HuffBase_RAM_0 = Field<_HUFFBASE15, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE15, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE16 : Register<JPEG_BASE + 0x1D0, ReadWrite, _HUFFBASE16> {
        using HuffBase_RAM_0 = Field<_HUFFBASE16, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE16, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE17 : Register<JPEG_BASE + 0x1D4, ReadWrite, _HUFFBASE17> {
        using HuffBase_RAM_0 = Field<_HUFFBASE17, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE17, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE18 : Register<JPEG_BASE + 0x1D8, ReadWrite, _HUFFBASE18> {
        using HuffBase_RAM_0 = Field<_HUFFBASE18, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE18, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE19 : Register<JPEG_BASE + 0x1DC, ReadWrite, _HUFFBASE19> {
        using HuffBase_RAM_0 = Field<_HUFFBASE19, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE19, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE20 : Register<JPEG_BASE + 0x1E0, ReadWrite, _HUFFBASE20> {
        using HuffBase_RAM_0 = Field<_HUFFBASE20, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE20, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE21 : Register<JPEG_BASE + 0x1E4, ReadWrite, _HUFFBASE21> {
        using HuffBase_RAM_0 = Field<_HUFFBASE21, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE21, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE22 : Register<JPEG_BASE + 0x1E8, ReadWrite, _HUFFBASE22> {
        using HuffBase_RAM_0 = Field<_HUFFBASE22, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE22, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE23 : Register<JPEG_BASE + 0x1EC, ReadWrite, _HUFFBASE23> {
        using HuffBase_RAM_0 = Field<_HUFFBASE23, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE23, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE24 : Register<JPEG_BASE + 0x1F0, ReadWrite, _HUFFBASE24> {
        using HuffBase_RAM_0 = Field<_HUFFBASE24, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE24, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE25 : Register<JPEG_BASE + 0x1F4, ReadWrite, _HUFFBASE25> {
        using HuffBase_RAM_0 = Field<_HUFFBASE25, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE25, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE26 : Register<JPEG_BASE + 0x1F8, ReadWrite, _HUFFBASE26> {
        using HuffBase_RAM_0 = Field<_HUFFBASE26, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE26, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE27 : Register<JPEG_BASE + 0x1FC, ReadWrite, _HUFFBASE27> {
        using HuffBase_RAM_0 = Field<_HUFFBASE27, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE27, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE28 : Register<JPEG_BASE + 0x200, ReadWrite, _HUFFBASE28> {
        using HuffBase_RAM_0 = Field<_HUFFBASE28, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE28, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE29 : Register<JPEG_BASE + 0x204, ReadWrite, _HUFFBASE29> {
        using HuffBase_RAM_0 = Field<_HUFFBASE29, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE29, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE30 : Register<JPEG_BASE + 0x208, ReadWrite, _HUFFBASE30> {
        using HuffBase_RAM_0 = Field<_HUFFBASE30, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE30, 16, 9>; // HuffBase RAM
    };

    // JPEG HuffSymb tables
    struct _HUFFBASE31 : Register<JPEG_BASE + 0x20C, ReadWrite, _HUFFBASE31> {
        using HuffBase_RAM_0 = Field<_HUFFBASE31, 0, 9>; // HuffBase RAM
        using HuffBase_RAM_1 = Field<_HUFFBASE31, 16, 9>; // HuffBase RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB0 : Register<JPEG_BASE + 0x210, ReadWrite, _HUFFSYMB0> {
        using HuffSymb_RAM = Field<_HUFFSYMB0, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB1 : Register<JPEG_BASE + 0x214, ReadWrite, _HUFFSYMB1> {
        using HuffSymb_RAM = Field<_HUFFSYMB1, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB2 : Register<JPEG_BASE + 0x218, ReadWrite, _HUFFSYMB2> {
        using HuffSymb_RAM = Field<_HUFFSYMB2, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB3 : Register<JPEG_BASE + 0x21C, ReadWrite, _HUFFSYMB3> {
        using HuffSymb_RAM = Field<_HUFFSYMB3, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB4 : Register<JPEG_BASE + 0x220, ReadWrite, _HUFFSYMB4> {
        using HuffSymb_RAM = Field<_HUFFSYMB4, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB5 : Register<JPEG_BASE + 0x224, ReadWrite, _HUFFSYMB5> {
        using HuffSymb_RAM = Field<_HUFFSYMB5, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB6 : Register<JPEG_BASE + 0x228, ReadWrite, _HUFFSYMB6> {
        using HuffSymb_RAM = Field<_HUFFSYMB6, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB7 : Register<JPEG_BASE + 0x22C, ReadWrite, _HUFFSYMB7> {
        using HuffSymb_RAM = Field<_HUFFSYMB7, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB8 : Register<JPEG_BASE + 0x230, ReadWrite, _HUFFSYMB8> {
        using HuffSymb_RAM = Field<_HUFFSYMB8, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB9 : Register<JPEG_BASE + 0x234, ReadWrite, _HUFFSYMB9> {
        using HuffSymb_RAM = Field<_HUFFSYMB9, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB10 : Register<JPEG_BASE + 0x238, ReadWrite, _HUFFSYMB10> {
        using HuffSymb_RAM = Field<_HUFFSYMB10, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB11 : Register<JPEG_BASE + 0x23C, ReadWrite, _HUFFSYMB11> {
        using HuffSymb_RAM = Field<_HUFFSYMB11, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB12 : Register<JPEG_BASE + 0x240, ReadWrite, _HUFFSYMB12> {
        using HuffSymb_RAM = Field<_HUFFSYMB12, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB13 : Register<JPEG_BASE + 0x244, ReadWrite, _HUFFSYMB13> {
        using HuffSymb_RAM = Field<_HUFFSYMB13, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB14 : Register<JPEG_BASE + 0x248, ReadWrite, _HUFFSYMB14> {
        using HuffSymb_RAM = Field<_HUFFSYMB14, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB15 : Register<JPEG_BASE + 0x24C, ReadWrite, _HUFFSYMB15> {
        using HuffSymb_RAM = Field<_HUFFSYMB15, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB16 : Register<JPEG_BASE + 0x250, ReadWrite, _HUFFSYMB16> {
        using HuffSymb_RAM = Field<_HUFFSYMB16, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB17 : Register<JPEG_BASE + 0x254, ReadWrite, _HUFFSYMB17> {
        using HuffSymb_RAM = Field<_HUFFSYMB17, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB18 : Register<JPEG_BASE + 0x258, ReadWrite, _HUFFSYMB18> {
        using HuffSymb_RAM = Field<_HUFFSYMB18, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB19 : Register<JPEG_BASE + 0x25C, ReadWrite, _HUFFSYMB19> {
        using HuffSymb_RAM = Field<_HUFFSYMB19, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB20 : Register<JPEG_BASE + 0x260, ReadWrite, _HUFFSYMB20> {
        using HuffSymb_RAM = Field<_HUFFSYMB20, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB21 : Register<JPEG_BASE + 0x264, ReadWrite, _HUFFSYMB21> {
        using HuffSymb_RAM = Field<_HUFFSYMB21, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB22 : Register<JPEG_BASE + 0x268, ReadWrite, _HUFFSYMB22> {
        using HuffSymb_RAM = Field<_HUFFSYMB22, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB23 : Register<JPEG_BASE + 0x26C, ReadWrite, _HUFFSYMB23> {
        using HuffSymb_RAM = Field<_HUFFSYMB23, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB24 : Register<JPEG_BASE + 0x270, ReadWrite, _HUFFSYMB24> {
        using HuffSymb_RAM = Field<_HUFFSYMB24, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB25 : Register<JPEG_BASE + 0x274, ReadWrite, _HUFFSYMB25> {
        using HuffSymb_RAM = Field<_HUFFSYMB25, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB26 : Register<JPEG_BASE + 0x278, ReadWrite, _HUFFSYMB26> {
        using HuffSymb_RAM = Field<_HUFFSYMB26, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB27 : Register<JPEG_BASE + 0x27C, ReadWrite, _HUFFSYMB27> {
        using HuffSymb_RAM = Field<_HUFFSYMB27, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB28 : Register<JPEG_BASE + 0x280, ReadWrite, _HUFFSYMB28> {
        using HuffSymb_RAM = Field<_HUFFSYMB28, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB29 : Register<JPEG_BASE + 0x284, ReadWrite, _HUFFSYMB29> {
        using HuffSymb_RAM = Field<_HUFFSYMB29, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB30 : Register<JPEG_BASE + 0x288, ReadWrite, _HUFFSYMB30> {
        using HuffSymb_RAM = Field<_HUFFSYMB30, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB31 : Register<JPEG_BASE + 0x28C, ReadWrite, _HUFFSYMB31> {
        using HuffSymb_RAM = Field<_HUFFSYMB31, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB32 : Register<JPEG_BASE + 0x290, ReadWrite, _HUFFSYMB32> {
        using HuffSymb_RAM = Field<_HUFFSYMB32, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB33 : Register<JPEG_BASE + 0x294, ReadWrite, _HUFFSYMB33> {
        using HuffSymb_RAM = Field<_HUFFSYMB33, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB34 : Register<JPEG_BASE + 0x298, ReadWrite, _HUFFSYMB34> {
        using HuffSymb_RAM = Field<_HUFFSYMB34, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB35 : Register<JPEG_BASE + 0x29C, ReadWrite, _HUFFSYMB35> {
        using HuffSymb_RAM = Field<_HUFFSYMB35, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB36 : Register<JPEG_BASE + 0x2A0, ReadWrite, _HUFFSYMB36> {
        using HuffSymb_RAM = Field<_HUFFSYMB36, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB37 : Register<JPEG_BASE + 0x2A4, ReadWrite, _HUFFSYMB37> {
        using HuffSymb_RAM = Field<_HUFFSYMB37, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB38 : Register<JPEG_BASE + 0x2A8, ReadWrite, _HUFFSYMB38> {
        using HuffSymb_RAM = Field<_HUFFSYMB38, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB39 : Register<JPEG_BASE + 0x2AC, ReadWrite, _HUFFSYMB39> {
        using HuffSymb_RAM = Field<_HUFFSYMB39, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB40 : Register<JPEG_BASE + 0x2B0, ReadWrite, _HUFFSYMB40> {
        using HuffSymb_RAM = Field<_HUFFSYMB40, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB41 : Register<JPEG_BASE + 0x2B4, ReadWrite, _HUFFSYMB41> {
        using HuffSymb_RAM = Field<_HUFFSYMB41, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB42 : Register<JPEG_BASE + 0x2B8, ReadWrite, _HUFFSYMB42> {
        using HuffSymb_RAM = Field<_HUFFSYMB42, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB43 : Register<JPEG_BASE + 0x2BC, ReadWrite, _HUFFSYMB43> {
        using HuffSymb_RAM = Field<_HUFFSYMB43, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB44 : Register<JPEG_BASE + 0x2C0, ReadWrite, _HUFFSYMB44> {
        using HuffSymb_RAM = Field<_HUFFSYMB44, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB45 : Register<JPEG_BASE + 0x2C4, ReadWrite, _HUFFSYMB45> {
        using HuffSymb_RAM = Field<_HUFFSYMB45, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB46 : Register<JPEG_BASE + 0x2C8, ReadWrite, _HUFFSYMB46> {
        using HuffSymb_RAM = Field<_HUFFSYMB46, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB47 : Register<JPEG_BASE + 0x2CC, ReadWrite, _HUFFSYMB47> {
        using HuffSymb_RAM = Field<_HUFFSYMB47, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB48 : Register<JPEG_BASE + 0x2D0, ReadWrite, _HUFFSYMB48> {
        using HuffSymb_RAM = Field<_HUFFSYMB48, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB49 : Register<JPEG_BASE + 0x2D4, ReadWrite, _HUFFSYMB49> {
        using HuffSymb_RAM = Field<_HUFFSYMB49, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB50 : Register<JPEG_BASE + 0x2D8, ReadWrite, _HUFFSYMB50> {
        using HuffSymb_RAM = Field<_HUFFSYMB50, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB51 : Register<JPEG_BASE + 0x2DC, ReadWrite, _HUFFSYMB51> {
        using HuffSymb_RAM = Field<_HUFFSYMB51, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB52 : Register<JPEG_BASE + 0x2E0, ReadWrite, _HUFFSYMB52> {
        using HuffSymb_RAM = Field<_HUFFSYMB52, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB53 : Register<JPEG_BASE + 0x2E4, ReadWrite, _HUFFSYMB53> {
        using HuffSymb_RAM = Field<_HUFFSYMB53, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB54 : Register<JPEG_BASE + 0x2E8, ReadWrite, _HUFFSYMB54> {
        using HuffSymb_RAM = Field<_HUFFSYMB54, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB55 : Register<JPEG_BASE + 0x2EC, ReadWrite, _HUFFSYMB55> {
        using HuffSymb_RAM = Field<_HUFFSYMB55, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB56 : Register<JPEG_BASE + 0x2F0, ReadWrite, _HUFFSYMB56> {
        using HuffSymb_RAM = Field<_HUFFSYMB56, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB57 : Register<JPEG_BASE + 0x2F4, ReadWrite, _HUFFSYMB57> {
        using HuffSymb_RAM = Field<_HUFFSYMB57, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB58 : Register<JPEG_BASE + 0x2F8, ReadWrite, _HUFFSYMB58> {
        using HuffSymb_RAM = Field<_HUFFSYMB58, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB59 : Register<JPEG_BASE + 0x2FC, ReadWrite, _HUFFSYMB59> {
        using HuffSymb_RAM = Field<_HUFFSYMB59, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB60 : Register<JPEG_BASE + 0x300, ReadWrite, _HUFFSYMB60> {
        using HuffSymb_RAM = Field<_HUFFSYMB60, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB61 : Register<JPEG_BASE + 0x304, ReadWrite, _HUFFSYMB61> {
        using HuffSymb_RAM = Field<_HUFFSYMB61, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB62 : Register<JPEG_BASE + 0x308, ReadWrite, _HUFFSYMB62> {
        using HuffSymb_RAM = Field<_HUFFSYMB62, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB63 : Register<JPEG_BASE + 0x30C, ReadWrite, _HUFFSYMB63> {
        using HuffSymb_RAM = Field<_HUFFSYMB63, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB64 : Register<JPEG_BASE + 0x310, ReadWrite, _HUFFSYMB64> {
        using HuffSymb_RAM = Field<_HUFFSYMB64, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB65 : Register<JPEG_BASE + 0x314, ReadWrite, _HUFFSYMB65> {
        using HuffSymb_RAM = Field<_HUFFSYMB65, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB66 : Register<JPEG_BASE + 0x318, ReadWrite, _HUFFSYMB66> {
        using HuffSymb_RAM = Field<_HUFFSYMB66, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB67 : Register<JPEG_BASE + 0x31C, ReadWrite, _HUFFSYMB67> {
        using HuffSymb_RAM = Field<_HUFFSYMB67, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB68 : Register<JPEG_BASE + 0x320, ReadWrite, _HUFFSYMB68> {
        using HuffSymb_RAM = Field<_HUFFSYMB68, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB69 : Register<JPEG_BASE + 0x324, ReadWrite, _HUFFSYMB69> {
        using HuffSymb_RAM = Field<_HUFFSYMB69, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB70 : Register<JPEG_BASE + 0x328, ReadWrite, _HUFFSYMB70> {
        using HuffSymb_RAM = Field<_HUFFSYMB70, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB71 : Register<JPEG_BASE + 0x32C, ReadWrite, _HUFFSYMB71> {
        using HuffSymb_RAM = Field<_HUFFSYMB71, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB72 : Register<JPEG_BASE + 0x330, ReadWrite, _HUFFSYMB72> {
        using HuffSymb_RAM = Field<_HUFFSYMB72, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB73 : Register<JPEG_BASE + 0x334, ReadWrite, _HUFFSYMB73> {
        using HuffSymb_RAM = Field<_HUFFSYMB73, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB74 : Register<JPEG_BASE + 0x338, ReadWrite, _HUFFSYMB74> {
        using HuffSymb_RAM = Field<_HUFFSYMB74, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB75 : Register<JPEG_BASE + 0x33C, ReadWrite, _HUFFSYMB75> {
        using HuffSymb_RAM = Field<_HUFFSYMB75, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB76 : Register<JPEG_BASE + 0x340, ReadWrite, _HUFFSYMB76> {
        using HuffSymb_RAM = Field<_HUFFSYMB76, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB77 : Register<JPEG_BASE + 0x344, ReadWrite, _HUFFSYMB77> {
        using HuffSymb_RAM = Field<_HUFFSYMB77, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB78 : Register<JPEG_BASE + 0x348, ReadWrite, _HUFFSYMB78> {
        using HuffSymb_RAM = Field<_HUFFSYMB78, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB79 : Register<JPEG_BASE + 0x34C, ReadWrite, _HUFFSYMB79> {
        using HuffSymb_RAM = Field<_HUFFSYMB79, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB80 : Register<JPEG_BASE + 0x350, ReadWrite, _HUFFSYMB80> {
        using HuffSymb_RAM = Field<_HUFFSYMB80, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB81 : Register<JPEG_BASE + 0x354, ReadWrite, _HUFFSYMB81> {
        using HuffSymb_RAM = Field<_HUFFSYMB81, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB82 : Register<JPEG_BASE + 0x358, ReadWrite, _HUFFSYMB82> {
        using HuffSymb_RAM = Field<_HUFFSYMB82, 0, 32>; // DHTSymb RAM
    };

    // JPEG HUFFSYMB tables
    struct _HUFFSYMB83 : Register<JPEG_BASE + 0x35C, ReadWrite, _HUFFSYMB83> {
        using HuffSymb_RAM = Field<_HUFFSYMB83, 0, 32>; // DHTSymb RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM0 : Register<JPEG_BASE + 0x360, ReadWrite, _DHTMEM0> {
        using DHTMem_RAM = Field<_DHTMEM0, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM2 : Register<JPEG_BASE + 0x364, ReadWrite, _DHTMEM2> {
        using DHTMem_RAM = Field<_DHTMEM2, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM3 : Register<JPEG_BASE + 0x368, ReadWrite, _DHTMEM3> {
        using DHTMem_RAM = Field<_DHTMEM3, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM4 : Register<JPEG_BASE + 0x36C, ReadWrite, _DHTMEM4> {
        using DHTMem_RAM = Field<_DHTMEM4, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM5 : Register<JPEG_BASE + 0x370, ReadWrite, _DHTMEM5> {
        using DHTMem_RAM = Field<_DHTMEM5, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM6 : Register<JPEG_BASE + 0x374, ReadWrite, _DHTMEM6> {
        using DHTMem_RAM = Field<_DHTMEM6, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM7 : Register<JPEG_BASE + 0x378, ReadWrite, _DHTMEM7> {
        using DHTMem_RAM = Field<_DHTMEM7, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM8 : Register<JPEG_BASE + 0x37C, ReadWrite, _DHTMEM8> {
        using DHTMem_RAM = Field<_DHTMEM8, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM9 : Register<JPEG_BASE + 0x380, ReadWrite, _DHTMEM9> {
        using DHTMem_RAM = Field<_DHTMEM9, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM10 : Register<JPEG_BASE + 0x384, ReadWrite, _DHTMEM10> {
        using DHTMem_RAM = Field<_DHTMEM10, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM11 : Register<JPEG_BASE + 0x388, ReadWrite, _DHTMEM11> {
        using DHTMem_RAM = Field<_DHTMEM11, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM12 : Register<JPEG_BASE + 0x38C, ReadWrite, _DHTMEM12> {
        using DHTMem_RAM = Field<_DHTMEM12, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM13 : Register<JPEG_BASE + 0x390, ReadWrite, _DHTMEM13> {
        using DHTMem_RAM = Field<_DHTMEM13, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM14 : Register<JPEG_BASE + 0x394, ReadWrite, _DHTMEM14> {
        using DHTMem_RAM = Field<_DHTMEM14, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM15 : Register<JPEG_BASE + 0x398, ReadWrite, _DHTMEM15> {
        using DHTMem_RAM = Field<_DHTMEM15, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM16 : Register<JPEG_BASE + 0x39C, ReadWrite, _DHTMEM16> {
        using DHTMem_RAM = Field<_DHTMEM16, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM17 : Register<JPEG_BASE + 0x3A0, ReadWrite, _DHTMEM17> {
        using DHTMem_RAM = Field<_DHTMEM17, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM18 : Register<JPEG_BASE + 0x3A4, ReadWrite, _DHTMEM18> {
        using DHTMem_RAM = Field<_DHTMEM18, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM19 : Register<JPEG_BASE + 0x3A8, ReadWrite, _DHTMEM19> {
        using DHTMem_RAM = Field<_DHTMEM19, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM20 : Register<JPEG_BASE + 0x3AC, ReadWrite, _DHTMEM20> {
        using DHTMem_RAM = Field<_DHTMEM20, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM21 : Register<JPEG_BASE + 0x3B0, ReadWrite, _DHTMEM21> {
        using DHTMem_RAM = Field<_DHTMEM21, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM22 : Register<JPEG_BASE + 0x3B4, ReadWrite, _DHTMEM22> {
        using DHTMem_RAM = Field<_DHTMEM22, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM23 : Register<JPEG_BASE + 0x3B8, ReadWrite, _DHTMEM23> {
        using DHTMem_RAM = Field<_DHTMEM23, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM24 : Register<JPEG_BASE + 0x3BC, ReadWrite, _DHTMEM24> {
        using DHTMem_RAM = Field<_DHTMEM24, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM25 : Register<JPEG_BASE + 0x3C0, ReadWrite, _DHTMEM25> {
        using DHTMem_RAM = Field<_DHTMEM25, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM26 : Register<JPEG_BASE + 0x3C4, ReadWrite, _DHTMEM26> {
        using DHTMem_RAM = Field<_DHTMEM26, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM27 : Register<JPEG_BASE + 0x3C8, ReadWrite, _DHTMEM27> {
        using DHTMem_RAM = Field<_DHTMEM27, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM28 : Register<JPEG_BASE + 0x3CC, ReadWrite, _DHTMEM28> {
        using DHTMem_RAM = Field<_DHTMEM28, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM29 : Register<JPEG_BASE + 0x3D0, ReadWrite, _DHTMEM29> {
        using DHTMem_RAM = Field<_DHTMEM29, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM30 : Register<JPEG_BASE + 0x3D4, ReadWrite, _DHTMEM30> {
        using DHTMem_RAM = Field<_DHTMEM30, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM31 : Register<JPEG_BASE + 0x3D8, ReadWrite, _DHTMEM31> {
        using DHTMem_RAM = Field<_DHTMEM31, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM32 : Register<JPEG_BASE + 0x3DC, ReadWrite, _DHTMEM32> {
        using DHTMem_RAM = Field<_DHTMEM32, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM33 : Register<JPEG_BASE + 0x3E0, ReadWrite, _DHTMEM33> {
        using DHTMem_RAM = Field<_DHTMEM33, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM34 : Register<JPEG_BASE + 0x3E4, ReadWrite, _DHTMEM34> {
        using DHTMem_RAM = Field<_DHTMEM34, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM35 : Register<JPEG_BASE + 0x3E8, ReadWrite, _DHTMEM35> {
        using DHTMem_RAM = Field<_DHTMEM35, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM36 : Register<JPEG_BASE + 0x3EC, ReadWrite, _DHTMEM36> {
        using DHTMem_RAM = Field<_DHTMEM36, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM37 : Register<JPEG_BASE + 0x3F0, ReadWrite, _DHTMEM37> {
        using DHTMem_RAM = Field<_DHTMEM37, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM38 : Register<JPEG_BASE + 0x3F4, ReadWrite, _DHTMEM38> {
        using DHTMem_RAM = Field<_DHTMEM38, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM39 : Register<JPEG_BASE + 0x3F8, ReadWrite, _DHTMEM39> {
        using DHTMem_RAM = Field<_DHTMEM39, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM40 : Register<JPEG_BASE + 0x3FC, ReadWrite, _DHTMEM40> {
        using DHTMem_RAM = Field<_DHTMEM40, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM41 : Register<JPEG_BASE + 0x400, ReadWrite, _DHTMEM41> {
        using DHTMem_RAM = Field<_DHTMEM41, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM42 : Register<JPEG_BASE + 0x404, ReadWrite, _DHTMEM42> {
        using DHTMem_RAM = Field<_DHTMEM42, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM43 : Register<JPEG_BASE + 0x408, ReadWrite, _DHTMEM43> {
        using DHTMem_RAM = Field<_DHTMEM43, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM44 : Register<JPEG_BASE + 0x40C, ReadWrite, _DHTMEM44> {
        using DHTMem_RAM = Field<_DHTMEM44, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM45 : Register<JPEG_BASE + 0x410, ReadWrite, _DHTMEM45> {
        using DHTMem_RAM = Field<_DHTMEM45, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM46 : Register<JPEG_BASE + 0x414, ReadWrite, _DHTMEM46> {
        using DHTMem_RAM = Field<_DHTMEM46, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM47 : Register<JPEG_BASE + 0x418, ReadWrite, _DHTMEM47> {
        using DHTMem_RAM = Field<_DHTMEM47, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM48 : Register<JPEG_BASE + 0x41C, ReadWrite, _DHTMEM48> {
        using DHTMem_RAM = Field<_DHTMEM48, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM49 : Register<JPEG_BASE + 0x420, ReadWrite, _DHTMEM49> {
        using DHTMem_RAM = Field<_DHTMEM49, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM50 : Register<JPEG_BASE + 0x424, ReadWrite, _DHTMEM50> {
        using DHTMem_RAM = Field<_DHTMEM50, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM51 : Register<JPEG_BASE + 0x428, ReadWrite, _DHTMEM51> {
        using DHTMem_RAM = Field<_DHTMEM51, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM52 : Register<JPEG_BASE + 0x42C, ReadWrite, _DHTMEM52> {
        using DHTMem_RAM = Field<_DHTMEM52, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM53 : Register<JPEG_BASE + 0x430, ReadWrite, _DHTMEM53> {
        using DHTMem_RAM = Field<_DHTMEM53, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM54 : Register<JPEG_BASE + 0x434, ReadWrite, _DHTMEM54> {
        using DHTMem_RAM = Field<_DHTMEM54, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM55 : Register<JPEG_BASE + 0x438, ReadWrite, _DHTMEM55> {
        using DHTMem_RAM = Field<_DHTMEM55, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM56 : Register<JPEG_BASE + 0x43C, ReadWrite, _DHTMEM56> {
        using DHTMem_RAM = Field<_DHTMEM56, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM57 : Register<JPEG_BASE + 0x440, ReadWrite, _DHTMEM57> {
        using DHTMem_RAM = Field<_DHTMEM57, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM58 : Register<JPEG_BASE + 0x444, ReadWrite, _DHTMEM58> {
        using DHTMem_RAM = Field<_DHTMEM58, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM59 : Register<JPEG_BASE + 0x448, ReadWrite, _DHTMEM59> {
        using DHTMem_RAM = Field<_DHTMEM59, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM60 : Register<JPEG_BASE + 0x44C, ReadWrite, _DHTMEM60> {
        using DHTMem_RAM = Field<_DHTMEM60, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM61 : Register<JPEG_BASE + 0x450, ReadWrite, _DHTMEM61> {
        using DHTMem_RAM = Field<_DHTMEM61, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM62 : Register<JPEG_BASE + 0x454, ReadWrite, _DHTMEM62> {
        using DHTMem_RAM = Field<_DHTMEM62, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM63 : Register<JPEG_BASE + 0x458, ReadWrite, _DHTMEM63> {
        using DHTMem_RAM = Field<_DHTMEM63, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM64 : Register<JPEG_BASE + 0x45C, ReadWrite, _DHTMEM64> {
        using DHTMem_RAM = Field<_DHTMEM64, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM65 : Register<JPEG_BASE + 0x460, ReadWrite, _DHTMEM65> {
        using DHTMem_RAM = Field<_DHTMEM65, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM66 : Register<JPEG_BASE + 0x464, ReadWrite, _DHTMEM66> {
        using DHTMem_RAM = Field<_DHTMEM66, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM67 : Register<JPEG_BASE + 0x468, ReadWrite, _DHTMEM67> {
        using DHTMem_RAM = Field<_DHTMEM67, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM68 : Register<JPEG_BASE + 0x46C, ReadWrite, _DHTMEM68> {
        using DHTMem_RAM = Field<_DHTMEM68, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM69 : Register<JPEG_BASE + 0x470, ReadWrite, _DHTMEM69> {
        using DHTMem_RAM = Field<_DHTMEM69, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM70 : Register<JPEG_BASE + 0x474, ReadWrite, _DHTMEM70> {
        using DHTMem_RAM = Field<_DHTMEM70, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM71 : Register<JPEG_BASE + 0x478, ReadWrite, _DHTMEM71> {
        using DHTMem_RAM = Field<_DHTMEM71, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM72 : Register<JPEG_BASE + 0x47C, ReadWrite, _DHTMEM72> {
        using DHTMem_RAM = Field<_DHTMEM72, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM73 : Register<JPEG_BASE + 0x480, ReadWrite, _DHTMEM73> {
        using DHTMem_RAM = Field<_DHTMEM73, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM74 : Register<JPEG_BASE + 0x484, ReadWrite, _DHTMEM74> {
        using DHTMem_RAM = Field<_DHTMEM74, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM75 : Register<JPEG_BASE + 0x488, ReadWrite, _DHTMEM75> {
        using DHTMem_RAM = Field<_DHTMEM75, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM76 : Register<JPEG_BASE + 0x48C, ReadWrite, _DHTMEM76> {
        using DHTMem_RAM = Field<_DHTMEM76, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM77 : Register<JPEG_BASE + 0x490, ReadWrite, _DHTMEM77> {
        using DHTMem_RAM = Field<_DHTMEM77, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM78 : Register<JPEG_BASE + 0x494, ReadWrite, _DHTMEM78> {
        using DHTMem_RAM = Field<_DHTMEM78, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM79 : Register<JPEG_BASE + 0x498, ReadWrite, _DHTMEM79> {
        using DHTMem_RAM = Field<_DHTMEM79, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM80 : Register<JPEG_BASE + 0x49C, ReadWrite, _DHTMEM80> {
        using DHTMem_RAM = Field<_DHTMEM80, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM81 : Register<JPEG_BASE + 0x4A0, ReadWrite, _DHTMEM81> {
        using DHTMem_RAM = Field<_DHTMEM81, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM82 : Register<JPEG_BASE + 0x4A4, ReadWrite, _DHTMEM82> {
        using DHTMem_RAM = Field<_DHTMEM82, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM83 : Register<JPEG_BASE + 0x4A8, ReadWrite, _DHTMEM83> {
        using DHTMem_RAM = Field<_DHTMEM83, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM84 : Register<JPEG_BASE + 0x4AC, ReadWrite, _DHTMEM84> {
        using DHTMem_RAM = Field<_DHTMEM84, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM85 : Register<JPEG_BASE + 0x4B0, ReadWrite, _DHTMEM85> {
        using DHTMem_RAM = Field<_DHTMEM85, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM86 : Register<JPEG_BASE + 0x4B4, ReadWrite, _DHTMEM86> {
        using DHTMem_RAM = Field<_DHTMEM86, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM87 : Register<JPEG_BASE + 0x4B8, ReadWrite, _DHTMEM87> {
        using DHTMem_RAM = Field<_DHTMEM87, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM88 : Register<JPEG_BASE + 0x4BC, ReadWrite, _DHTMEM88> {
        using DHTMem_RAM = Field<_DHTMEM88, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM89 : Register<JPEG_BASE + 0x4C0, ReadWrite, _DHTMEM89> {
        using DHTMem_RAM = Field<_DHTMEM89, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM90 : Register<JPEG_BASE + 0x4C4, ReadWrite, _DHTMEM90> {
        using DHTMem_RAM = Field<_DHTMEM90, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM91 : Register<JPEG_BASE + 0x4C8, ReadWrite, _DHTMEM91> {
        using DHTMem_RAM = Field<_DHTMEM91, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM92 : Register<JPEG_BASE + 0x4CC, ReadWrite, _DHTMEM92> {
        using DHTMem_RAM = Field<_DHTMEM92, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM93 : Register<JPEG_BASE + 0x4D0, ReadWrite, _DHTMEM93> {
        using DHTMem_RAM = Field<_DHTMEM93, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM94 : Register<JPEG_BASE + 0x4D4, ReadWrite, _DHTMEM94> {
        using DHTMem_RAM = Field<_DHTMEM94, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM95 : Register<JPEG_BASE + 0x4D8, ReadWrite, _DHTMEM95> {
        using DHTMem_RAM = Field<_DHTMEM95, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM96 : Register<JPEG_BASE + 0x4DC, ReadWrite, _DHTMEM96> {
        using DHTMem_RAM = Field<_DHTMEM96, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM97 : Register<JPEG_BASE + 0x4E0, ReadWrite, _DHTMEM97> {
        using DHTMem_RAM = Field<_DHTMEM97, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM98 : Register<JPEG_BASE + 0x4E4, ReadWrite, _DHTMEM98> {
        using DHTMem_RAM = Field<_DHTMEM98, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM99 : Register<JPEG_BASE + 0x4E8, ReadWrite, _DHTMEM99> {
        using DHTMem_RAM = Field<_DHTMEM99, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM100 : Register<JPEG_BASE + 0x4EC, ReadWrite, _DHTMEM100> {
        using DHTMem_RAM = Field<_DHTMEM100, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM101 : Register<JPEG_BASE + 0x4F0, ReadWrite, _DHTMEM101> {
        using DHTMem_RAM = Field<_DHTMEM101, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM102 : Register<JPEG_BASE + 0x4F4, ReadWrite, _DHTMEM102> {
        using DHTMem_RAM = Field<_DHTMEM102, 0, 32>; // DHTMem RAM
    };

    // JPEG DHTMem tables
    struct _DHTMEM103 : Register<JPEG_BASE + 0x4F8, ReadWrite, _DHTMEM103> {
        using DHTMem_RAM = Field<_DHTMEM103, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_0 : Register<JPEG_BASE + 0x500, ReadWrite, _HUFFENC_AC0_0> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_0, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_1 : Register<JPEG_BASE + 0x504, ReadWrite, _HUFFENC_AC0_1> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_1, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_2 : Register<JPEG_BASE + 0x508, ReadWrite, _HUFFENC_AC0_2> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_2, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_3 : Register<JPEG_BASE + 0x50C, ReadWrite, _HUFFENC_AC0_3> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_3, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_4 : Register<JPEG_BASE + 0x510, ReadWrite, _HUFFENC_AC0_4> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_4, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_5 : Register<JPEG_BASE + 0x514, ReadWrite, _HUFFENC_AC0_5> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_5, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_6 : Register<JPEG_BASE + 0x518, ReadWrite, _HUFFENC_AC0_6> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_6, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_7 : Register<JPEG_BASE + 0x51C, ReadWrite, _HUFFENC_AC0_7> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_7, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_8 : Register<JPEG_BASE + 0x520, ReadWrite, _HUFFENC_AC0_8> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_8, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_9 : Register<JPEG_BASE + 0x524, ReadWrite, _HUFFENC_AC0_9> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_9, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_10 : Register<JPEG_BASE + 0x528, ReadWrite, _HUFFENC_AC0_10> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_10, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_11 : Register<JPEG_BASE + 0x52C, ReadWrite, _HUFFENC_AC0_11> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_11, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_12 : Register<JPEG_BASE + 0x530, ReadWrite, _HUFFENC_AC0_12> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_12, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_13 : Register<JPEG_BASE + 0x534, ReadWrite, _HUFFENC_AC0_13> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_13, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_14 : Register<JPEG_BASE + 0x538, ReadWrite, _HUFFENC_AC0_14> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_14, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_15 : Register<JPEG_BASE + 0x53C, ReadWrite, _HUFFENC_AC0_15> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_15, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_16 : Register<JPEG_BASE + 0x540, ReadWrite, _HUFFENC_AC0_16> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_16, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_17 : Register<JPEG_BASE + 0x544, ReadWrite, _HUFFENC_AC0_17> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_17, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_18 : Register<JPEG_BASE + 0x548, ReadWrite, _HUFFENC_AC0_18> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_18, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_19 : Register<JPEG_BASE + 0x54C, ReadWrite, _HUFFENC_AC0_19> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_19, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_20 : Register<JPEG_BASE + 0x550, ReadWrite, _HUFFENC_AC0_20> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_20, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_21 : Register<JPEG_BASE + 0x554, ReadWrite, _HUFFENC_AC0_21> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_21, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_22 : Register<JPEG_BASE + 0x558, ReadWrite, _HUFFENC_AC0_22> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_22, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_23 : Register<JPEG_BASE + 0x55C, ReadWrite, _HUFFENC_AC0_23> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_23, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_24 : Register<JPEG_BASE + 0x560, ReadWrite, _HUFFENC_AC0_24> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_24, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_25 : Register<JPEG_BASE + 0x564, ReadWrite, _HUFFENC_AC0_25> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_25, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_26 : Register<JPEG_BASE + 0x568, ReadWrite, _HUFFENC_AC0_26> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_26, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_27 : Register<JPEG_BASE + 0x56C, ReadWrite, _HUFFENC_AC0_27> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_27, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_28 : Register<JPEG_BASE + 0x570, ReadWrite, _HUFFENC_AC0_28> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_28, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_29 : Register<JPEG_BASE + 0x574, ReadWrite, _HUFFENC_AC0_29> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_29, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_30 : Register<JPEG_BASE + 0x578, ReadWrite, _HUFFENC_AC0_30> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_30, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_31 : Register<JPEG_BASE + 0x57C, ReadWrite, _HUFFENC_AC0_31> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_31, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_32 : Register<JPEG_BASE + 0x580, ReadWrite, _HUFFENC_AC0_32> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_32, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_33 : Register<JPEG_BASE + 0x584, ReadWrite, _HUFFENC_AC0_33> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_33, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_34 : Register<JPEG_BASE + 0x588, ReadWrite, _HUFFENC_AC0_34> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_34, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_35 : Register<JPEG_BASE + 0x58C, ReadWrite, _HUFFENC_AC0_35> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_35, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_36 : Register<JPEG_BASE + 0x590, ReadWrite, _HUFFENC_AC0_36> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_36, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_37 : Register<JPEG_BASE + 0x594, ReadWrite, _HUFFENC_AC0_37> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_37, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_38 : Register<JPEG_BASE + 0x598, ReadWrite, _HUFFENC_AC0_38> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_38, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_39 : Register<JPEG_BASE + 0x59C, ReadWrite, _HUFFENC_AC0_39> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_39, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_40 : Register<JPEG_BASE + 0x5A0, ReadWrite, _HUFFENC_AC0_40> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_40, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_41 : Register<JPEG_BASE + 0x5A4, ReadWrite, _HUFFENC_AC0_41> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_41, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_42 : Register<JPEG_BASE + 0x5A8, ReadWrite, _HUFFENC_AC0_42> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_42, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_43 : Register<JPEG_BASE + 0x5AC, ReadWrite, _HUFFENC_AC0_43> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_43, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_44 : Register<JPEG_BASE + 0x5B0, ReadWrite, _HUFFENC_AC0_44> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_44, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_45 : Register<JPEG_BASE + 0x5B4, ReadWrite, _HUFFENC_AC0_45> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_45, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_46 : Register<JPEG_BASE + 0x5B8, ReadWrite, _HUFFENC_AC0_46> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_46, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_47 : Register<JPEG_BASE + 0x5BC, ReadWrite, _HUFFENC_AC0_47> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_47, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_48 : Register<JPEG_BASE + 0x5C0, ReadWrite, _HUFFENC_AC0_48> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_48, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_49 : Register<JPEG_BASE + 0x5C4, ReadWrite, _HUFFENC_AC0_49> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_49, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_50 : Register<JPEG_BASE + 0x5C8, ReadWrite, _HUFFENC_AC0_50> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_50, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_51 : Register<JPEG_BASE + 0x5CC, ReadWrite, _HUFFENC_AC0_51> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_51, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_52 : Register<JPEG_BASE + 0x5D0, ReadWrite, _HUFFENC_AC0_52> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_52, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_53 : Register<JPEG_BASE + 0x5D4, ReadWrite, _HUFFENC_AC0_53> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_53, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_54 : Register<JPEG_BASE + 0x5D8, ReadWrite, _HUFFENC_AC0_54> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_54, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_55 : Register<JPEG_BASE + 0x5DC, ReadWrite, _HUFFENC_AC0_55> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_55, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_56 : Register<JPEG_BASE + 0x5E0, ReadWrite, _HUFFENC_AC0_56> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_56, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_57 : Register<JPEG_BASE + 0x5E4, ReadWrite, _HUFFENC_AC0_57> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_57, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_58 : Register<JPEG_BASE + 0x5E8, ReadWrite, _HUFFENC_AC0_58> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_58, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_59 : Register<JPEG_BASE + 0x5EC, ReadWrite, _HUFFENC_AC0_59> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_59, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_60 : Register<JPEG_BASE + 0x5F0, ReadWrite, _HUFFENC_AC0_60> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_60, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_61 : Register<JPEG_BASE + 0x5F4, ReadWrite, _HUFFENC_AC0_61> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_61, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_62 : Register<JPEG_BASE + 0x5F8, ReadWrite, _HUFFENC_AC0_62> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_62, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_63 : Register<JPEG_BASE + 0x5FC, ReadWrite, _HUFFENC_AC0_63> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_63, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_64 : Register<JPEG_BASE + 0x600, ReadWrite, _HUFFENC_AC0_64> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_64, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_65 : Register<JPEG_BASE + 0x604, ReadWrite, _HUFFENC_AC0_65> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_65, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_66 : Register<JPEG_BASE + 0x608, ReadWrite, _HUFFENC_AC0_66> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_66, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_67 : Register<JPEG_BASE + 0x60C, ReadWrite, _HUFFENC_AC0_67> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_67, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_68 : Register<JPEG_BASE + 0x610, ReadWrite, _HUFFENC_AC0_68> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_68, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_69 : Register<JPEG_BASE + 0x614, ReadWrite, _HUFFENC_AC0_69> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_69, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_70 : Register<JPEG_BASE + 0x618, ReadWrite, _HUFFENC_AC0_70> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_70, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_71 : Register<JPEG_BASE + 0x61C, ReadWrite, _HUFFENC_AC0_71> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_71, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_72 : Register<JPEG_BASE + 0x620, ReadWrite, _HUFFENC_AC0_72> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_72, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_73 : Register<JPEG_BASE + 0x624, ReadWrite, _HUFFENC_AC0_73> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_73, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_74 : Register<JPEG_BASE + 0x628, ReadWrite, _HUFFENC_AC0_74> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_74, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_75 : Register<JPEG_BASE + 0x62C, ReadWrite, _HUFFENC_AC0_75> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_75, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_76 : Register<JPEG_BASE + 0x630, ReadWrite, _HUFFENC_AC0_76> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_76, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_77 : Register<JPEG_BASE + 0x634, ReadWrite, _HUFFENC_AC0_77> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_77, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_78 : Register<JPEG_BASE + 0x638, ReadWrite, _HUFFENC_AC0_78> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_78, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_79 : Register<JPEG_BASE + 0x63C, ReadWrite, _HUFFENC_AC0_79> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_79, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_80 : Register<JPEG_BASE + 0x640, ReadWrite, _HUFFENC_AC0_80> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_80, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_81 : Register<JPEG_BASE + 0x644, ReadWrite, _HUFFENC_AC0_81> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_81, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_82 : Register<JPEG_BASE + 0x648, ReadWrite, _HUFFENC_AC0_82> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_82, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_83 : Register<JPEG_BASE + 0x64C, ReadWrite, _HUFFENC_AC0_83> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_83, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_84 : Register<JPEG_BASE + 0x650, ReadWrite, _HUFFENC_AC0_84> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_84, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_85 : Register<JPEG_BASE + 0x654, ReadWrite, _HUFFENC_AC0_85> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_85, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_86 : Register<JPEG_BASE + 0x658, ReadWrite, _HUFFENC_AC0_86> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_86, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 0
    struct _HUFFENC_AC0_87 : Register<JPEG_BASE + 0x65C, ReadWrite, _HUFFENC_AC0_87> {
        using DHTMem_RAM = Field<_HUFFENC_AC0_87, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_0 : Register<JPEG_BASE + 0x660, ReadWrite, _HUFFENC_AC1_0> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_0, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_1 : Register<JPEG_BASE + 0x664, ReadWrite, _HUFFENC_AC1_1> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_1, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_2 : Register<JPEG_BASE + 0x668, ReadWrite, _HUFFENC_AC1_2> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_2, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_3 : Register<JPEG_BASE + 0x66C, ReadWrite, _HUFFENC_AC1_3> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_3, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_4 : Register<JPEG_BASE + 0x670, ReadWrite, _HUFFENC_AC1_4> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_4, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_5 : Register<JPEG_BASE + 0x674, ReadWrite, _HUFFENC_AC1_5> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_5, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_6 : Register<JPEG_BASE + 0x678, ReadWrite, _HUFFENC_AC1_6> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_6, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_7 : Register<JPEG_BASE + 0x67C, ReadWrite, _HUFFENC_AC1_7> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_7, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_8 : Register<JPEG_BASE + 0x680, ReadWrite, _HUFFENC_AC1_8> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_8, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_9 : Register<JPEG_BASE + 0x684, ReadWrite, _HUFFENC_AC1_9> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_9, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_10 : Register<JPEG_BASE + 0x688, ReadWrite, _HUFFENC_AC1_10> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_10, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_11 : Register<JPEG_BASE + 0x68C, ReadWrite, _HUFFENC_AC1_11> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_11, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_12 : Register<JPEG_BASE + 0x690, ReadWrite, _HUFFENC_AC1_12> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_12, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_13 : Register<JPEG_BASE + 0x694, ReadWrite, _HUFFENC_AC1_13> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_13, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_14 : Register<JPEG_BASE + 0x698, ReadWrite, _HUFFENC_AC1_14> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_14, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_15 : Register<JPEG_BASE + 0x69C, ReadWrite, _HUFFENC_AC1_15> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_15, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_16 : Register<JPEG_BASE + 0x6A0, ReadWrite, _HUFFENC_AC1_16> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_16, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_17 : Register<JPEG_BASE + 0x6A4, ReadWrite, _HUFFENC_AC1_17> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_17, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_18 : Register<JPEG_BASE + 0x6A8, ReadWrite, _HUFFENC_AC1_18> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_18, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_19 : Register<JPEG_BASE + 0x6AC, ReadWrite, _HUFFENC_AC1_19> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_19, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_20 : Register<JPEG_BASE + 0x6B0, ReadWrite, _HUFFENC_AC1_20> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_20, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_21 : Register<JPEG_BASE + 0x6B4, ReadWrite, _HUFFENC_AC1_21> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_21, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_22 : Register<JPEG_BASE + 0x6B8, ReadWrite, _HUFFENC_AC1_22> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_22, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_23 : Register<JPEG_BASE + 0x6BC, ReadWrite, _HUFFENC_AC1_23> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_23, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_24 : Register<JPEG_BASE + 0x6C0, ReadWrite, _HUFFENC_AC1_24> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_24, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_25 : Register<JPEG_BASE + 0x6C4, ReadWrite, _HUFFENC_AC1_25> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_25, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_26 : Register<JPEG_BASE + 0x6C8, ReadWrite, _HUFFENC_AC1_26> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_26, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_27 : Register<JPEG_BASE + 0x6CC, ReadWrite, _HUFFENC_AC1_27> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_27, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_28 : Register<JPEG_BASE + 0x6D0, ReadWrite, _HUFFENC_AC1_28> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_28, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_29 : Register<JPEG_BASE + 0x6D4, ReadWrite, _HUFFENC_AC1_29> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_29, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_30 : Register<JPEG_BASE + 0x6D8, ReadWrite, _HUFFENC_AC1_30> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_30, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_31 : Register<JPEG_BASE + 0x6DC, ReadWrite, _HUFFENC_AC1_31> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_31, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_32 : Register<JPEG_BASE + 0x6E0, ReadWrite, _HUFFENC_AC1_32> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_32, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_33 : Register<JPEG_BASE + 0x6E4, ReadWrite, _HUFFENC_AC1_33> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_33, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_34 : Register<JPEG_BASE + 0x6E8, ReadWrite, _HUFFENC_AC1_34> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_34, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_35 : Register<JPEG_BASE + 0x6EC, ReadWrite, _HUFFENC_AC1_35> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_35, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_36 : Register<JPEG_BASE + 0x6F0, ReadWrite, _HUFFENC_AC1_36> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_36, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_37 : Register<JPEG_BASE + 0x6F4, ReadWrite, _HUFFENC_AC1_37> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_37, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_38 : Register<JPEG_BASE + 0x6F8, ReadWrite, _HUFFENC_AC1_38> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_38, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_39 : Register<JPEG_BASE + 0x6FC, ReadWrite, _HUFFENC_AC1_39> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_39, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_40 : Register<JPEG_BASE + 0x700, ReadWrite, _HUFFENC_AC1_40> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_40, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_41 : Register<JPEG_BASE + 0x704, ReadWrite, _HUFFENC_AC1_41> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_41, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_42 : Register<JPEG_BASE + 0x708, ReadWrite, _HUFFENC_AC1_42> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_42, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_43 : Register<JPEG_BASE + 0x70C, ReadWrite, _HUFFENC_AC1_43> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_43, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_44 : Register<JPEG_BASE + 0x710, ReadWrite, _HUFFENC_AC1_44> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_44, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_45 : Register<JPEG_BASE + 0x714, ReadWrite, _HUFFENC_AC1_45> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_45, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_46 : Register<JPEG_BASE + 0x718, ReadWrite, _HUFFENC_AC1_46> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_46, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_47 : Register<JPEG_BASE + 0x71C, ReadWrite, _HUFFENC_AC1_47> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_47, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_48 : Register<JPEG_BASE + 0x720, ReadWrite, _HUFFENC_AC1_48> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_48, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_49 : Register<JPEG_BASE + 0x724, ReadWrite, _HUFFENC_AC1_49> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_49, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_50 : Register<JPEG_BASE + 0x728, ReadWrite, _HUFFENC_AC1_50> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_50, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_51 : Register<JPEG_BASE + 0x72C, ReadWrite, _HUFFENC_AC1_51> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_51, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_52 : Register<JPEG_BASE + 0x730, ReadWrite, _HUFFENC_AC1_52> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_52, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_53 : Register<JPEG_BASE + 0x734, ReadWrite, _HUFFENC_AC1_53> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_53, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_54 : Register<JPEG_BASE + 0x738, ReadWrite, _HUFFENC_AC1_54> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_54, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_55 : Register<JPEG_BASE + 0x73C, ReadWrite, _HUFFENC_AC1_55> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_55, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_56 : Register<JPEG_BASE + 0x740, ReadWrite, _HUFFENC_AC1_56> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_56, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_57 : Register<JPEG_BASE + 0x744, ReadWrite, _HUFFENC_AC1_57> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_57, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_58 : Register<JPEG_BASE + 0x748, ReadWrite, _HUFFENC_AC1_58> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_58, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_59 : Register<JPEG_BASE + 0x74C, ReadWrite, _HUFFENC_AC1_59> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_59, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_60 : Register<JPEG_BASE + 0x750, ReadWrite, _HUFFENC_AC1_60> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_60, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_61 : Register<JPEG_BASE + 0x754, ReadWrite, _HUFFENC_AC1_61> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_61, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_62 : Register<JPEG_BASE + 0x758, ReadWrite, _HUFFENC_AC1_62> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_62, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_63 : Register<JPEG_BASE + 0x75C, ReadWrite, _HUFFENC_AC1_63> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_63, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_64 : Register<JPEG_BASE + 0x760, ReadWrite, _HUFFENC_AC1_64> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_64, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_65 : Register<JPEG_BASE + 0x764, ReadWrite, _HUFFENC_AC1_65> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_65, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_66 : Register<JPEG_BASE + 0x768, ReadWrite, _HUFFENC_AC1_66> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_66, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_67 : Register<JPEG_BASE + 0x76C, ReadWrite, _HUFFENC_AC1_67> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_67, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_68 : Register<JPEG_BASE + 0x770, ReadWrite, _HUFFENC_AC1_68> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_68, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_69 : Register<JPEG_BASE + 0x774, ReadWrite, _HUFFENC_AC1_69> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_69, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_70 : Register<JPEG_BASE + 0x778, ReadWrite, _HUFFENC_AC1_70> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_70, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_71 : Register<JPEG_BASE + 0x77C, ReadWrite, _HUFFENC_AC1_71> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_71, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_72 : Register<JPEG_BASE + 0x780, ReadWrite, _HUFFENC_AC1_72> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_72, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_73 : Register<JPEG_BASE + 0x784, ReadWrite, _HUFFENC_AC1_73> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_73, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_74 : Register<JPEG_BASE + 0x788, ReadWrite, _HUFFENC_AC1_74> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_74, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_75 : Register<JPEG_BASE + 0x78C, ReadWrite, _HUFFENC_AC1_75> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_75, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_76 : Register<JPEG_BASE + 0x790, ReadWrite, _HUFFENC_AC1_76> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_76, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_77 : Register<JPEG_BASE + 0x794, ReadWrite, _HUFFENC_AC1_77> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_77, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_78 : Register<JPEG_BASE + 0x798, ReadWrite, _HUFFENC_AC1_78> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_78, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_79 : Register<JPEG_BASE + 0x79C, ReadWrite, _HUFFENC_AC1_79> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_79, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_80 : Register<JPEG_BASE + 0x7A0, ReadWrite, _HUFFENC_AC1_80> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_80, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_81 : Register<JPEG_BASE + 0x7A4, ReadWrite, _HUFFENC_AC1_81> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_81, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_82 : Register<JPEG_BASE + 0x7A8, ReadWrite, _HUFFENC_AC1_82> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_82, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_83 : Register<JPEG_BASE + 0x7AC, ReadWrite, _HUFFENC_AC1_83> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_83, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_84 : Register<JPEG_BASE + 0x7B0, ReadWrite, _HUFFENC_AC1_84> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_84, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_85 : Register<JPEG_BASE + 0x7B4, ReadWrite, _HUFFENC_AC1_85> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_85, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_86 : Register<JPEG_BASE + 0x7B8, ReadWrite, _HUFFENC_AC1_86> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_86, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, AC Huffman table 1
    struct _HUFFENC_AC1_87 : Register<JPEG_BASE + 0x7BC, ReadWrite, _HUFFENC_AC1_87> {
        using DHTMem_RAM = Field<_HUFFENC_AC1_87, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 0
    struct _HUFFENC_DC0_0 : Register<JPEG_BASE + 0x7C0, ReadWrite, _HUFFENC_DC0_0> {
        using DHTMem_RAM = Field<_HUFFENC_DC0_0, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 0
    struct _HUFFENC_DC0_1 : Register<JPEG_BASE + 0x7C4, ReadWrite, _HUFFENC_DC0_1> {
        using DHTMem_RAM = Field<_HUFFENC_DC0_1, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 0
    struct _HUFFENC_DC0_2 : Register<JPEG_BASE + 0x7C8, ReadWrite, _HUFFENC_DC0_2> {
        using DHTMem_RAM = Field<_HUFFENC_DC0_2, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 0
    struct _HUFFENC_DC0_3 : Register<JPEG_BASE + 0x7CC, ReadWrite, _HUFFENC_DC0_3> {
        using DHTMem_RAM = Field<_HUFFENC_DC0_3, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 0
    struct _HUFFENC_DC0_4 : Register<JPEG_BASE + 0x7D0, ReadWrite, _HUFFENC_DC0_4> {
        using DHTMem_RAM = Field<_HUFFENC_DC0_4, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 0
    struct _HUFFENC_DC0_5 : Register<JPEG_BASE + 0x7D4, ReadWrite, _HUFFENC_DC0_5> {
        using DHTMem_RAM = Field<_HUFFENC_DC0_5, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 0
    struct _HUFFENC_DC0_6 : Register<JPEG_BASE + 0x7D8, ReadWrite, _HUFFENC_DC0_6> {
        using DHTMem_RAM = Field<_HUFFENC_DC0_6, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 0
    struct _HUFFENC_DC0_7 : Register<JPEG_BASE + 0x7DC, ReadWrite, _HUFFENC_DC0_7> {
        using DHTMem_RAM = Field<_HUFFENC_DC0_7, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 1
    struct _HUFFENC_DC1_0 : Register<JPEG_BASE + 0x7E0, ReadWrite, _HUFFENC_DC1_0> {
        using DHTMem_RAM = Field<_HUFFENC_DC1_0, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 1
    struct _HUFFENC_DC1_1 : Register<JPEG_BASE + 0x7E4, ReadWrite, _HUFFENC_DC1_1> {
        using DHTMem_RAM = Field<_HUFFENC_DC1_1, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 1
    struct _HUFFENC_DC1_2 : Register<JPEG_BASE + 0x7E8, ReadWrite, _HUFFENC_DC1_2> {
        using DHTMem_RAM = Field<_HUFFENC_DC1_2, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 1
    struct _HUFFENC_DC1_3 : Register<JPEG_BASE + 0x7EC, ReadWrite, _HUFFENC_DC1_3> {
        using DHTMem_RAM = Field<_HUFFENC_DC1_3, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 1
    struct _HUFFENC_DC1_4 : Register<JPEG_BASE + 0x7F0, ReadWrite, _HUFFENC_DC1_4> {
        using DHTMem_RAM = Field<_HUFFENC_DC1_4, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 1
    struct _HUFFENC_DC1_5 : Register<JPEG_BASE + 0x7F4, ReadWrite, _HUFFENC_DC1_5> {
        using DHTMem_RAM = Field<_HUFFENC_DC1_5, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 1
    struct _HUFFENC_DC1_6 : Register<JPEG_BASE + 0x7F8, ReadWrite, _HUFFENC_DC1_6> {
        using DHTMem_RAM = Field<_HUFFENC_DC1_6, 0, 32>; // DHTMem RAM
    };

    // JPEG encoder, DC Huffman table 1
    struct _HUFFENC_DC1_7 : Register<JPEG_BASE + 0x7FC, ReadWrite, _HUFFENC_DC1_7> {
        using DHTMem_RAM = Field<_HUFFENC_DC1_7, 0, 32>; // DHTMem RAM
    };

} // namespace JPEG

// --------------------------------------------
// Ethernet_MMC: Ethernet: MAC management counters
// Base address: 0x40028100
// --------------------------------------------

namespace Ethernet_MMC {
    static constexpr uint32_t Ethernet_MMC_BASE = 0x40028100;

    // Ethernet MMC control register
    struct _MMCCR : Register<Ethernet_MMC_BASE + 0x0, ReadWrite, _MMCCR> {
        using CR = Field<_MMCCR, 0, 1>; // CR
        using CSR = Field<_MMCCR, 1, 1>; // CSR
        using ROR = Field<_MMCCR, 2, 1>; // ROR
        using MCF = Field<_MMCCR, 3, 1>; // MCF
        using MCP = Field<_MMCCR, 4, 1>; // MCP
        using MCFHP = Field<_MMCCR, 5, 1>; // MCFHP
    };

    // Ethernet MMC receive interrupt register
    struct _MMCRIR : Register<Ethernet_MMC_BASE + 0x4, ReadWrite, _MMCRIR> {
        using RFCES = Field<_MMCRIR, 5, 1>; // RFCES
        using RFAES = Field<_MMCRIR, 6, 1>; // RFAES
        using RGUFS = Field<_MMCRIR, 17, 1>; // RGUFS
    };

    // Ethernet MMC transmit interrupt register
    struct _MMCTIR : Register<Ethernet_MMC_BASE + 0x8, ReadOnly, _MMCTIR> {
        using TGFSCS = Field<_MMCTIR, 14, 1>; // TGFSCS
        using TGFMSCS = Field<_MMCTIR, 15, 1>; // TGFMSCS
        using TGFS = Field<_MMCTIR, 21, 1>; // TGFS
    };

    // Ethernet MMC receive interrupt mask register
    struct _MMCRIMR : Register<Ethernet_MMC_BASE + 0xC, ReadWrite, _MMCRIMR> {
        using RFCEM = Field<_MMCRIMR, 5, 1>; // RFCEM
        using RFAEM = Field<_MMCRIMR, 6, 1>; // RFAEM
        using RGUFM = Field<_MMCRIMR, 17, 1>; // RGUFM
    };

    // Ethernet MMC transmit interrupt mask register
    struct _MMCTIMR : Register<Ethernet_MMC_BASE + 0x10, ReadWrite, _MMCTIMR> {
        using TGFSCM = Field<_MMCTIMR, 14, 1>; // TGFSCM
        using TGFMSCM = Field<_MMCTIMR, 15, 1>; // TGFMSCM
        using TGFM = Field<_MMCTIMR, 16, 1>; // TGFM
    };

    // Ethernet MMC transmitted good frames after a single collision counter
    struct _MMCTGFSCCR : Register<Ethernet_MMC_BASE + 0x4C, ReadOnly, _MMCTGFSCCR> {
        using TGFSCC = Field<_MMCTGFSCCR, 0, 32>; // TGFSCC
    };

    // Ethernet MMC transmitted good frames after more than a single collision
    struct _MMCTGFMSCCR : Register<Ethernet_MMC_BASE + 0x50, ReadOnly, _MMCTGFMSCCR> {
        using TGFMSCC = Field<_MMCTGFMSCCR, 0, 32>; // TGFMSCC
    };

    // Ethernet MMC transmitted good frames counter register
    struct _MMCTGFCR : Register<Ethernet_MMC_BASE + 0x68, ReadOnly, _MMCTGFCR> {
        using TGFC = Field<_MMCTGFCR, 0, 32>; // HTL
    };

    // Ethernet MMC received frames with CRC error counter register
    struct _MMCRFCECR : Register<Ethernet_MMC_BASE + 0x94, ReadOnly, _MMCRFCECR> {
        using RFCFC = Field<_MMCRFCECR, 0, 32>; // RFCFC
    };

    // Ethernet MMC received frames with alignment error counter register
    struct _MMCRFAECR : Register<Ethernet_MMC_BASE + 0x98, ReadOnly, _MMCRFAECR> {
        using RFAEC = Field<_MMCRFAECR, 0, 32>; // RFAEC
    };

    // MMC received good unicast frames counter register
    struct _MMCRGUFCR : Register<Ethernet_MMC_BASE + 0xC4, ReadOnly, _MMCRGUFCR> {
        using RGUFC = Field<_MMCRGUFCR, 0, 32>; // RGUFC
    };

} // namespace Ethernet_MMC

// --------------------------------------------
// Ethernet_PTP: Ethernet: Precision time protocol
// Base address: 0x40028700
// --------------------------------------------

namespace Ethernet_PTP {
    static constexpr uint32_t Ethernet_PTP_BASE = 0x40028700;

    // Ethernet PTP time stamp control register
    struct _PTPTSCR : Register<Ethernet_PTP_BASE + 0x0, ReadWrite, _PTPTSCR> {
        using TSE = Field<_PTPTSCR, 0, 1>; // TSE
        using TSFCU = Field<_PTPTSCR, 1, 1>; // TSFCU
        using TSPTPPSV2E = Field<_PTPTSCR, 10, 1>; // TSPTPPSV2E
        using TSSPTPOEFE = Field<_PTPTSCR, 11, 1>; // TSSPTPOEFE
        using TSSIPV6FE = Field<_PTPTSCR, 12, 1>; // TSSIPV6FE
        using TSSIPV4FE = Field<_PTPTSCR, 13, 1>; // TSSIPV4FE
        using TSSEME = Field<_PTPTSCR, 14, 1>; // TSSEME
        using TSSMRME = Field<_PTPTSCR, 15, 1>; // TSSMRME
        using TSCNT = Field<_PTPTSCR, 16, 2>; // TSCNT
        using TSPFFMAE = Field<_PTPTSCR, 18, 1>; // TSPFFMAE
        using TSSTI = Field<_PTPTSCR, 2, 1>; // TSSTI
        using TSSTU = Field<_PTPTSCR, 3, 1>; // TSSTU
        using TSITE = Field<_PTPTSCR, 4, 1>; // TSITE
        using TTSARU = Field<_PTPTSCR, 5, 1>; // TTSARU
        using TSSARFE = Field<_PTPTSCR, 8, 1>; // TSSARFE
        using TSSSR = Field<_PTPTSCR, 9, 1>; // TSSSR
    };

    // Ethernet PTP subsecond increment register
    struct _PTPSSIR : Register<Ethernet_PTP_BASE + 0x4, ReadWrite, _PTPSSIR> {
        using STSSI = Field<_PTPSSIR, 0, 8>; // STSSI
    };

    // Ethernet PTP time stamp high register
    struct _PTPTSHR : Register<Ethernet_PTP_BASE + 0x8, ReadOnly, _PTPTSHR> {
        using STS = Field<_PTPTSHR, 0, 32>; // STS
    };

    // Ethernet PTP time stamp low register
    struct _PTPTSLR : Register<Ethernet_PTP_BASE + 0xC, ReadOnly, _PTPTSLR> {
        using STSS = Field<_PTPTSLR, 0, 31>; // STSS
        using STPNS = Field<_PTPTSLR, 31, 1>; // STPNS
    };

    // Ethernet PTP time stamp high update register
    struct _PTPTSHUR : Register<Ethernet_PTP_BASE + 0x10, ReadWrite, _PTPTSHUR> {
        using TSUS = Field<_PTPTSHUR, 0, 32>; // TSUS
    };

    // Ethernet PTP time stamp low update register
    struct _PTPTSLUR : Register<Ethernet_PTP_BASE + 0x14, ReadWrite, _PTPTSLUR> {
        using TSUSS = Field<_PTPTSLUR, 0, 31>; // TSUSS
        using TSUPNS = Field<_PTPTSLUR, 31, 1>; // TSUPNS
    };

    // Ethernet PTP time stamp addend register
    struct _PTPTSAR : Register<Ethernet_PTP_BASE + 0x18, ReadWrite, _PTPTSAR> {
        using TSA = Field<_PTPTSAR, 0, 32>; // TSA
    };

    // Ethernet PTP target time high register
    struct _PTPTTHR : Register<Ethernet_PTP_BASE + 0x1C, ReadWrite, _PTPTTHR> {
        using TTSH = Field<_PTPTTHR, 0, 32>; // 0
    };

    // Ethernet PTP target time low register
    struct _PTPTTLR : Register<Ethernet_PTP_BASE + 0x20, ReadWrite, _PTPTTLR> {
        using TTSL = Field<_PTPTTLR, 0, 32>; // TTSL
    };

    // Ethernet PTP time stamp status register
    struct _PTPTSSR : Register<Ethernet_PTP_BASE + 0x28, ReadOnly, _PTPTSSR> {
        using TSSO = Field<_PTPTSSR, 0, 1>; // TSSO
        using TSTTR = Field<_PTPTSSR, 1, 1>; // TSTTR
    };

    // Ethernet PTP PPS control register
    struct _PTPPPSCR : Register<Ethernet_PTP_BASE + 0x2C, ReadOnly, _PTPPPSCR> {
        using TSSO = Field<_PTPPPSCR, 0, 1>; // TSSO
        using TSTTR = Field<_PTPPPSCR, 1, 1>; // TSTTR
    };

} // namespace Ethernet_PTP

// --------------------------------------------
// Ethernet_DMA: Ethernet: DMA controller operation
// Base address: 0x40029000
// --------------------------------------------

namespace Ethernet_DMA {
    static constexpr uint32_t Ethernet_DMA_BASE = 0x40029000;

    // Ethernet DMA bus mode register
    struct _DMABMR : Register<Ethernet_DMA_BASE + 0x0, ReadWrite, _DMABMR> {
        using SR = Field<_DMABMR, 0, 1>; // SR
        using DA = Field<_DMABMR, 1, 1>; // DA
        using DSL = Field<_DMABMR, 2, 5>; // DSL
        using EDFE = Field<_DMABMR, 7, 1>; // EDFE
        using PBL = Field<_DMABMR, 8, 6>; // PBL
        using RTPR = Field<_DMABMR, 14, 2>; // RTPR
        using FB = Field<_DMABMR, 16, 1>; // FB
        using RDP = Field<_DMABMR, 17, 6>; // RDP
        using USP = Field<_DMABMR, 23, 1>; // USP
        using FPM = Field<_DMABMR, 24, 1>; // FPM
        using AAB = Field<_DMABMR, 25, 1>; // AAB
        using MB = Field<_DMABMR, 26, 1>; // MB
    };

    // Ethernet DMA transmit poll demand register
    struct _DMATPDR : Register<Ethernet_DMA_BASE + 0x4, ReadWrite, _DMATPDR> {
        using TPD = Field<_DMATPDR, 0, 32>; // TPD
    };

    // EHERNET DMA receive poll demand register
    struct _DMARPDR : Register<Ethernet_DMA_BASE + 0x8, ReadWrite, _DMARPDR> {
        using RPD = Field<_DMARPDR, 0, 32>; // RPD
    };

    // Ethernet DMA receive descriptor list address register
    struct _DMARDLAR : Register<Ethernet_DMA_BASE + 0xC, ReadWrite, _DMARDLAR> {
        using SRL = Field<_DMARDLAR, 0, 32>; // SRL
    };

    // Ethernet DMA transmit descriptor list address register
    struct _DMATDLAR : Register<Ethernet_DMA_BASE + 0x10, ReadWrite, _DMATDLAR> {
        using STL = Field<_DMATDLAR, 0, 32>; // STL
    };

    // Ethernet DMA status register
    struct _DMASR : Register<Ethernet_DMA_BASE + 0x14, ReadWrite, _DMASR> {
        using TS = Field<_DMASR, 0, 1>; // TS
        using TPSS = Field<_DMASR, 1, 1>; // TPSS
        using TBUS = Field<_DMASR, 2, 1>; // TBUS
        using TJTS = Field<_DMASR, 3, 1>; // TJTS
        using ROS = Field<_DMASR, 4, 1>; // ROS
        using TUS = Field<_DMASR, 5, 1>; // TUS
        using RS = Field<_DMASR, 6, 1>; // RS
        using RBUS = Field<_DMASR, 7, 1>; // RBUS
        using RPSS = Field<_DMASR, 8, 1>; // RPSS
        using PWTS = Field<_DMASR, 9, 1>; // PWTS
        using ETS = Field<_DMASR, 10, 1>; // ETS
        using FBES = Field<_DMASR, 13, 1>; // FBES
        using ERS = Field<_DMASR, 14, 1>; // ERS
        using AIS = Field<_DMASR, 15, 1>; // AIS
        using NIS = Field<_DMASR, 16, 1>; // NIS
        using RPS = Field<_DMASR, 17, 3>; // RPS
        using TPS = Field<_DMASR, 20, 3>; // TPS
        using EBS = Field<_DMASR, 23, 3>; // EBS
        using MMCS = Field<_DMASR, 27, 1>; // MMCS
        using PMTS = Field<_DMASR, 28, 1>; // PMTS
        using TSTS = Field<_DMASR, 29, 1>; // TSTS
    };

    // Ethernet DMA operation mode register
    struct _DMAOMR : Register<Ethernet_DMA_BASE + 0x18, ReadWrite, _DMAOMR> {
        using SR = Field<_DMAOMR, 1, 1>; // SR
        using OSF = Field<_DMAOMR, 2, 1>; // OSF
        using RTC = Field<_DMAOMR, 3, 2>; // RTC
        using FUGF = Field<_DMAOMR, 6, 1>; // FUGF
        using FEF = Field<_DMAOMR, 7, 1>; // FEF
        using ST = Field<_DMAOMR, 13, 1>; // ST
        using TTC = Field<_DMAOMR, 14, 3>; // TTC
        using FTF = Field<_DMAOMR, 20, 1>; // FTF
        using TSF = Field<_DMAOMR, 21, 1>; // TSF
        using DFRF = Field<_DMAOMR, 24, 1>; // DFRF
        using RSF = Field<_DMAOMR, 25, 1>; // RSF
        using DTCEFD = Field<_DMAOMR, 26, 1>; // DTCEFD
    };

    // Ethernet DMA interrupt enable register
    struct _DMAIER : Register<Ethernet_DMA_BASE + 0x1C, ReadWrite, _DMAIER> {
        using TIE = Field<_DMAIER, 0, 1>; // TIE
        using TPSIE = Field<_DMAIER, 1, 1>; // TPSIE
        using TBUIE = Field<_DMAIER, 2, 1>; // TBUIE
        using TJTIE = Field<_DMAIER, 3, 1>; // TJTIE
        using ROIE = Field<_DMAIER, 4, 1>; // ROIE
        using TUIE = Field<_DMAIER, 5, 1>; // TUIE
        using RIE = Field<_DMAIER, 6, 1>; // RIE
        using RBUIE = Field<_DMAIER, 7, 1>; // RBUIE
        using RPSIE = Field<_DMAIER, 8, 1>; // RPSIE
        using RWTIE = Field<_DMAIER, 9, 1>; // RWTIE
        using ETIE = Field<_DMAIER, 10, 1>; // ETIE
        using FBEIE = Field<_DMAIER, 13, 1>; // FBEIE
        using ERIE = Field<_DMAIER, 14, 1>; // ERIE
        using AISE = Field<_DMAIER, 15, 1>; // AISE
        using NISE = Field<_DMAIER, 16, 1>; // NISE
    };

    // Ethernet DMA missed frame and buffer overflow counter register
    struct _DMAMFBOCR : Register<Ethernet_DMA_BASE + 0x20, ReadWrite, _DMAMFBOCR> {
        using MFC = Field<_DMAMFBOCR, 0, 16>; // MFC
        using OMFC = Field<_DMAMFBOCR, 16, 1>; // OMFC
        using MFA = Field<_DMAMFBOCR, 17, 11>; // MFA
        using OFOC = Field<_DMAMFBOCR, 28, 1>; // OFOC
    };

    // Ethernet DMA receive status watchdog timer register
    struct _DMARSWTR : Register<Ethernet_DMA_BASE + 0x24, ReadWrite, _DMARSWTR> {
        using RSWTC = Field<_DMARSWTR, 0, 8>; // RSWTC
    };

    // Ethernet DMA current host transmit descriptor register
    struct _DMACHTDR : Register<Ethernet_DMA_BASE + 0x48, ReadOnly, _DMACHTDR> {
        using HTDAP = Field<_DMACHTDR, 0, 32>; // HTDAP
    };

    // Ethernet DMA current host receive descriptor register
    struct _DMACHRDR : Register<Ethernet_DMA_BASE + 0x4C, ReadOnly, _DMACHRDR> {
        using HRDAP = Field<_DMACHRDR, 0, 32>; // HRDAP
    };

    // Ethernet DMA current host transmit buffer address register
    struct _DMACHTBAR : Register<Ethernet_DMA_BASE + 0x50, ReadOnly, _DMACHTBAR> {
        using HTBAP = Field<_DMACHTBAR, 0, 32>; // HTBAP
    };

    // Ethernet DMA current host receive buffer address register
    struct _DMACHRBAR : Register<Ethernet_DMA_BASE + 0x54, ReadOnly, _DMACHRBAR> {
        using HRBAP = Field<_DMACHRBAR, 0, 32>; // HRBAP
    };

} // namespace Ethernet_DMA

// --------------------------------------------
// OTG_FS_HOST: USB on the go full speed
// Base address: 0x50000400
// --------------------------------------------

namespace OTG_FS_HOST {
    static constexpr uint32_t OTG_FS_HOST_BASE = 0x50000400;

    // OTG_FS host configuration register (OTG_FS_HCFG)
    struct _OTG_FS_HCFG : Register<OTG_FS_HOST_BASE + 0x0, ReadWrite, _OTG_FS_HCFG> {
        using FSLSPCS = Field<_OTG_FS_HCFG, 0, 2>; // FS/LS PHY clock select
        using FSLSS = Field<_OTG_FS_HCFG, 2, 1>; // FS- and LS-only support
    };

    // OTG_FS Host frame interval register
    struct _OTG_FS_HFIR : Register<OTG_FS_HOST_BASE + 0x4, ReadWrite, _OTG_FS_HFIR> {
        using FRIVL = Field<_OTG_FS_HFIR, 0, 16>; // Frame interval
    };

    // OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
    struct _OTG_FS_HFNUM : Register<OTG_FS_HOST_BASE + 0x8, ReadOnly, _OTG_FS_HFNUM> {
        using FRNUM = Field<_OTG_FS_HFNUM, 0, 16>; // Frame number
        using FTREM = Field<_OTG_FS_HFNUM, 16, 16>; // Frame time remaining
    };

    // OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
    struct _OTG_FS_HPTXSTS : Register<OTG_FS_HOST_BASE + 0x10, ReadWrite, _OTG_FS_HPTXSTS> {
        using PTXFSAVL = Field<_OTG_FS_HPTXSTS, 0, 16>; // Periodic transmit data FIFO space available
        using PTXQSAV = Field<_OTG_FS_HPTXSTS, 16, 8>; // Periodic transmit request queue space available
        using PTXQTOP = Field<_OTG_FS_HPTXSTS, 24, 8>; // Top of the periodic transmit request queue
    };

    // OTG_FS Host all channels interrupt register
    struct _OTG_FS_HAINT : Register<OTG_FS_HOST_BASE + 0x14, ReadOnly, _OTG_FS_HAINT> {
        using HAINT = Field<_OTG_FS_HAINT, 0, 16>; // Channel interrupts
    };

    // OTG_FS host all channels interrupt mask register
    struct _OTG_FS_HAINTMSK : Register<OTG_FS_HOST_BASE + 0x18, ReadWrite, _OTG_FS_HAINTMSK> {
        using HAINTM = Field<_OTG_FS_HAINTMSK, 0, 16>; // Channel interrupt mask
    };

    // OTG_FS host port control and status register (OTG_FS_HPRT)
    struct _OTG_FS_HPRT : Register<OTG_FS_HOST_BASE + 0x40, ReadWrite, _OTG_FS_HPRT> {
        using PCSTS = Field<_OTG_FS_HPRT, 0, 1>; // Port connect status
        using PCDET = Field<_OTG_FS_HPRT, 1, 1>; // Port connect detected
        using PENA = Field<_OTG_FS_HPRT, 2, 1>; // Port enable
        using PENCHNG = Field<_OTG_FS_HPRT, 3, 1>; // Port enable/disable change
        using POCA = Field<_OTG_FS_HPRT, 4, 1>; // Port overcurrent active
        using POCCHNG = Field<_OTG_FS_HPRT, 5, 1>; // Port overcurrent change
        using PRES = Field<_OTG_FS_HPRT, 6, 1>; // Port resume
        using PSUSP = Field<_OTG_FS_HPRT, 7, 1>; // Port suspend
        using PRST = Field<_OTG_FS_HPRT, 8, 1>; // Port reset
        using PLSTS = Field<_OTG_FS_HPRT, 10, 2>; // Port line status
        using PPWR = Field<_OTG_FS_HPRT, 12, 1>; // Port power
        using PTCTL = Field<_OTG_FS_HPRT, 13, 4>; // Port test control
        using PSPD = Field<_OTG_FS_HPRT, 17, 2>; // Port speed
    };

    // OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
    struct _OTG_FS_HCCHAR0 : Register<OTG_FS_HOST_BASE + 0x100, ReadWrite, _OTG_FS_HCCHAR0> {
        using MPSIZ = Field<_OTG_FS_HCCHAR0, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR0, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR0, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR0, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR0, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR0, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR0, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR0, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR0, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR0, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
    struct _OTG_FS_HCCHAR1 : Register<OTG_FS_HOST_BASE + 0x120, ReadWrite, _OTG_FS_HCCHAR1> {
        using MPSIZ = Field<_OTG_FS_HCCHAR1, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR1, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR1, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR1, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR1, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR1, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR1, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR1, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR1, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR1, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
    struct _OTG_FS_HCCHAR2 : Register<OTG_FS_HOST_BASE + 0x140, ReadWrite, _OTG_FS_HCCHAR2> {
        using MPSIZ = Field<_OTG_FS_HCCHAR2, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR2, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR2, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR2, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR2, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR2, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR2, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR2, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR2, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR2, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
    struct _OTG_FS_HCCHAR3 : Register<OTG_FS_HOST_BASE + 0x160, ReadWrite, _OTG_FS_HCCHAR3> {
        using MPSIZ = Field<_OTG_FS_HCCHAR3, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR3, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR3, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR3, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR3, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR3, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR3, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR3, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR3, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR3, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
    struct _OTG_FS_HCCHAR4 : Register<OTG_FS_HOST_BASE + 0x180, ReadWrite, _OTG_FS_HCCHAR4> {
        using MPSIZ = Field<_OTG_FS_HCCHAR4, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR4, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR4, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR4, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR4, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR4, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR4, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR4, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR4, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR4, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
    struct _OTG_FS_HCCHAR5 : Register<OTG_FS_HOST_BASE + 0x1A0, ReadWrite, _OTG_FS_HCCHAR5> {
        using MPSIZ = Field<_OTG_FS_HCCHAR5, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR5, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR5, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR5, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR5, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR5, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR5, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR5, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR5, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR5, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
    struct _OTG_FS_HCCHAR6 : Register<OTG_FS_HOST_BASE + 0x1C0, ReadWrite, _OTG_FS_HCCHAR6> {
        using MPSIZ = Field<_OTG_FS_HCCHAR6, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR6, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR6, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR6, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR6, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR6, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR6, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR6, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR6, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR6, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
    struct _OTG_FS_HCCHAR7 : Register<OTG_FS_HOST_BASE + 0x1E0, ReadWrite, _OTG_FS_HCCHAR7> {
        using MPSIZ = Field<_OTG_FS_HCCHAR7, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR7, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR7, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR7, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR7, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR7, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR7, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR7, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR7, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR7, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
    struct _OTG_FS_HCINT0 : Register<OTG_FS_HOST_BASE + 0x108, ReadWrite, _OTG_FS_HCINT0> {
        using XFRC = Field<_OTG_FS_HCINT0, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT0, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT0, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT0, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT0, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT0, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT0, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT0, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT0, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
    struct _OTG_FS_HCINT1 : Register<OTG_FS_HOST_BASE + 0x128, ReadWrite, _OTG_FS_HCINT1> {
        using XFRC = Field<_OTG_FS_HCINT1, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT1, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT1, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT1, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT1, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT1, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT1, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT1, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT1, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
    struct _OTG_FS_HCINT2 : Register<OTG_FS_HOST_BASE + 0x148, ReadWrite, _OTG_FS_HCINT2> {
        using XFRC = Field<_OTG_FS_HCINT2, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT2, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT2, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT2, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT2, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT2, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT2, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT2, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT2, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
    struct _OTG_FS_HCINT3 : Register<OTG_FS_HOST_BASE + 0x168, ReadWrite, _OTG_FS_HCINT3> {
        using XFRC = Field<_OTG_FS_HCINT3, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT3, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT3, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT3, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT3, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT3, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT3, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT3, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT3, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
    struct _OTG_FS_HCINT4 : Register<OTG_FS_HOST_BASE + 0x188, ReadWrite, _OTG_FS_HCINT4> {
        using XFRC = Field<_OTG_FS_HCINT4, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT4, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT4, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT4, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT4, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT4, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT4, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT4, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT4, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
    struct _OTG_FS_HCINT5 : Register<OTG_FS_HOST_BASE + 0x1A8, ReadWrite, _OTG_FS_HCINT5> {
        using XFRC = Field<_OTG_FS_HCINT5, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT5, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT5, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT5, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT5, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT5, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT5, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT5, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT5, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
    struct _OTG_FS_HCINT6 : Register<OTG_FS_HOST_BASE + 0x1C8, ReadWrite, _OTG_FS_HCINT6> {
        using XFRC = Field<_OTG_FS_HCINT6, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT6, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT6, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT6, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT6, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT6, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT6, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT6, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT6, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
    struct _OTG_FS_HCINT7 : Register<OTG_FS_HOST_BASE + 0x1E8, ReadWrite, _OTG_FS_HCINT7> {
        using XFRC = Field<_OTG_FS_HCINT7, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT7, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT7, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT7, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT7, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT7, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT7, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT7, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT7, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
    struct _OTG_FS_HCINTMSK0 : Register<OTG_FS_HOST_BASE + 0x10C, ReadWrite, _OTG_FS_HCINTMSK0> {
        using XFRCM = Field<_OTG_FS_HCINTMSK0, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK0, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK0, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK0, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK0, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK0, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK0, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK0, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK0, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK0, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
    struct _OTG_FS_HCINTMSK1 : Register<OTG_FS_HOST_BASE + 0x12C, ReadWrite, _OTG_FS_HCINTMSK1> {
        using XFRCM = Field<_OTG_FS_HCINTMSK1, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK1, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK1, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK1, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK1, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK1, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK1, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK1, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK1, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK1, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
    struct _OTG_FS_HCINTMSK2 : Register<OTG_FS_HOST_BASE + 0x14C, ReadWrite, _OTG_FS_HCINTMSK2> {
        using XFRCM = Field<_OTG_FS_HCINTMSK2, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK2, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK2, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK2, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK2, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK2, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK2, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK2, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK2, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK2, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
    struct _OTG_FS_HCINTMSK3 : Register<OTG_FS_HOST_BASE + 0x16C, ReadWrite, _OTG_FS_HCINTMSK3> {
        using XFRCM = Field<_OTG_FS_HCINTMSK3, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK3, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK3, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK3, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK3, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK3, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK3, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK3, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK3, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK3, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
    struct _OTG_FS_HCINTMSK4 : Register<OTG_FS_HOST_BASE + 0x18C, ReadWrite, _OTG_FS_HCINTMSK4> {
        using XFRCM = Field<_OTG_FS_HCINTMSK4, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK4, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK4, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK4, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK4, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK4, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK4, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK4, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK4, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK4, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
    struct _OTG_FS_HCINTMSK5 : Register<OTG_FS_HOST_BASE + 0x1AC, ReadWrite, _OTG_FS_HCINTMSK5> {
        using XFRCM = Field<_OTG_FS_HCINTMSK5, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK5, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK5, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK5, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK5, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK5, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK5, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK5, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK5, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK5, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
    struct _OTG_FS_HCINTMSK6 : Register<OTG_FS_HOST_BASE + 0x1CC, ReadWrite, _OTG_FS_HCINTMSK6> {
        using XFRCM = Field<_OTG_FS_HCINTMSK6, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK6, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK6, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK6, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK6, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK6, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK6, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK6, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK6, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK6, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
    struct _OTG_FS_HCINTMSK7 : Register<OTG_FS_HOST_BASE + 0x1EC, ReadWrite, _OTG_FS_HCINTMSK7> {
        using XFRCM = Field<_OTG_FS_HCINTMSK7, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK7, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK7, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK7, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK7, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK7, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK7, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK7, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK7, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK7, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-0 transfer size register
    struct _OTG_FS_HCTSIZ0 : Register<OTG_FS_HOST_BASE + 0x110, ReadWrite, _OTG_FS_HCTSIZ0> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ0, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ0, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ0, 29, 2>; // Data PID
    };

    // OTG_FS host channel-1 transfer size register
    struct _OTG_FS_HCTSIZ1 : Register<OTG_FS_HOST_BASE + 0x130, ReadWrite, _OTG_FS_HCTSIZ1> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ1, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ1, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ1, 29, 2>; // Data PID
    };

    // OTG_FS host channel-2 transfer size register
    struct _OTG_FS_HCTSIZ2 : Register<OTG_FS_HOST_BASE + 0x150, ReadWrite, _OTG_FS_HCTSIZ2> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ2, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ2, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ2, 29, 2>; // Data PID
    };

    // OTG_FS host channel-3 transfer size register
    struct _OTG_FS_HCTSIZ3 : Register<OTG_FS_HOST_BASE + 0x170, ReadWrite, _OTG_FS_HCTSIZ3> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ3, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ3, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ3, 29, 2>; // Data PID
    };

    // OTG_FS host channel-x transfer size register
    struct _OTG_FS_HCTSIZ4 : Register<OTG_FS_HOST_BASE + 0x190, ReadWrite, _OTG_FS_HCTSIZ4> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ4, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ4, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ4, 29, 2>; // Data PID
    };

    // OTG_FS host channel-5 transfer size register
    struct _OTG_FS_HCTSIZ5 : Register<OTG_FS_HOST_BASE + 0x1B0, ReadWrite, _OTG_FS_HCTSIZ5> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ5, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ5, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ5, 29, 2>; // Data PID
    };

    // OTG_FS host channel-6 transfer size register
    struct _OTG_FS_HCTSIZ6 : Register<OTG_FS_HOST_BASE + 0x1D0, ReadWrite, _OTG_FS_HCTSIZ6> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ6, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ6, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ6, 29, 2>; // Data PID
    };

    // OTG_FS host channel-7 transfer size register
    struct _OTG_FS_HCTSIZ7 : Register<OTG_FS_HOST_BASE + 0x1F0, ReadWrite, _OTG_FS_HCTSIZ7> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ7, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ7, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ7, 29, 2>; // Data PID
    };

    // OTG_FS host channel-8 characteristics register
    struct _OTG_FS_HCCHAR8 : Register<OTG_FS_HOST_BASE + 0x1F4, ReadWrite, _OTG_FS_HCCHAR8> {
        using MPSIZ = Field<_OTG_FS_HCCHAR8, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR8, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR8, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR8, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR8, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR8, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR8, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR8, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR8, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR8, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-8 interrupt register
    struct _OTG_FS_HCINT8 : Register<OTG_FS_HOST_BASE + 0x1F8, ReadWrite, _OTG_FS_HCINT8> {
        using XFRC = Field<_OTG_FS_HCINT8, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT8, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT8, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT8, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT8, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT8, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT8, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT8, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT8, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-8 mask register
    struct _OTG_FS_HCINTMSK8 : Register<OTG_FS_HOST_BASE + 0x1FC, ReadWrite, _OTG_FS_HCINTMSK8> {
        using XFRCM = Field<_OTG_FS_HCINTMSK8, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK8, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK8, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK8, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK8, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK8, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK8, 7, 1>; // Transaction error
        using BBERRM = Field<_OTG_FS_HCINTMSK8, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK8, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK8, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-8 transfer size register
    struct _OTG_FS_HCTSIZ8 : Register<OTG_FS_HOST_BASE + 0x200, ReadWrite, _OTG_FS_HCTSIZ8> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ8, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ8, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ8, 29, 2>; // Data PID
    };

    // OTG_FS host channel-9 characteristics register
    struct _OTG_FS_HCCHAR9 : Register<OTG_FS_HOST_BASE + 0x204, ReadWrite, _OTG_FS_HCCHAR9> {
        using MPSIZ = Field<_OTG_FS_HCCHAR9, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR9, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR9, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR9, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR9, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR9, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR9, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR9, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR9, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR9, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-9 interrupt register
    struct _OTG_FS_HCINT9 : Register<OTG_FS_HOST_BASE + 0x208, ReadWrite, _OTG_FS_HCINT9> {
        using XFRC = Field<_OTG_FS_HCINT9, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT9, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT9, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT9, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT9, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT9, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT9, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT9, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT9, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-9 mask register
    struct _OTG_FS_HCINTMSK9 : Register<OTG_FS_HOST_BASE + 0x20C, ReadWrite, _OTG_FS_HCINTMSK9> {
        using XFRCM = Field<_OTG_FS_HCINTMSK9, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK9, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK9, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK9, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK9, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK9, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK9, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK9, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK9, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK9, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-9 transfer size register
    struct _OTG_FS_HCTSIZ9 : Register<OTG_FS_HOST_BASE + 0x210, ReadWrite, _OTG_FS_HCTSIZ9> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ9, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ9, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ9, 29, 2>; // Data PID
    };

    // OTG_FS host channel-10 characteristics register
    struct _OTG_FS_HCCHAR10 : Register<OTG_FS_HOST_BASE + 0x214, ReadWrite, _OTG_FS_HCCHAR10> {
        using MPSIZ = Field<_OTG_FS_HCCHAR10, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR10, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR10, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR10, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR10, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR10, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR10, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR10, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR10, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR10, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-10 interrupt register
    struct _OTG_FS_HCINT10 : Register<OTG_FS_HOST_BASE + 0x218, ReadWrite, _OTG_FS_HCINT10> {
        using XFRC = Field<_OTG_FS_HCINT10, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT10, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT10, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT10, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT10, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT10, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT10, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT10, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT10, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-10 mask register
    struct _OTG_FS_HCINTMSK10 : Register<OTG_FS_HOST_BASE + 0x21C, ReadWrite, _OTG_FS_HCINTMSK10> {
        using XFRCM = Field<_OTG_FS_HCINTMSK10, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK10, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK10, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK10, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK10, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK10, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK10, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK10, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK10, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK10, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-10 transfer size register
    struct _OTG_FS_HCTSIZ10 : Register<OTG_FS_HOST_BASE + 0x220, ReadWrite, _OTG_FS_HCTSIZ10> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ10, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ10, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ10, 29, 2>; // Data PID
    };

    // OTG_FS host channel-11 characteristics register
    struct _OTG_FS_HCCHAR11 : Register<OTG_FS_HOST_BASE + 0x224, ReadWrite, _OTG_FS_HCCHAR11> {
        using MPSIZ = Field<_OTG_FS_HCCHAR11, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_FS_HCCHAR11, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_FS_HCCHAR11, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_FS_HCCHAR11, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_FS_HCCHAR11, 18, 2>; // Endpoint type
        using MCNT = Field<_OTG_FS_HCCHAR11, 20, 2>; // Multicount
        using DAD = Field<_OTG_FS_HCCHAR11, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_FS_HCCHAR11, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_FS_HCCHAR11, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_FS_HCCHAR11, 31, 1>; // Channel enable
    };

    // OTG_FS host channel-11 interrupt register
    struct _OTG_FS_HCINT11 : Register<OTG_FS_HOST_BASE + 0x228, ReadWrite, _OTG_FS_HCINT11> {
        using XFRC = Field<_OTG_FS_HCINT11, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_FS_HCINT11, 1, 1>; // Channel halted
        using STALL = Field<_OTG_FS_HCINT11, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_FS_HCINT11, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_FS_HCINT11, 5, 1>; // ACK response received/transmitted interrupt
        using TXERR = Field<_OTG_FS_HCINT11, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_FS_HCINT11, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_FS_HCINT11, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_FS_HCINT11, 10, 1>; // Data toggle error
    };

    // OTG_FS host channel-11 mask register
    struct _OTG_FS_HCINTMSK11 : Register<OTG_FS_HOST_BASE + 0x22C, ReadWrite, _OTG_FS_HCINTMSK11> {
        using XFRCM = Field<_OTG_FS_HCINTMSK11, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_FS_HCINTMSK11, 1, 1>; // Channel halted mask
        using STALLM = Field<_OTG_FS_HCINTMSK11, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_FS_HCINTMSK11, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_FS_HCINTMSK11, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_FS_HCINTMSK11, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_FS_HCINTMSK11, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_FS_HCINTMSK11, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_FS_HCINTMSK11, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_FS_HCINTMSK11, 10, 1>; // Data toggle error mask
    };

    // OTG_FS host channel-11 transfer size register
    struct _OTG_FS_HCTSIZ11 : Register<OTG_FS_HOST_BASE + 0x230, ReadWrite, _OTG_FS_HCTSIZ11> {
        using XFRSIZ = Field<_OTG_FS_HCTSIZ11, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_FS_HCTSIZ11, 19, 10>; // Packet count
        using DPID = Field<_OTG_FS_HCTSIZ11, 29, 2>; // Data PID
    };

} // namespace OTG_FS_HOST

// --------------------------------------------
// OTG_FS_DEVICE: USB on the go full speed
// Base address: 0x50000800
// --------------------------------------------

namespace OTG_FS_DEVICE {
    static constexpr uint32_t OTG_FS_DEVICE_BASE = 0x50000800;

    // OTG_FS device configuration register (OTG_FS_DCFG)
    struct _OTG_FS_DCFG : Register<OTG_FS_DEVICE_BASE + 0x0, ReadWrite, _OTG_FS_DCFG> {
        using DSPD = Field<_OTG_FS_DCFG, 0, 2>; // Device speed
        using NZLSOHSK = Field<_OTG_FS_DCFG, 2, 1>; // Non-zero-length status OUT handshake
        using DAD = Field<_OTG_FS_DCFG, 4, 7>; // Device address
        using PFIVL = Field<_OTG_FS_DCFG, 11, 2>; // Periodic frame interval
    };

    // OTG_FS device control register (OTG_FS_DCTL)
    struct _OTG_FS_DCTL : Register<OTG_FS_DEVICE_BASE + 0x4, ReadWrite, _OTG_FS_DCTL> {
        using RWUSIG = Field<_OTG_FS_DCTL, 0, 1>; // Remote wakeup signaling
        using SDIS = Field<_OTG_FS_DCTL, 1, 1>; // Soft disconnect
        using GINSTS = Field<_OTG_FS_DCTL, 2, 1>; // Global IN NAK status
        using GONSTS = Field<_OTG_FS_DCTL, 3, 1>; // Global OUT NAK status
        using TCTL = Field<_OTG_FS_DCTL, 4, 3>; // Test control
        using SGINAK = Field<_OTG_FS_DCTL, 7, 1>; // Set global IN NAK
        using CGINAK = Field<_OTG_FS_DCTL, 8, 1>; // Clear global IN NAK
        using SGONAK = Field<_OTG_FS_DCTL, 9, 1>; // Set global OUT NAK
        using CGONAK = Field<_OTG_FS_DCTL, 10, 1>; // Clear global OUT NAK
        using POPRGDNE = Field<_OTG_FS_DCTL, 11, 1>; // Power-on programming done
    };

    // OTG_FS device status register (OTG_FS_DSTS)
    struct _OTG_FS_DSTS : Register<OTG_FS_DEVICE_BASE + 0x8, ReadOnly, _OTG_FS_DSTS> {
        using SUSPSTS = Field<_OTG_FS_DSTS, 0, 1>; // Suspend status
        using ENUMSPD = Field<_OTG_FS_DSTS, 1, 2>; // Enumerated speed
        using EERR = Field<_OTG_FS_DSTS, 3, 1>; // Erratic error
        using FNSOF = Field<_OTG_FS_DSTS, 8, 14>; // Frame number of the received SOF
    };

    // OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
    struct _OTG_FS_DIEPMSK : Register<OTG_FS_DEVICE_BASE + 0x10, ReadWrite, _OTG_FS_DIEPMSK> {
        using XFRCM = Field<_OTG_FS_DIEPMSK, 0, 1>; // Transfer completed interrupt mask
        using EPDM = Field<_OTG_FS_DIEPMSK, 1, 1>; // Endpoint disabled interrupt mask
        using TOM = Field<_OTG_FS_DIEPMSK, 3, 1>; // Timeout condition mask (Non-isochronous endpoints)
        using ITTXFEMSK = Field<_OTG_FS_DIEPMSK, 4, 1>; // IN token received when TxFIFO empty mask
        using INEPNMM = Field<_OTG_FS_DIEPMSK, 5, 1>; // IN token received with EP mismatch mask
        using INEPNEM = Field<_OTG_FS_DIEPMSK, 6, 1>; // IN endpoint NAK effective mask
    };

    // OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
    struct _OTG_FS_DOEPMSK : Register<OTG_FS_DEVICE_BASE + 0x14, ReadWrite, _OTG_FS_DOEPMSK> {
        using XFRCM = Field<_OTG_FS_DOEPMSK, 0, 1>; // Transfer completed interrupt mask
        using EPDM = Field<_OTG_FS_DOEPMSK, 1, 1>; // Endpoint disabled interrupt mask
        using STUPM = Field<_OTG_FS_DOEPMSK, 3, 1>; // SETUP phase done mask
        using OTEPDM = Field<_OTG_FS_DOEPMSK, 4, 1>; // OUT token received when endpoint disabled mask
    };

    // OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
    struct _OTG_FS_DAINT : Register<OTG_FS_DEVICE_BASE + 0x18, ReadOnly, _OTG_FS_DAINT> {
        using IEPINT = Field<_OTG_FS_DAINT, 0, 16>; // IN endpoint interrupt bits
        using OEPINT = Field<_OTG_FS_DAINT, 16, 16>; // OUT endpoint interrupt bits
    };

    // OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
    struct _OTG_FS_DAINTMSK : Register<OTG_FS_DEVICE_BASE + 0x1C, ReadWrite, _OTG_FS_DAINTMSK> {
        using IEPM = Field<_OTG_FS_DAINTMSK, 0, 16>; // IN EP interrupt mask bits
        using OEPINT = Field<_OTG_FS_DAINTMSK, 16, 16>; // OUT endpoint interrupt bits
    };

    // OTG_FS device VBUS discharge time register
    struct _OTG_FS_DVBUSDIS : Register<OTG_FS_DEVICE_BASE + 0x28, ReadWrite, _OTG_FS_DVBUSDIS> {
        using VBUSDT = Field<_OTG_FS_DVBUSDIS, 0, 16>; // Device VBUS discharge time
    };

    // OTG_FS device VBUS pulsing time register
    struct _OTG_FS_DVBUSPULSE : Register<OTG_FS_DEVICE_BASE + 0x2C, ReadWrite, _OTG_FS_DVBUSPULSE> {
        using DVBUSP = Field<_OTG_FS_DVBUSPULSE, 0, 12>; // Device VBUS pulsing time
    };

    // OTG_FS device IN endpoint FIFO empty interrupt mask register
    struct _OTG_FS_DIEPEMPMSK : Register<OTG_FS_DEVICE_BASE + 0x34, ReadWrite, _OTG_FS_DIEPEMPMSK> {
        using INEPTXFEM = Field<_OTG_FS_DIEPEMPMSK, 0, 16>; // IN EP Tx FIFO empty interrupt mask bits
    };

    // OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
    struct _OTG_FS_DIEPCTL0 : Register<OTG_FS_DEVICE_BASE + 0x100, ReadWrite, _OTG_FS_DIEPCTL0> {
        using MPSIZ = Field<_OTG_FS_DIEPCTL0, 0, 2>; // Maximum packet size
        using USBAEP = Field<_OTG_FS_DIEPCTL0, 15, 1>; // USB active endpoint
        using NAKSTS = Field<_OTG_FS_DIEPCTL0, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_FS_DIEPCTL0, 18, 2>; // Endpoint type
        using STALL = Field<_OTG_FS_DIEPCTL0, 21, 1>; // STALL handshake
        using TXFNUM = Field<_OTG_FS_DIEPCTL0, 22, 4>; // TxFIFO number
        using CNAK = Field<_OTG_FS_DIEPCTL0, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_FS_DIEPCTL0, 27, 1>; // Set NAK
        using EPDIS = Field<_OTG_FS_DIEPCTL0, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_FS_DIEPCTL0, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-1 control register
    struct _OTG_FS_DIEPCTL1 : Register<OTG_FS_DEVICE_BASE + 0x120, ReadWrite, _OTG_FS_DIEPCTL1> {
        using EPENA = Field<_OTG_FS_DIEPCTL1, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DIEPCTL1, 30, 1>; // EPDIS
        using SODDFRM_SD1PID = Field<_OTG_FS_DIEPCTL1, 29, 1>; // SODDFRM/SD1PID
        using SD0PID_SEVNFRM = Field<_OTG_FS_DIEPCTL1, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DIEPCTL1, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DIEPCTL1, 26, 1>; // CNAK
        using TXFNUM = Field<_OTG_FS_DIEPCTL1, 22, 4>; // TXFNUM
        using Stall = Field<_OTG_FS_DIEPCTL1, 21, 1>; // Stall
        using EPTYP = Field<_OTG_FS_DIEPCTL1, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DIEPCTL1, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DIEPCTL1, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DIEPCTL1, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DIEPCTL1, 0, 11>; // MPSIZ
    };

    // OTG device endpoint-2 control register
    struct _OTG_FS_DIEPCTL2 : Register<OTG_FS_DEVICE_BASE + 0x140, ReadWrite, _OTG_FS_DIEPCTL2> {
        using EPENA = Field<_OTG_FS_DIEPCTL2, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DIEPCTL2, 30, 1>; // EPDIS
        using SODDFRM = Field<_OTG_FS_DIEPCTL2, 29, 1>; // SODDFRM
        using SD0PID_SEVNFRM = Field<_OTG_FS_DIEPCTL2, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DIEPCTL2, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DIEPCTL2, 26, 1>; // CNAK
        using TXFNUM = Field<_OTG_FS_DIEPCTL2, 22, 4>; // TXFNUM
        using Stall = Field<_OTG_FS_DIEPCTL2, 21, 1>; // Stall
        using EPTYP = Field<_OTG_FS_DIEPCTL2, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DIEPCTL2, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DIEPCTL2, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DIEPCTL2, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DIEPCTL2, 0, 11>; // MPSIZ
    };

    // OTG device endpoint-3 control register
    struct _OTG_FS_DIEPCTL3 : Register<OTG_FS_DEVICE_BASE + 0x160, ReadWrite, _OTG_FS_DIEPCTL3> {
        using EPENA = Field<_OTG_FS_DIEPCTL3, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DIEPCTL3, 30, 1>; // EPDIS
        using SODDFRM = Field<_OTG_FS_DIEPCTL3, 29, 1>; // SODDFRM
        using SD0PID_SEVNFRM = Field<_OTG_FS_DIEPCTL3, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DIEPCTL3, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DIEPCTL3, 26, 1>; // CNAK
        using TXFNUM = Field<_OTG_FS_DIEPCTL3, 22, 4>; // TXFNUM
        using Stall = Field<_OTG_FS_DIEPCTL3, 21, 1>; // Stall
        using EPTYP = Field<_OTG_FS_DIEPCTL3, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DIEPCTL3, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DIEPCTL3, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DIEPCTL3, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DIEPCTL3, 0, 11>; // MPSIZ
    };

    // device endpoint-0 control register
    struct _OTG_FS_DOEPCTL0 : Register<OTG_FS_DEVICE_BASE + 0x300, ReadWrite, _OTG_FS_DOEPCTL0> {
        using EPENA = Field<_OTG_FS_DOEPCTL0, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DOEPCTL0, 30, 1>; // EPDIS
        using SNAK = Field<_OTG_FS_DOEPCTL0, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DOEPCTL0, 26, 1>; // CNAK
        using Stall = Field<_OTG_FS_DOEPCTL0, 21, 1>; // Stall
        using SNPM = Field<_OTG_FS_DOEPCTL0, 20, 1>; // SNPM
        using EPTYP = Field<_OTG_FS_DOEPCTL0, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DOEPCTL0, 17, 1>; // NAKSTS
        using USBAEP = Field<_OTG_FS_DOEPCTL0, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DOEPCTL0, 0, 2>; // MPSIZ
    };

    // device endpoint-1 control register
    struct _OTG_FS_DOEPCTL1 : Register<OTG_FS_DEVICE_BASE + 0x320, ReadWrite, _OTG_FS_DOEPCTL1> {
        using EPENA = Field<_OTG_FS_DOEPCTL1, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DOEPCTL1, 30, 1>; // EPDIS
        using SODDFRM = Field<_OTG_FS_DOEPCTL1, 29, 1>; // SODDFRM
        using SD0PID_SEVNFRM = Field<_OTG_FS_DOEPCTL1, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DOEPCTL1, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DOEPCTL1, 26, 1>; // CNAK
        using Stall = Field<_OTG_FS_DOEPCTL1, 21, 1>; // Stall
        using SNPM = Field<_OTG_FS_DOEPCTL1, 20, 1>; // SNPM
        using EPTYP = Field<_OTG_FS_DOEPCTL1, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DOEPCTL1, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DOEPCTL1, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DOEPCTL1, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DOEPCTL1, 0, 11>; // MPSIZ
    };

    // device endpoint-2 control register
    struct _OTG_FS_DOEPCTL2 : Register<OTG_FS_DEVICE_BASE + 0x340, ReadWrite, _OTG_FS_DOEPCTL2> {
        using EPENA = Field<_OTG_FS_DOEPCTL2, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DOEPCTL2, 30, 1>; // EPDIS
        using SODDFRM = Field<_OTG_FS_DOEPCTL2, 29, 1>; // SODDFRM
        using SD0PID_SEVNFRM = Field<_OTG_FS_DOEPCTL2, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DOEPCTL2, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DOEPCTL2, 26, 1>; // CNAK
        using Stall = Field<_OTG_FS_DOEPCTL2, 21, 1>; // Stall
        using SNPM = Field<_OTG_FS_DOEPCTL2, 20, 1>; // SNPM
        using EPTYP = Field<_OTG_FS_DOEPCTL2, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DOEPCTL2, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DOEPCTL2, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DOEPCTL2, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DOEPCTL2, 0, 11>; // MPSIZ
    };

    // device endpoint-3 control register
    struct _OTG_FS_DOEPCTL3 : Register<OTG_FS_DEVICE_BASE + 0x360, ReadWrite, _OTG_FS_DOEPCTL3> {
        using EPENA = Field<_OTG_FS_DOEPCTL3, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DOEPCTL3, 30, 1>; // EPDIS
        using SODDFRM = Field<_OTG_FS_DOEPCTL3, 29, 1>; // SODDFRM
        using SD0PID_SEVNFRM = Field<_OTG_FS_DOEPCTL3, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DOEPCTL3, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DOEPCTL3, 26, 1>; // CNAK
        using Stall = Field<_OTG_FS_DOEPCTL3, 21, 1>; // Stall
        using SNPM = Field<_OTG_FS_DOEPCTL3, 20, 1>; // SNPM
        using EPTYP = Field<_OTG_FS_DOEPCTL3, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DOEPCTL3, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DOEPCTL3, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DOEPCTL3, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DOEPCTL3, 0, 11>; // MPSIZ
    };

    // device endpoint-x interrupt register
    struct _OTG_FS_DIEPINT0 : Register<OTG_FS_DEVICE_BASE + 0x108, ReadWrite, _OTG_FS_DIEPINT0> {
        using TXFE = Field<_OTG_FS_DIEPINT0, 7, 1>; // TXFE
        using INEPNE = Field<_OTG_FS_DIEPINT0, 6, 1>; // INEPNE
        using ITTXFE = Field<_OTG_FS_DIEPINT0, 4, 1>; // ITTXFE
        using TOC = Field<_OTG_FS_DIEPINT0, 3, 1>; // TOC
        using EPDISD = Field<_OTG_FS_DIEPINT0, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DIEPINT0, 0, 1>; // XFRC
    };

    // device endpoint-1 interrupt register
    struct _OTG_FS_DIEPINT1 : Register<OTG_FS_DEVICE_BASE + 0x128, ReadWrite, _OTG_FS_DIEPINT1> {
        using TXFE = Field<_OTG_FS_DIEPINT1, 7, 1>; // TXFE
        using INEPNE = Field<_OTG_FS_DIEPINT1, 6, 1>; // INEPNE
        using ITTXFE = Field<_OTG_FS_DIEPINT1, 4, 1>; // ITTXFE
        using TOC = Field<_OTG_FS_DIEPINT1, 3, 1>; // TOC
        using EPDISD = Field<_OTG_FS_DIEPINT1, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DIEPINT1, 0, 1>; // XFRC
    };

    // device endpoint-2 interrupt register
    struct _OTG_FS_DIEPINT2 : Register<OTG_FS_DEVICE_BASE + 0x148, ReadWrite, _OTG_FS_DIEPINT2> {
        using TXFE = Field<_OTG_FS_DIEPINT2, 7, 1>; // TXFE
        using INEPNE = Field<_OTG_FS_DIEPINT2, 6, 1>; // INEPNE
        using ITTXFE = Field<_OTG_FS_DIEPINT2, 4, 1>; // ITTXFE
        using TOC = Field<_OTG_FS_DIEPINT2, 3, 1>; // TOC
        using EPDISD = Field<_OTG_FS_DIEPINT2, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DIEPINT2, 0, 1>; // XFRC
    };

    // device endpoint-3 interrupt register
    struct _OTG_FS_DIEPINT3 : Register<OTG_FS_DEVICE_BASE + 0x168, ReadWrite, _OTG_FS_DIEPINT3> {
        using TXFE = Field<_OTG_FS_DIEPINT3, 7, 1>; // TXFE
        using INEPNE = Field<_OTG_FS_DIEPINT3, 6, 1>; // INEPNE
        using ITTXFE = Field<_OTG_FS_DIEPINT3, 4, 1>; // ITTXFE
        using TOC = Field<_OTG_FS_DIEPINT3, 3, 1>; // TOC
        using EPDISD = Field<_OTG_FS_DIEPINT3, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DIEPINT3, 0, 1>; // XFRC
    };

    // device endpoint-0 interrupt register
    struct _OTG_FS_DOEPINT0 : Register<OTG_FS_DEVICE_BASE + 0x308, ReadWrite, _OTG_FS_DOEPINT0> {
        using B2BSTUP = Field<_OTG_FS_DOEPINT0, 6, 1>; // B2BSTUP
        using OTEPDIS = Field<_OTG_FS_DOEPINT0, 4, 1>; // OTEPDIS
        using STUP = Field<_OTG_FS_DOEPINT0, 3, 1>; // STUP
        using EPDISD = Field<_OTG_FS_DOEPINT0, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DOEPINT0, 0, 1>; // XFRC
    };

    // device endpoint-1 interrupt register
    struct _OTG_FS_DOEPINT1 : Register<OTG_FS_DEVICE_BASE + 0x328, ReadWrite, _OTG_FS_DOEPINT1> {
        using B2BSTUP = Field<_OTG_FS_DOEPINT1, 6, 1>; // B2BSTUP
        using OTEPDIS = Field<_OTG_FS_DOEPINT1, 4, 1>; // OTEPDIS
        using STUP = Field<_OTG_FS_DOEPINT1, 3, 1>; // STUP
        using EPDISD = Field<_OTG_FS_DOEPINT1, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DOEPINT1, 0, 1>; // XFRC
    };

    // device endpoint-2 interrupt register
    struct _OTG_FS_DOEPINT2 : Register<OTG_FS_DEVICE_BASE + 0x348, ReadWrite, _OTG_FS_DOEPINT2> {
        using B2BSTUP = Field<_OTG_FS_DOEPINT2, 6, 1>; // B2BSTUP
        using OTEPDIS = Field<_OTG_FS_DOEPINT2, 4, 1>; // OTEPDIS
        using STUP = Field<_OTG_FS_DOEPINT2, 3, 1>; // STUP
        using EPDISD = Field<_OTG_FS_DOEPINT2, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DOEPINT2, 0, 1>; // XFRC
    };

    // device endpoint-3 interrupt register
    struct _OTG_FS_DOEPINT3 : Register<OTG_FS_DEVICE_BASE + 0x368, ReadWrite, _OTG_FS_DOEPINT3> {
        using B2BSTUP = Field<_OTG_FS_DOEPINT3, 6, 1>; // B2BSTUP
        using OTEPDIS = Field<_OTG_FS_DOEPINT3, 4, 1>; // OTEPDIS
        using STUP = Field<_OTG_FS_DOEPINT3, 3, 1>; // STUP
        using EPDISD = Field<_OTG_FS_DOEPINT3, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DOEPINT3, 0, 1>; // XFRC
    };

    // device endpoint-0 transfer size register
    struct _OTG_FS_DIEPTSIZ0 : Register<OTG_FS_DEVICE_BASE + 0x110, ReadWrite, _OTG_FS_DIEPTSIZ0> {
        using PKTCNT = Field<_OTG_FS_DIEPTSIZ0, 19, 2>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DIEPTSIZ0, 0, 7>; // Transfer size
    };

    // device OUT endpoint-0 transfer size register
    struct _OTG_FS_DOEPTSIZ0 : Register<OTG_FS_DEVICE_BASE + 0x310, ReadWrite, _OTG_FS_DOEPTSIZ0> {
        using STUPCNT = Field<_OTG_FS_DOEPTSIZ0, 29, 2>; // SETUP packet count
        using PKTCNT = Field<_OTG_FS_DOEPTSIZ0, 19, 1>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DOEPTSIZ0, 0, 7>; // Transfer size
    };

    // device endpoint-1 transfer size register
    struct _OTG_FS_DIEPTSIZ1 : Register<OTG_FS_DEVICE_BASE + 0x130, ReadWrite, _OTG_FS_DIEPTSIZ1> {
        using MCNT = Field<_OTG_FS_DIEPTSIZ1, 29, 2>; // Multi count
        using PKTCNT = Field<_OTG_FS_DIEPTSIZ1, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DIEPTSIZ1, 0, 19>; // Transfer size
    };

    // device endpoint-2 transfer size register
    struct _OTG_FS_DIEPTSIZ2 : Register<OTG_FS_DEVICE_BASE + 0x150, ReadWrite, _OTG_FS_DIEPTSIZ2> {
        using MCNT = Field<_OTG_FS_DIEPTSIZ2, 29, 2>; // Multi count
        using PKTCNT = Field<_OTG_FS_DIEPTSIZ2, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DIEPTSIZ2, 0, 19>; // Transfer size
    };

    // device endpoint-3 transfer size register
    struct _OTG_FS_DIEPTSIZ3 : Register<OTG_FS_DEVICE_BASE + 0x170, ReadWrite, _OTG_FS_DIEPTSIZ3> {
        using MCNT = Field<_OTG_FS_DIEPTSIZ3, 29, 2>; // Multi count
        using PKTCNT = Field<_OTG_FS_DIEPTSIZ3, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DIEPTSIZ3, 0, 19>; // Transfer size
    };

    // OTG_FS device IN endpoint transmit FIFO status register
    struct _OTG_FS_DTXFSTS0 : Register<OTG_FS_DEVICE_BASE + 0x118, ReadOnly, _OTG_FS_DTXFSTS0> {
        using INEPTFSAV = Field<_OTG_FS_DTXFSTS0, 0, 16>; // IN endpoint TxFIFO space available
    };

    // OTG_FS device IN endpoint transmit FIFO status register
    struct _OTG_FS_DTXFSTS1 : Register<OTG_FS_DEVICE_BASE + 0x138, ReadOnly, _OTG_FS_DTXFSTS1> {
        using INEPTFSAV = Field<_OTG_FS_DTXFSTS1, 0, 16>; // IN endpoint TxFIFO space available
    };

    // OTG_FS device IN endpoint transmit FIFO status register
    struct _OTG_FS_DTXFSTS2 : Register<OTG_FS_DEVICE_BASE + 0x158, ReadOnly, _OTG_FS_DTXFSTS2> {
        using INEPTFSAV = Field<_OTG_FS_DTXFSTS2, 0, 16>; // IN endpoint TxFIFO space available
    };

    // OTG_FS device IN endpoint transmit FIFO status register
    struct _OTG_FS_DTXFSTS3 : Register<OTG_FS_DEVICE_BASE + 0x178, ReadOnly, _OTG_FS_DTXFSTS3> {
        using INEPTFSAV = Field<_OTG_FS_DTXFSTS3, 0, 16>; // IN endpoint TxFIFO space available
    };

    // device OUT endpoint-1 transfer size register
    struct _OTG_FS_DOEPTSIZ1 : Register<OTG_FS_DEVICE_BASE + 0x330, ReadWrite, _OTG_FS_DOEPTSIZ1> {
        using RXDPID_STUPCNT = Field<_OTG_FS_DOEPTSIZ1, 29, 2>; // Received data PID/SETUP packet count
        using PKTCNT = Field<_OTG_FS_DOEPTSIZ1, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DOEPTSIZ1, 0, 19>; // Transfer size
    };

    // device OUT endpoint-2 transfer size register
    struct _OTG_FS_DOEPTSIZ2 : Register<OTG_FS_DEVICE_BASE + 0x350, ReadWrite, _OTG_FS_DOEPTSIZ2> {
        using RXDPID_STUPCNT = Field<_OTG_FS_DOEPTSIZ2, 29, 2>; // Received data PID/SETUP packet count
        using PKTCNT = Field<_OTG_FS_DOEPTSIZ2, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DOEPTSIZ2, 0, 19>; // Transfer size
    };

    // device OUT endpoint-3 transfer size register
    struct _OTG_FS_DOEPTSIZ3 : Register<OTG_FS_DEVICE_BASE + 0x370, ReadWrite, _OTG_FS_DOEPTSIZ3> {
        using RXDPID_STUPCNT = Field<_OTG_FS_DOEPTSIZ3, 29, 2>; // Received data PID/SETUP packet count
        using PKTCNT = Field<_OTG_FS_DOEPTSIZ3, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DOEPTSIZ3, 0, 19>; // Transfer size
    };

    // OTG device endpoint-4 control register
    struct _OTG_FS_DIEPCTL4 : Register<OTG_FS_DEVICE_BASE + 0x180, ReadWrite, _OTG_FS_DIEPCTL4> {
        using EPENA = Field<_OTG_FS_DIEPCTL4, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DIEPCTL4, 30, 1>; // EPDIS
        using SODDFRM = Field<_OTG_FS_DIEPCTL4, 29, 1>; // SODDFRM
        using SD0PID_SEVNFRM = Field<_OTG_FS_DIEPCTL4, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DIEPCTL4, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DIEPCTL4, 26, 1>; // CNAK
        using TXFNUM = Field<_OTG_FS_DIEPCTL4, 22, 4>; // TXFNUM
        using Stall = Field<_OTG_FS_DIEPCTL4, 21, 1>; // Stall
        using EPTYP = Field<_OTG_FS_DIEPCTL4, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DIEPCTL4, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DIEPCTL4, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DIEPCTL4, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DIEPCTL4, 0, 11>; // MPSIZ
    };

    // device endpoint-4 interrupt register
    struct _OTG_FS_DIEPINT4 : Register<OTG_FS_DEVICE_BASE + 0x188, ReadWrite, _OTG_FS_DIEPINT4> {
        using TXFE = Field<_OTG_FS_DIEPINT4, 7, 1>; // TXFE
        using INEPNE = Field<_OTG_FS_DIEPINT4, 6, 1>; // INEPNE
        using ITTXFE = Field<_OTG_FS_DIEPINT4, 4, 1>; // ITTXFE
        using TOC = Field<_OTG_FS_DIEPINT4, 3, 1>; // TOC
        using EPDISD = Field<_OTG_FS_DIEPINT4, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DIEPINT4, 0, 1>; // XFRC
    };

    // device endpoint-4 transfer size register
    struct _OTG_FS_DIEPTSIZ4 : Register<OTG_FS_DEVICE_BASE + 0x194, ReadWrite, _OTG_FS_DIEPTSIZ4> {
        using MCNT = Field<_OTG_FS_DIEPTSIZ4, 29, 2>; // Multi count
        using PKTCNT = Field<_OTG_FS_DIEPTSIZ4, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DIEPTSIZ4, 0, 19>; // Transfer size
    };

    // OTG_FS device IN endpoint transmit FIFO status register
    struct _OTG_FS_DTXFSTS4 : Register<OTG_FS_DEVICE_BASE + 0x19C, ReadWrite, _OTG_FS_DTXFSTS4> {
        using INEPTFSAV = Field<_OTG_FS_DTXFSTS4, 0, 16>; // IN endpoint TxFIFO space available
    };

    // OTG device endpoint-5 control register
    struct _OTG_FS_DIEPCTL5 : Register<OTG_FS_DEVICE_BASE + 0x1A0, ReadWrite, _OTG_FS_DIEPCTL5> {
        using EPENA = Field<_OTG_FS_DIEPCTL5, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DIEPCTL5, 30, 1>; // EPDIS
        using SODDFRM = Field<_OTG_FS_DIEPCTL5, 29, 1>; // SODDFRM
        using SD0PID_SEVNFRM = Field<_OTG_FS_DIEPCTL5, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DIEPCTL5, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DIEPCTL5, 26, 1>; // CNAK
        using TXFNUM = Field<_OTG_FS_DIEPCTL5, 22, 4>; // TXFNUM
        using Stall = Field<_OTG_FS_DIEPCTL5, 21, 1>; // Stall
        using EPTYP = Field<_OTG_FS_DIEPCTL5, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DIEPCTL5, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DIEPCTL5, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DIEPCTL5, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DIEPCTL5, 0, 11>; // MPSIZ
    };

    // device endpoint-5 interrupt register
    struct _OTG_FS_DIEPINT5 : Register<OTG_FS_DEVICE_BASE + 0x1A8, ReadWrite, _OTG_FS_DIEPINT5> {
        using TXFE = Field<_OTG_FS_DIEPINT5, 7, 1>; // TXFE
        using INEPNE = Field<_OTG_FS_DIEPINT5, 6, 1>; // INEPNE
        using ITTXFE = Field<_OTG_FS_DIEPINT5, 4, 1>; // ITTXFE
        using TOC = Field<_OTG_FS_DIEPINT5, 3, 1>; // TOC
        using EPDISD = Field<_OTG_FS_DIEPINT5, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DIEPINT5, 0, 1>; // XFRC
    };

    // device endpoint-5 transfer size register
    struct _OTG_FS_DIEPTSIZ55 : Register<OTG_FS_DEVICE_BASE + 0x1B0, ReadWrite, _OTG_FS_DIEPTSIZ55> {
        using MCNT = Field<_OTG_FS_DIEPTSIZ55, 29, 2>; // Multi count
        using PKTCNT = Field<_OTG_FS_DIEPTSIZ55, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DIEPTSIZ55, 0, 19>; // Transfer size
    };

    // OTG_FS device IN endpoint transmit FIFO status register
    struct _OTG_FS_DTXFSTS55 : Register<OTG_FS_DEVICE_BASE + 0x1B8, ReadWrite, _OTG_FS_DTXFSTS55> {
        using INEPTFSAV = Field<_OTG_FS_DTXFSTS55, 0, 16>; // IN endpoint TxFIFO space available
    };

    // device endpoint-4 control register
    struct _OTG_FS_DOEPCTL4 : Register<OTG_FS_DEVICE_BASE + 0x378, ReadWrite, _OTG_FS_DOEPCTL4> {
        using EPENA = Field<_OTG_FS_DOEPCTL4, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DOEPCTL4, 30, 1>; // EPDIS
        using SODDFRM = Field<_OTG_FS_DOEPCTL4, 29, 1>; // SODDFRM
        using SD0PID_SEVNFRM = Field<_OTG_FS_DOEPCTL4, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DOEPCTL4, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DOEPCTL4, 26, 1>; // CNAK
        using Stall = Field<_OTG_FS_DOEPCTL4, 21, 1>; // Stall
        using SNPM = Field<_OTG_FS_DOEPCTL4, 20, 1>; // SNPM
        using EPTYP = Field<_OTG_FS_DOEPCTL4, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DOEPCTL4, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DOEPCTL4, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DOEPCTL4, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DOEPCTL4, 0, 11>; // MPSIZ
    };

    // device endpoint-4 interrupt register
    struct _OTG_FS_DOEPINT4 : Register<OTG_FS_DEVICE_BASE + 0x380, ReadWrite, _OTG_FS_DOEPINT4> {
        using B2BSTUP = Field<_OTG_FS_DOEPINT4, 6, 1>; // B2BSTUP
        using OTEPDIS = Field<_OTG_FS_DOEPINT4, 4, 1>; // OTEPDIS
        using STUP = Field<_OTG_FS_DOEPINT4, 3, 1>; // STUP
        using EPDISD = Field<_OTG_FS_DOEPINT4, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DOEPINT4, 0, 1>; // XFRC
    };

    // device OUT endpoint-4 transfer size register
    struct _OTG_FS_DOEPTSIZ4 : Register<OTG_FS_DEVICE_BASE + 0x388, ReadWrite, _OTG_FS_DOEPTSIZ4> {
        using RXDPID_STUPCNT = Field<_OTG_FS_DOEPTSIZ4, 29, 2>; // Received data PID/SETUP packet count
        using PKTCNT = Field<_OTG_FS_DOEPTSIZ4, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DOEPTSIZ4, 0, 19>; // Transfer size
    };

    // device endpoint-5 control register
    struct _OTG_FS_DOEPCTL5 : Register<OTG_FS_DEVICE_BASE + 0x390, ReadWrite, _OTG_FS_DOEPCTL5> {
        using EPENA = Field<_OTG_FS_DOEPCTL5, 31, 1>; // EPENA
        using EPDIS = Field<_OTG_FS_DOEPCTL5, 30, 1>; // EPDIS
        using SODDFRM = Field<_OTG_FS_DOEPCTL5, 29, 1>; // SODDFRM
        using SD0PID_SEVNFRM = Field<_OTG_FS_DOEPCTL5, 28, 1>; // SD0PID/SEVNFRM
        using SNAK = Field<_OTG_FS_DOEPCTL5, 27, 1>; // SNAK
        using CNAK = Field<_OTG_FS_DOEPCTL5, 26, 1>; // CNAK
        using Stall = Field<_OTG_FS_DOEPCTL5, 21, 1>; // Stall
        using SNPM = Field<_OTG_FS_DOEPCTL5, 20, 1>; // SNPM
        using EPTYP = Field<_OTG_FS_DOEPCTL5, 18, 2>; // EPTYP
        using NAKSTS = Field<_OTG_FS_DOEPCTL5, 17, 1>; // NAKSTS
        using EONUM_DPID = Field<_OTG_FS_DOEPCTL5, 16, 1>; // EONUM/DPID
        using USBAEP = Field<_OTG_FS_DOEPCTL5, 15, 1>; // USBAEP
        using MPSIZ = Field<_OTG_FS_DOEPCTL5, 0, 11>; // MPSIZ
    };

    // device endpoint-5 interrupt register
    struct _OTG_FS_DOEPINT5 : Register<OTG_FS_DEVICE_BASE + 0x398, ReadWrite, _OTG_FS_DOEPINT5> {
        using B2BSTUP = Field<_OTG_FS_DOEPINT5, 6, 1>; // B2BSTUP
        using OTEPDIS = Field<_OTG_FS_DOEPINT5, 4, 1>; // OTEPDIS
        using STUP = Field<_OTG_FS_DOEPINT5, 3, 1>; // STUP
        using EPDISD = Field<_OTG_FS_DOEPINT5, 1, 1>; // EPDISD
        using XFRC = Field<_OTG_FS_DOEPINT5, 0, 1>; // XFRC
    };

    // device OUT endpoint-5 transfer size register
    struct _OTG_FS_DOEPTSIZ5 : Register<OTG_FS_DEVICE_BASE + 0x3A0, ReadWrite, _OTG_FS_DOEPTSIZ5> {
        using RXDPID_STUPCNT = Field<_OTG_FS_DOEPTSIZ5, 29, 2>; // Received data PID/SETUP packet count
        using PKTCNT = Field<_OTG_FS_DOEPTSIZ5, 19, 10>; // Packet count
        using XFRSIZ = Field<_OTG_FS_DOEPTSIZ5, 0, 19>; // Transfer size
    };

} // namespace OTG_FS_DEVICE

// --------------------------------------------
// OTG_FS_PWRCLK: USB on the go full speed
// Base address: 0x50000E00
// --------------------------------------------

namespace OTG_FS_PWRCLK {
    static constexpr uint32_t OTG_FS_PWRCLK_BASE = 0x50000E00;

    // OTG_FS power and clock gating control register (OTG_FS_PCGCCTL)
    struct _OTG_FS_PCGCCTL : Register<OTG_FS_PWRCLK_BASE + 0x0, ReadWrite, _OTG_FS_PCGCCTL> {
        using STPPCLK = Field<_OTG_FS_PCGCCTL, 0, 1>; // Stop PHY clock
        using GATEHCLK = Field<_OTG_FS_PCGCCTL, 1, 1>; // Gate HCLK
        using PHYSUSP = Field<_OTG_FS_PCGCCTL, 4, 1>; // PHY Suspended
    };

} // namespace OTG_FS_PWRCLK

// --------------------------------------------
// OTG_HS_HOST: USB on the go high speed
// Base address: 0x40040400
// --------------------------------------------

namespace OTG_HS_HOST {
    static constexpr uint32_t OTG_HS_HOST_BASE = 0x40040400;

    // OTG_HS host configuration register
    struct _OTG_HS_HCFG : Register<OTG_HS_HOST_BASE + 0x0, ReadWrite, _OTG_HS_HCFG> {
        using FSLSPCS = Field<_OTG_HS_HCFG, 0, 2>; // FS/LS PHY clock select
        using FSLSS = Field<_OTG_HS_HCFG, 2, 1>; // FS- and LS-only support
    };

    // OTG_HS Host frame interval register
    struct _OTG_HS_HFIR : Register<OTG_HS_HOST_BASE + 0x4, ReadWrite, _OTG_HS_HFIR> {
        using FRIVL = Field<_OTG_HS_HFIR, 0, 16>; // Frame interval
    };

    // OTG_HS host frame number/frame time remaining register
    struct _OTG_HS_HFNUM : Register<OTG_HS_HOST_BASE + 0x8, ReadOnly, _OTG_HS_HFNUM> {
        using FRNUM = Field<_OTG_HS_HFNUM, 0, 16>; // Frame number
        using FTREM = Field<_OTG_HS_HFNUM, 16, 16>; // Frame time remaining
    };

    // OTG_HS_Host periodic transmit FIFO/queue status register
    struct _OTG_HS_HPTXSTS : Register<OTG_HS_HOST_BASE + 0x10, ReadWrite, _OTG_HS_HPTXSTS> {
        using PTXFSAVL = Field<_OTG_HS_HPTXSTS, 0, 16>; // Periodic transmit data FIFO space available
        using PTXQSAV = Field<_OTG_HS_HPTXSTS, 16, 8>; // Periodic transmit request queue space available
        using PTXQTOP = Field<_OTG_HS_HPTXSTS, 24, 8>; // Top of the periodic transmit request queue
    };

    // OTG_HS Host all channels interrupt register
    struct _OTG_HS_HAINT : Register<OTG_HS_HOST_BASE + 0x14, ReadOnly, _OTG_HS_HAINT> {
        using HAINT = Field<_OTG_HS_HAINT, 0, 16>; // Channel interrupts
    };

    // OTG_HS host all channels interrupt mask register
    struct _OTG_HS_HAINTMSK : Register<OTG_HS_HOST_BASE + 0x18, ReadWrite, _OTG_HS_HAINTMSK> {
        using HAINTM = Field<_OTG_HS_HAINTMSK, 0, 16>; // Channel interrupt mask
    };

    // OTG_HS host port control and status register
    struct _OTG_HS_HPRT : Register<OTG_HS_HOST_BASE + 0x40, ReadWrite, _OTG_HS_HPRT> {
        using PCSTS = Field<_OTG_HS_HPRT, 0, 1>; // Port connect status
        using PCDET = Field<_OTG_HS_HPRT, 1, 1>; // Port connect detected
        using PENA = Field<_OTG_HS_HPRT, 2, 1>; // Port enable
        using PENCHNG = Field<_OTG_HS_HPRT, 3, 1>; // Port enable/disable change
        using POCA = Field<_OTG_HS_HPRT, 4, 1>; // Port overcurrent active
        using POCCHNG = Field<_OTG_HS_HPRT, 5, 1>; // Port overcurrent change
        using PRES = Field<_OTG_HS_HPRT, 6, 1>; // Port resume
        using PSUSP = Field<_OTG_HS_HPRT, 7, 1>; // Port suspend
        using PRST = Field<_OTG_HS_HPRT, 8, 1>; // Port reset
        using PLSTS = Field<_OTG_HS_HPRT, 10, 2>; // Port line status
        using PPWR = Field<_OTG_HS_HPRT, 12, 1>; // Port power
        using PTCTL = Field<_OTG_HS_HPRT, 13, 4>; // Port test control
        using PSPD = Field<_OTG_HS_HPRT, 17, 2>; // Port speed
    };

    // OTG_HS host channel-0 characteristics register
    struct _OTG_HS_HCCHAR0 : Register<OTG_HS_HOST_BASE + 0x100, ReadWrite, _OTG_HS_HCCHAR0> {
        using MPSIZ = Field<_OTG_HS_HCCHAR0, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR0, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR0, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR0, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR0, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR0, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR0, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR0, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR0, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR0, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-1 characteristics register
    struct _OTG_HS_HCCHAR1 : Register<OTG_HS_HOST_BASE + 0x120, ReadWrite, _OTG_HS_HCCHAR1> {
        using MPSIZ = Field<_OTG_HS_HCCHAR1, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR1, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR1, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR1, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR1, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR1, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR1, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR1, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR1, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR1, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-2 characteristics register
    struct _OTG_HS_HCCHAR2 : Register<OTG_HS_HOST_BASE + 0x140, ReadWrite, _OTG_HS_HCCHAR2> {
        using MPSIZ = Field<_OTG_HS_HCCHAR2, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR2, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR2, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR2, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR2, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR2, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR2, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR2, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR2, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR2, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-3 characteristics register
    struct _OTG_HS_HCCHAR3 : Register<OTG_HS_HOST_BASE + 0x160, ReadWrite, _OTG_HS_HCCHAR3> {
        using MPSIZ = Field<_OTG_HS_HCCHAR3, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR3, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR3, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR3, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR3, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR3, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR3, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR3, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR3, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR3, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-4 characteristics register
    struct _OTG_HS_HCCHAR4 : Register<OTG_HS_HOST_BASE + 0x180, ReadWrite, _OTG_HS_HCCHAR4> {
        using MPSIZ = Field<_OTG_HS_HCCHAR4, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR4, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR4, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR4, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR4, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR4, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR4, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR4, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR4, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR4, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-5 characteristics register
    struct _OTG_HS_HCCHAR5 : Register<OTG_HS_HOST_BASE + 0x1A0, ReadWrite, _OTG_HS_HCCHAR5> {
        using MPSIZ = Field<_OTG_HS_HCCHAR5, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR5, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR5, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR5, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR5, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR5, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR5, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR5, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR5, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR5, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-6 characteristics register
    struct _OTG_HS_HCCHAR6 : Register<OTG_HS_HOST_BASE + 0x1C0, ReadWrite, _OTG_HS_HCCHAR6> {
        using MPSIZ = Field<_OTG_HS_HCCHAR6, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR6, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR6, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR6, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR6, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR6, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR6, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR6, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR6, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR6, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-7 characteristics register
    struct _OTG_HS_HCCHAR7 : Register<OTG_HS_HOST_BASE + 0x1E0, ReadWrite, _OTG_HS_HCCHAR7> {
        using MPSIZ = Field<_OTG_HS_HCCHAR7, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR7, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR7, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR7, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR7, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR7, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR7, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR7, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR7, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR7, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-8 characteristics register
    struct _OTG_HS_HCCHAR8 : Register<OTG_HS_HOST_BASE + 0x200, ReadWrite, _OTG_HS_HCCHAR8> {
        using MPSIZ = Field<_OTG_HS_HCCHAR8, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR8, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR8, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR8, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR8, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR8, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR8, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR8, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR8, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR8, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-9 characteristics register
    struct _OTG_HS_HCCHAR9 : Register<OTG_HS_HOST_BASE + 0x220, ReadWrite, _OTG_HS_HCCHAR9> {
        using MPSIZ = Field<_OTG_HS_HCCHAR9, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR9, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR9, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR9, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR9, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR9, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR9, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR9, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR9, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR9, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-10 characteristics register
    struct _OTG_HS_HCCHAR10 : Register<OTG_HS_HOST_BASE + 0x240, ReadWrite, _OTG_HS_HCCHAR10> {
        using MPSIZ = Field<_OTG_HS_HCCHAR10, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR10, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR10, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR10, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR10, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR10, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR10, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR10, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR10, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR10, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-11 characteristics register
    struct _OTG_HS_HCCHAR11 : Register<OTG_HS_HOST_BASE + 0x260, ReadWrite, _OTG_HS_HCCHAR11> {
        using MPSIZ = Field<_OTG_HS_HCCHAR11, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR11, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR11, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR11, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR11, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR11, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR11, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR11, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR11, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR11, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-0 split control register
    struct _OTG_HS_HCSPLT0 : Register<OTG_HS_HOST_BASE + 0x104, ReadWrite, _OTG_HS_HCSPLT0> {
        using PRTADDR = Field<_OTG_HS_HCSPLT0, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT0, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT0, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT0, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT0, 31, 1>; // Split enable
    };

    // OTG_HS host channel-1 split control register
    struct _OTG_HS_HCSPLT1 : Register<OTG_HS_HOST_BASE + 0x124, ReadWrite, _OTG_HS_HCSPLT1> {
        using PRTADDR = Field<_OTG_HS_HCSPLT1, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT1, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT1, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT1, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT1, 31, 1>; // Split enable
    };

    // OTG_HS host channel-2 split control register
    struct _OTG_HS_HCSPLT2 : Register<OTG_HS_HOST_BASE + 0x144, ReadWrite, _OTG_HS_HCSPLT2> {
        using PRTADDR = Field<_OTG_HS_HCSPLT2, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT2, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT2, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT2, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT2, 31, 1>; // Split enable
    };

    // OTG_HS host channel-3 split control register
    struct _OTG_HS_HCSPLT3 : Register<OTG_HS_HOST_BASE + 0x164, ReadWrite, _OTG_HS_HCSPLT3> {
        using PRTADDR = Field<_OTG_HS_HCSPLT3, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT3, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT3, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT3, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT3, 31, 1>; // Split enable
    };

    // OTG_HS host channel-4 split control register
    struct _OTG_HS_HCSPLT4 : Register<OTG_HS_HOST_BASE + 0x184, ReadWrite, _OTG_HS_HCSPLT4> {
        using PRTADDR = Field<_OTG_HS_HCSPLT4, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT4, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT4, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT4, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT4, 31, 1>; // Split enable
    };

    // OTG_HS host channel-5 split control register
    struct _OTG_HS_HCSPLT5 : Register<OTG_HS_HOST_BASE + 0x1A4, ReadWrite, _OTG_HS_HCSPLT5> {
        using PRTADDR = Field<_OTG_HS_HCSPLT5, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT5, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT5, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT5, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT5, 31, 1>; // Split enable
    };

    // OTG_HS host channel-6 split control register
    struct _OTG_HS_HCSPLT6 : Register<OTG_HS_HOST_BASE + 0x1C4, ReadWrite, _OTG_HS_HCSPLT6> {
        using PRTADDR = Field<_OTG_HS_HCSPLT6, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT6, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT6, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT6, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT6, 31, 1>; // Split enable
    };

    // OTG_HS host channel-7 split control register
    struct _OTG_HS_HCSPLT7 : Register<OTG_HS_HOST_BASE + 0x1E4, ReadWrite, _OTG_HS_HCSPLT7> {
        using PRTADDR = Field<_OTG_HS_HCSPLT7, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT7, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT7, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT7, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT7, 31, 1>; // Split enable
    };

    // OTG_HS host channel-8 split control register
    struct _OTG_HS_HCSPLT8 : Register<OTG_HS_HOST_BASE + 0x204, ReadWrite, _OTG_HS_HCSPLT8> {
        using PRTADDR = Field<_OTG_HS_HCSPLT8, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT8, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT8, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT8, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT8, 31, 1>; // Split enable
    };

    // OTG_HS host channel-9 split control register
    struct _OTG_HS_HCSPLT9 : Register<OTG_HS_HOST_BASE + 0x224, ReadWrite, _OTG_HS_HCSPLT9> {
        using PRTADDR = Field<_OTG_HS_HCSPLT9, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT9, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT9, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT9, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT9, 31, 1>; // Split enable
    };

    // OTG_HS host channel-10 split control register
    struct _OTG_HS_HCSPLT10 : Register<OTG_HS_HOST_BASE + 0x244, ReadWrite, _OTG_HS_HCSPLT10> {
        using PRTADDR = Field<_OTG_HS_HCSPLT10, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT10, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT10, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT10, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT10, 31, 1>; // Split enable
    };

    // OTG_HS host channel-11 split control register
    struct _OTG_HS_HCSPLT11 : Register<OTG_HS_HOST_BASE + 0x264, ReadWrite, _OTG_HS_HCSPLT11> {
        using PRTADDR = Field<_OTG_HS_HCSPLT11, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT11, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT11, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT11, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT11, 31, 1>; // Split enable
    };

    // OTG_HS host channel-11 interrupt register
    struct _OTG_HS_HCINT0 : Register<OTG_HS_HOST_BASE + 0x108, ReadWrite, _OTG_HS_HCINT0> {
        using XFRC = Field<_OTG_HS_HCINT0, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT0, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT0, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT0, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT0, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT0, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT0, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT0, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT0, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT0, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT0, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-1 interrupt register
    struct _OTG_HS_HCINT1 : Register<OTG_HS_HOST_BASE + 0x128, ReadWrite, _OTG_HS_HCINT1> {
        using XFRC = Field<_OTG_HS_HCINT1, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT1, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT1, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT1, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT1, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT1, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT1, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT1, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT1, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT1, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT1, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-2 interrupt register
    struct _OTG_HS_HCINT2 : Register<OTG_HS_HOST_BASE + 0x148, ReadWrite, _OTG_HS_HCINT2> {
        using XFRC = Field<_OTG_HS_HCINT2, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT2, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT2, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT2, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT2, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT2, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT2, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT2, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT2, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT2, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT2, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-3 interrupt register
    struct _OTG_HS_HCINT3 : Register<OTG_HS_HOST_BASE + 0x168, ReadWrite, _OTG_HS_HCINT3> {
        using XFRC = Field<_OTG_HS_HCINT3, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT3, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT3, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT3, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT3, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT3, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT3, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT3, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT3, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT3, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT3, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-4 interrupt register
    struct _OTG_HS_HCINT4 : Register<OTG_HS_HOST_BASE + 0x188, ReadWrite, _OTG_HS_HCINT4> {
        using XFRC = Field<_OTG_HS_HCINT4, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT4, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT4, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT4, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT4, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT4, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT4, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT4, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT4, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT4, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT4, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-5 interrupt register
    struct _OTG_HS_HCINT5 : Register<OTG_HS_HOST_BASE + 0x1A8, ReadWrite, _OTG_HS_HCINT5> {
        using XFRC = Field<_OTG_HS_HCINT5, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT5, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT5, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT5, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT5, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT5, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT5, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT5, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT5, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT5, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT5, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-6 interrupt register
    struct _OTG_HS_HCINT6 : Register<OTG_HS_HOST_BASE + 0x1C8, ReadWrite, _OTG_HS_HCINT6> {
        using XFRC = Field<_OTG_HS_HCINT6, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT6, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT6, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT6, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT6, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT6, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT6, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT6, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT6, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT6, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT6, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-7 interrupt register
    struct _OTG_HS_HCINT7 : Register<OTG_HS_HOST_BASE + 0x1E8, ReadWrite, _OTG_HS_HCINT7> {
        using XFRC = Field<_OTG_HS_HCINT7, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT7, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT7, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT7, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT7, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT7, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT7, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT7, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT7, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT7, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT7, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-8 interrupt register
    struct _OTG_HS_HCINT8 : Register<OTG_HS_HOST_BASE + 0x208, ReadWrite, _OTG_HS_HCINT8> {
        using XFRC = Field<_OTG_HS_HCINT8, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT8, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT8, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT8, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT8, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT8, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT8, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT8, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT8, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT8, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT8, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-9 interrupt register
    struct _OTG_HS_HCINT9 : Register<OTG_HS_HOST_BASE + 0x228, ReadWrite, _OTG_HS_HCINT9> {
        using XFRC = Field<_OTG_HS_HCINT9, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT9, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT9, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT9, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT9, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT9, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT9, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT9, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT9, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT9, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT9, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-10 interrupt register
    struct _OTG_HS_HCINT10 : Register<OTG_HS_HOST_BASE + 0x248, ReadWrite, _OTG_HS_HCINT10> {
        using XFRC = Field<_OTG_HS_HCINT10, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT10, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT10, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT10, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT10, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT10, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT10, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT10, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT10, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT10, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT10, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-11 interrupt register
    struct _OTG_HS_HCINT11 : Register<OTG_HS_HOST_BASE + 0x268, ReadWrite, _OTG_HS_HCINT11> {
        using XFRC = Field<_OTG_HS_HCINT11, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT11, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT11, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT11, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT11, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT11, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT11, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT11, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT11, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT11, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT11, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-11 interrupt mask register
    struct _OTG_HS_HCINTMSK0 : Register<OTG_HS_HOST_BASE + 0x10C, ReadWrite, _OTG_HS_HCINTMSK0> {
        using XFRCM = Field<_OTG_HS_HCINTMSK0, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK0, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK0, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK0, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK0, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK0, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK0, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK0, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK0, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK0, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK0, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-1 interrupt mask register
    struct _OTG_HS_HCINTMSK1 : Register<OTG_HS_HOST_BASE + 0x12C, ReadWrite, _OTG_HS_HCINTMSK1> {
        using XFRCM = Field<_OTG_HS_HCINTMSK1, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK1, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK1, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK1, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK1, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK1, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK1, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK1, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK1, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK1, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK1, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-2 interrupt mask register
    struct _OTG_HS_HCINTMSK2 : Register<OTG_HS_HOST_BASE + 0x14C, ReadWrite, _OTG_HS_HCINTMSK2> {
        using XFRCM = Field<_OTG_HS_HCINTMSK2, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK2, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK2, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK2, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK2, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK2, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK2, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK2, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK2, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK2, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK2, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-3 interrupt mask register
    struct _OTG_HS_HCINTMSK3 : Register<OTG_HS_HOST_BASE + 0x16C, ReadWrite, _OTG_HS_HCINTMSK3> {
        using XFRCM = Field<_OTG_HS_HCINTMSK3, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK3, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK3, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK3, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK3, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK3, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK3, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK3, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK3, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK3, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK3, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-4 interrupt mask register
    struct _OTG_HS_HCINTMSK4 : Register<OTG_HS_HOST_BASE + 0x18C, ReadWrite, _OTG_HS_HCINTMSK4> {
        using XFRCM = Field<_OTG_HS_HCINTMSK4, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK4, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK4, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK4, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK4, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK4, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK4, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK4, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK4, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK4, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK4, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-5 interrupt mask register
    struct _OTG_HS_HCINTMSK5 : Register<OTG_HS_HOST_BASE + 0x1AC, ReadWrite, _OTG_HS_HCINTMSK5> {
        using XFRCM = Field<_OTG_HS_HCINTMSK5, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK5, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK5, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK5, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK5, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK5, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK5, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK5, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK5, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK5, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK5, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-6 interrupt mask register
    struct _OTG_HS_HCINTMSK6 : Register<OTG_HS_HOST_BASE + 0x1CC, ReadWrite, _OTG_HS_HCINTMSK6> {
        using XFRCM = Field<_OTG_HS_HCINTMSK6, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK6, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK6, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK6, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK6, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK6, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK6, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK6, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK6, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK6, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK6, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-7 interrupt mask register
    struct _OTG_HS_HCINTMSK7 : Register<OTG_HS_HOST_BASE + 0x1EC, ReadWrite, _OTG_HS_HCINTMSK7> {
        using XFRCM = Field<_OTG_HS_HCINTMSK7, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK7, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK7, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK7, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK7, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK7, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK7, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK7, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK7, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK7, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK7, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-8 interrupt mask register
    struct _OTG_HS_HCINTMSK8 : Register<OTG_HS_HOST_BASE + 0x20C, ReadWrite, _OTG_HS_HCINTMSK8> {
        using XFRCM = Field<_OTG_HS_HCINTMSK8, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK8, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK8, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK8, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK8, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK8, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK8, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK8, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK8, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK8, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK8, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-9 interrupt mask register
    struct _OTG_HS_HCINTMSK9 : Register<OTG_HS_HOST_BASE + 0x22C, ReadWrite, _OTG_HS_HCINTMSK9> {
        using XFRCM = Field<_OTG_HS_HCINTMSK9, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK9, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK9, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK9, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK9, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK9, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK9, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK9, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK9, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK9, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK9, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-10 interrupt mask register
    struct _OTG_HS_HCINTMSK10 : Register<OTG_HS_HOST_BASE + 0x24C, ReadWrite, _OTG_HS_HCINTMSK10> {
        using XFRCM = Field<_OTG_HS_HCINTMSK10, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK10, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK10, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK10, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK10, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK10, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK10, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK10, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK10, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK10, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK10, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-11 interrupt mask register
    struct _OTG_HS_HCINTMSK11 : Register<OTG_HS_HOST_BASE + 0x26C, ReadWrite, _OTG_HS_HCINTMSK11> {
        using XFRCM = Field<_OTG_HS_HCINTMSK11, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK11, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK11, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK11, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK11, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK11, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK11, 6, 1>; // response received interrupt mask
        using TXERRM = Field<_OTG_HS_HCINTMSK11, 7, 1>; // Transaction error mask
        using BBERRM = Field<_OTG_HS_HCINTMSK11, 8, 1>; // Babble error mask
        using FRMORM = Field<_OTG_HS_HCINTMSK11, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK11, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-11 transfer size register
    struct _OTG_HS_HCTSIZ0 : Register<OTG_HS_HOST_BASE + 0x110, ReadWrite, _OTG_HS_HCTSIZ0> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ0, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ0, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ0, 29, 2>; // Data PID
    };

    // OTG_HS host channel-1 transfer size register
    struct _OTG_HS_HCTSIZ1 : Register<OTG_HS_HOST_BASE + 0x130, ReadWrite, _OTG_HS_HCTSIZ1> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ1, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ1, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ1, 29, 2>; // Data PID
    };

    // OTG_HS host channel-2 transfer size register
    struct _OTG_HS_HCTSIZ2 : Register<OTG_HS_HOST_BASE + 0x150, ReadWrite, _OTG_HS_HCTSIZ2> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ2, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ2, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ2, 29, 2>; // Data PID
    };

    // OTG_HS host channel-3 transfer size register
    struct _OTG_HS_HCTSIZ3 : Register<OTG_HS_HOST_BASE + 0x170, ReadWrite, _OTG_HS_HCTSIZ3> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ3, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ3, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ3, 29, 2>; // Data PID
    };

    // OTG_HS host channel-4 transfer size register
    struct _OTG_HS_HCTSIZ4 : Register<OTG_HS_HOST_BASE + 0x190, ReadWrite, _OTG_HS_HCTSIZ4> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ4, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ4, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ4, 29, 2>; // Data PID
    };

    // OTG_HS host channel-5 transfer size register
    struct _OTG_HS_HCTSIZ5 : Register<OTG_HS_HOST_BASE + 0x1B0, ReadWrite, _OTG_HS_HCTSIZ5> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ5, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ5, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ5, 29, 2>; // Data PID
    };

    // OTG_HS host channel-6 transfer size register
    struct _OTG_HS_HCTSIZ6 : Register<OTG_HS_HOST_BASE + 0x1D0, ReadWrite, _OTG_HS_HCTSIZ6> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ6, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ6, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ6, 29, 2>; // Data PID
    };

    // OTG_HS host channel-7 transfer size register
    struct _OTG_HS_HCTSIZ7 : Register<OTG_HS_HOST_BASE + 0x1F0, ReadWrite, _OTG_HS_HCTSIZ7> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ7, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ7, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ7, 29, 2>; // Data PID
    };

    // OTG_HS host channel-8 transfer size register
    struct _OTG_HS_HCTSIZ8 : Register<OTG_HS_HOST_BASE + 0x210, ReadWrite, _OTG_HS_HCTSIZ8> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ8, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ8, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ8, 29, 2>; // Data PID
    };

    // OTG_HS host channel-9 transfer size register
    struct _OTG_HS_HCTSIZ9 : Register<OTG_HS_HOST_BASE + 0x230, ReadWrite, _OTG_HS_HCTSIZ9> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ9, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ9, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ9, 29, 2>; // Data PID
    };

    // OTG_HS host channel-10 transfer size register
    struct _OTG_HS_HCTSIZ10 : Register<OTG_HS_HOST_BASE + 0x250, ReadWrite, _OTG_HS_HCTSIZ10> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ10, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ10, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ10, 29, 2>; // Data PID
    };

    // OTG_HS host channel-11 transfer size register
    struct _OTG_HS_HCTSIZ11 : Register<OTG_HS_HOST_BASE + 0x270, ReadWrite, _OTG_HS_HCTSIZ11> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ11, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ11, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ11, 29, 2>; // Data PID
    };

    // OTG_HS host channel-0 DMA address register
    struct _OTG_HS_HCDMA0 : Register<OTG_HS_HOST_BASE + 0x114, ReadWrite, _OTG_HS_HCDMA0> {
        using DMAADDR = Field<_OTG_HS_HCDMA0, 0, 32>; // DMA address
    };

    // OTG_HS host channel-1 DMA address register
    struct _OTG_HS_HCDMA1 : Register<OTG_HS_HOST_BASE + 0x134, ReadWrite, _OTG_HS_HCDMA1> {
        using DMAADDR = Field<_OTG_HS_HCDMA1, 0, 32>; // DMA address
    };

    // OTG_HS host channel-2 DMA address register
    struct _OTG_HS_HCDMA2 : Register<OTG_HS_HOST_BASE + 0x154, ReadWrite, _OTG_HS_HCDMA2> {
        using DMAADDR = Field<_OTG_HS_HCDMA2, 0, 32>; // DMA address
    };

    // OTG_HS host channel-3 DMA address register
    struct _OTG_HS_HCDMA3 : Register<OTG_HS_HOST_BASE + 0x174, ReadWrite, _OTG_HS_HCDMA3> {
        using DMAADDR = Field<_OTG_HS_HCDMA3, 0, 32>; // DMA address
    };

    // OTG_HS host channel-4 DMA address register
    struct _OTG_HS_HCDMA4 : Register<OTG_HS_HOST_BASE + 0x194, ReadWrite, _OTG_HS_HCDMA4> {
        using DMAADDR = Field<_OTG_HS_HCDMA4, 0, 32>; // DMA address
    };

    // OTG_HS host channel-5 DMA address register
    struct _OTG_HS_HCDMA5 : Register<OTG_HS_HOST_BASE + 0x1B4, ReadWrite, _OTG_HS_HCDMA5> {
        using DMAADDR = Field<_OTG_HS_HCDMA5, 0, 32>; // DMA address
    };

    // OTG_HS host channel-6 DMA address register
    struct _OTG_HS_HCDMA6 : Register<OTG_HS_HOST_BASE + 0x1D4, ReadWrite, _OTG_HS_HCDMA6> {
        using DMAADDR = Field<_OTG_HS_HCDMA6, 0, 32>; // DMA address
    };

    // OTG_HS host channel-7 DMA address register
    struct _OTG_HS_HCDMA7 : Register<OTG_HS_HOST_BASE + 0x1F4, ReadWrite, _OTG_HS_HCDMA7> {
        using DMAADDR = Field<_OTG_HS_HCDMA7, 0, 32>; // DMA address
    };

    // OTG_HS host channel-8 DMA address register
    struct _OTG_HS_HCDMA8 : Register<OTG_HS_HOST_BASE + 0x214, ReadWrite, _OTG_HS_HCDMA8> {
        using DMAADDR = Field<_OTG_HS_HCDMA8, 0, 32>; // DMA address
    };

    // OTG_HS host channel-9 DMA address register
    struct _OTG_HS_HCDMA9 : Register<OTG_HS_HOST_BASE + 0x234, ReadWrite, _OTG_HS_HCDMA9> {
        using DMAADDR = Field<_OTG_HS_HCDMA9, 0, 32>; // DMA address
    };

    // OTG_HS host channel-10 DMA address register
    struct _OTG_HS_HCDMA10 : Register<OTG_HS_HOST_BASE + 0x254, ReadWrite, _OTG_HS_HCDMA10> {
        using DMAADDR = Field<_OTG_HS_HCDMA10, 0, 32>; // DMA address
    };

    // OTG_HS host channel-11 DMA address register
    struct _OTG_HS_HCDMA11 : Register<OTG_HS_HOST_BASE + 0x274, ReadWrite, _OTG_HS_HCDMA11> {
        using DMAADDR = Field<_OTG_HS_HCDMA11, 0, 32>; // DMA address
    };

    // OTG_HS host channel-12 characteristics register
    struct _OTG_HS_HCCHAR12 : Register<OTG_HS_HOST_BASE + 0x278, ReadWrite, _OTG_HS_HCCHAR12> {
        using MPSIZ = Field<_OTG_HS_HCCHAR12, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR12, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR12, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR12, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR12, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR12, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR12, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR12, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR12, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR12, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-12 split control register
    struct _OTG_HS_HCSPLT12 : Register<OTG_HS_HOST_BASE + 0x27C, ReadWrite, _OTG_HS_HCSPLT12> {
        using PRTADDR = Field<_OTG_HS_HCSPLT12, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT12, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT12, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT12, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT12, 31, 1>; // Split enable
    };

    // OTG_HS host channel-12 interrupt register
    struct _OTG_HS_HCINT12 : Register<OTG_HS_HOST_BASE + 0x280, ReadWrite, _OTG_HS_HCINT12> {
        using XFRC = Field<_OTG_HS_HCINT12, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT12, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT12, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT12, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT12, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT12, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT12, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT12, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT12, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT12, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT12, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-12 interrupt mask register
    struct _OTG_HS_HCINTMSK12 : Register<OTG_HS_HOST_BASE + 0x284, ReadWrite, _OTG_HS_HCINTMSK12> {
        using XFRCM = Field<_OTG_HS_HCINTMSK12, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK12, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK12, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK12, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK12, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK12, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK12, 6, 1>; // Response received interrupt
        using TXERRM = Field<_OTG_HS_HCINTMSK12, 7, 1>; // Transaction error
        using BBERRM = Field<_OTG_HS_HCINTMSK12, 8, 1>; // Babble error
        using FRMORM = Field<_OTG_HS_HCINTMSK12, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK12, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-12 transfer size register
    struct _OTG_HS_HCTSIZ12 : Register<OTG_HS_HOST_BASE + 0x288, ReadWrite, _OTG_HS_HCTSIZ12> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ12, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ12, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ12, 29, 2>; // Data PID
    };

    // OTG_HS host channel-12 DMA address register
    struct _OTG_HS_HCDMA12 : Register<OTG_HS_HOST_BASE + 0x28C, ReadWrite, _OTG_HS_HCDMA12> {
        using DMAADDR = Field<_OTG_HS_HCDMA12, 0, 32>; // DMA address
    };

    // OTG_HS host channel-13 characteristics register
    struct _OTG_HS_HCCHAR13 : Register<OTG_HS_HOST_BASE + 0x290, ReadWrite, _OTG_HS_HCCHAR13> {
        using MPSIZ = Field<_OTG_HS_HCCHAR13, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR13, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR13, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR13, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR13, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR13, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR13, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR13, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR13, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR13, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-13 split control register
    struct _OTG_HS_HCSPLT13 : Register<OTG_HS_HOST_BASE + 0x294, ReadWrite, _OTG_HS_HCSPLT13> {
        using PRTADDR = Field<_OTG_HS_HCSPLT13, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT13, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT13, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT13, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT13, 31, 1>; // Split enable
    };

    // OTG_HS host channel-13 interrupt register
    struct _OTG_HS_HCINT13 : Register<OTG_HS_HOST_BASE + 0x298, ReadWrite, _OTG_HS_HCINT13> {
        using XFRC = Field<_OTG_HS_HCINT13, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT13, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT13, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT13, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT13, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT13, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT13, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT13, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT13, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT13, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT13, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-13 interrupt mask register
    struct _OTG_HS_HCINTMSK13 : Register<OTG_HS_HOST_BASE + 0x29C, ReadWrite, _OTG_HS_HCINTMSK13> {
        using XFRCM = Field<_OTG_HS_HCINTMSK13, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK13, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK13, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK13, 3, 1>; // STALLM response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK13, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK13, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK13, 6, 1>; // Response received interrupt
        using TXERRM = Field<_OTG_HS_HCINTMSK13, 7, 1>; // Transaction error
        using BBERRM = Field<_OTG_HS_HCINTMSK13, 8, 1>; // Babble error
        using FRMORM = Field<_OTG_HS_HCINTMSK13, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK13, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-13 transfer size register
    struct _OTG_HS_HCTSIZ13 : Register<OTG_HS_HOST_BASE + 0x2A0, ReadWrite, _OTG_HS_HCTSIZ13> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ13, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ13, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ13, 29, 2>; // Data PID
    };

    // OTG_HS host channel-13 DMA address register
    struct _OTG_HS_HCDMA13 : Register<OTG_HS_HOST_BASE + 0x2A4, ReadWrite, _OTG_HS_HCDMA13> {
        using DMAADDR = Field<_OTG_HS_HCDMA13, 0, 32>; // DMA address
    };

    // OTG_HS host channel-14 characteristics register
    struct _OTG_HS_HCCHAR14 : Register<OTG_HS_HOST_BASE + 0x2A8, ReadWrite, _OTG_HS_HCCHAR14> {
        using MPSIZ = Field<_OTG_HS_HCCHAR14, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR14, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR14, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR14, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR14, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR14, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR14, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR14, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR14, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR14, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-14 split control register
    struct _OTG_HS_HCSPLT14 : Register<OTG_HS_HOST_BASE + 0x2AC, ReadWrite, _OTG_HS_HCSPLT14> {
        using PRTADDR = Field<_OTG_HS_HCSPLT14, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT14, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT14, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT14, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT14, 31, 1>; // Split enable
    };

    // OTG_HS host channel-14 interrupt register
    struct _OTG_HS_HCINT14 : Register<OTG_HS_HOST_BASE + 0x2B0, ReadWrite, _OTG_HS_HCINT14> {
        using XFRC = Field<_OTG_HS_HCINT14, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT14, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT14, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT14, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT14, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT14, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT14, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT14, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT14, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT14, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT14, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-14 interrupt mask register
    struct _OTG_HS_HCINTMSK14 : Register<OTG_HS_HOST_BASE + 0x2B4, ReadWrite, _OTG_HS_HCINTMSK14> {
        using XFRCM = Field<_OTG_HS_HCINTMSK14, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK14, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK14, 2, 1>; // AHB error
        using STALLM = Field<_OTG_HS_HCINTMSK14, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK14, 4, 1>; // NAKM response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK14, 5, 1>; // ACKM response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK14, 6, 1>; // Response received interrupt
        using TXERRM = Field<_OTG_HS_HCINTMSK14, 7, 1>; // Transaction error
        using BBERRM = Field<_OTG_HS_HCINTMSK14, 8, 1>; // Babble error
        using FRMORM = Field<_OTG_HS_HCINTMSK14, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK14, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-14 transfer size register
    struct _OTG_HS_HCTSIZ14 : Register<OTG_HS_HOST_BASE + 0x2B8, ReadWrite, _OTG_HS_HCTSIZ14> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ14, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ14, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ14, 29, 2>; // Data PID
    };

    // OTG_HS host channel-14 DMA address register
    struct _OTG_HS_HCDMA14 : Register<OTG_HS_HOST_BASE + 0x2BC, ReadWrite, _OTG_HS_HCDMA14> {
        using DMAADDR = Field<_OTG_HS_HCDMA14, 0, 32>; // DMA address
    };

    // OTG_HS host channel-15 characteristics register
    struct _OTG_HS_HCCHAR15 : Register<OTG_HS_HOST_BASE + 0x2C0, ReadWrite, _OTG_HS_HCCHAR15> {
        using MPSIZ = Field<_OTG_HS_HCCHAR15, 0, 11>; // Maximum packet size
        using EPNUM = Field<_OTG_HS_HCCHAR15, 11, 4>; // Endpoint number
        using EPDIR = Field<_OTG_HS_HCCHAR15, 15, 1>; // Endpoint direction
        using LSDEV = Field<_OTG_HS_HCCHAR15, 17, 1>; // Low-speed device
        using EPTYP = Field<_OTG_HS_HCCHAR15, 18, 2>; // Endpoint type
        using MC = Field<_OTG_HS_HCCHAR15, 20, 2>; // Multi Count (MC) / Error Count (EC)
        using DAD = Field<_OTG_HS_HCCHAR15, 22, 7>; // Device address
        using ODDFRM = Field<_OTG_HS_HCCHAR15, 29, 1>; // Odd frame
        using CHDIS = Field<_OTG_HS_HCCHAR15, 30, 1>; // Channel disable
        using CHENA = Field<_OTG_HS_HCCHAR15, 31, 1>; // Channel enable
    };

    // OTG_HS host channel-15 split control register
    struct _OTG_HS_HCSPLT15 : Register<OTG_HS_HOST_BASE + 0x2C4, ReadWrite, _OTG_HS_HCSPLT15> {
        using PRTADDR = Field<_OTG_HS_HCSPLT15, 0, 7>; // Port address
        using HUBADDR = Field<_OTG_HS_HCSPLT15, 7, 7>; // Hub address
        using XACTPOS = Field<_OTG_HS_HCSPLT15, 14, 2>; // XACTPOS
        using COMPLSPLT = Field<_OTG_HS_HCSPLT15, 16, 1>; // Do complete split
        using SPLITEN = Field<_OTG_HS_HCSPLT15, 31, 1>; // Split enable
    };

    // OTG_HS host channel-15 interrupt register
    struct _OTG_HS_HCINT15 : Register<OTG_HS_HOST_BASE + 0x2C8, ReadWrite, _OTG_HS_HCINT15> {
        using XFRC = Field<_OTG_HS_HCINT15, 0, 1>; // Transfer completed
        using CHH = Field<_OTG_HS_HCINT15, 1, 1>; // Channel halted
        using AHBERR = Field<_OTG_HS_HCINT15, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINT15, 3, 1>; // STALL response received interrupt
        using NAK = Field<_OTG_HS_HCINT15, 4, 1>; // NAK response received interrupt
        using ACK = Field<_OTG_HS_HCINT15, 5, 1>; // ACK response received/transmitted interrupt
        using NYET = Field<_OTG_HS_HCINT15, 6, 1>; // Response received interrupt
        using TXERR = Field<_OTG_HS_HCINT15, 7, 1>; // Transaction error
        using BBERR = Field<_OTG_HS_HCINT15, 8, 1>; // Babble error
        using FRMOR = Field<_OTG_HS_HCINT15, 9, 1>; // Frame overrun
        using DTERR = Field<_OTG_HS_HCINT15, 10, 1>; // Data toggle error
    };

    // OTG_HS host channel-15 interrupt mask register
    struct _OTG_HS_HCINTMSK15 : Register<OTG_HS_HOST_BASE + 0x2CC, ReadWrite, _OTG_HS_HCINTMSK15> {
        using XFRCM = Field<_OTG_HS_HCINTMSK15, 0, 1>; // Transfer completed mask
        using CHHM = Field<_OTG_HS_HCINTMSK15, 1, 1>; // Channel halted mask
        using AHBERR = Field<_OTG_HS_HCINTMSK15, 2, 1>; // AHB error
        using STALL = Field<_OTG_HS_HCINTMSK15, 3, 1>; // STALL response received interrupt mask
        using NAKM = Field<_OTG_HS_HCINTMSK15, 4, 1>; // NAK response received interrupt mask
        using ACKM = Field<_OTG_HS_HCINTMSK15, 5, 1>; // ACK response received/transmitted interrupt mask
        using NYET = Field<_OTG_HS_HCINTMSK15, 6, 1>; // Response received interrupt
        using TXERRM = Field<_OTG_HS_HCINTMSK15, 7, 1>; // Transaction error
        using BBERRM = Field<_OTG_HS_HCINTMSK15, 8, 1>; // Babble error
        using FRMORM = Field<_OTG_HS_HCINTMSK15, 9, 1>; // Frame overrun mask
        using DTERRM = Field<_OTG_HS_HCINTMSK15, 10, 1>; // Data toggle error mask
    };

    // OTG_HS host channel-15 transfer size register
    struct _OTG_HS_HCTSIZ15 : Register<OTG_HS_HOST_BASE + 0x2D0, ReadWrite, _OTG_HS_HCTSIZ15> {
        using XFRSIZ = Field<_OTG_HS_HCTSIZ15, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_HCTSIZ15, 19, 10>; // Packet count
        using DPID = Field<_OTG_HS_HCTSIZ15, 29, 2>; // Data PID
    };

    // OTG_HS host channel-15 DMA address register
    struct _OTG_HS_HCDMA15 : Register<OTG_HS_HOST_BASE + 0x2D4, ReadWrite, _OTG_HS_HCDMA15> {
        using DMAADDR = Field<_OTG_HS_HCDMA15, 0, 32>; // DMA address
    };

} // namespace OTG_HS_HOST

// --------------------------------------------
// OTG_HS_DEVICE: USB on the go high speed
// Base address: 0x40040800
// --------------------------------------------

namespace OTG_HS_DEVICE {
    static constexpr uint32_t OTG_HS_DEVICE_BASE = 0x40040800;

    // OTG_HS device configuration register
    struct _OTG_HS_DCFG : Register<OTG_HS_DEVICE_BASE + 0x0, ReadWrite, _OTG_HS_DCFG> {
        using DSPD = Field<_OTG_HS_DCFG, 0, 2>; // Device speed
        using NZLSOHSK = Field<_OTG_HS_DCFG, 2, 1>; // Nonzero-length status OUT handshake
        using DAD = Field<_OTG_HS_DCFG, 4, 7>; // Device address
        using PFIVL = Field<_OTG_HS_DCFG, 11, 2>; // Periodic (micro)frame interval
        using PERSCHIVL = Field<_OTG_HS_DCFG, 24, 2>; // Periodic scheduling interval
    };

    // OTG_HS device control register
    struct _OTG_HS_DCTL : Register<OTG_HS_DEVICE_BASE + 0x4, ReadWrite, _OTG_HS_DCTL> {
        using RWUSIG = Field<_OTG_HS_DCTL, 0, 1>; // Remote wakeup signaling
        using SDIS = Field<_OTG_HS_DCTL, 1, 1>; // Soft disconnect
        using GINSTS = Field<_OTG_HS_DCTL, 2, 1>; // Global IN NAK status
        using GONSTS = Field<_OTG_HS_DCTL, 3, 1>; // Global OUT NAK status
        using TCTL = Field<_OTG_HS_DCTL, 4, 3>; // Test control
        using SGINAK = Field<_OTG_HS_DCTL, 7, 1>; // Set global IN NAK
        using CGINAK = Field<_OTG_HS_DCTL, 8, 1>; // Clear global IN NAK
        using SGONAK = Field<_OTG_HS_DCTL, 9, 1>; // Set global OUT NAK
        using CGONAK = Field<_OTG_HS_DCTL, 10, 1>; // Clear global OUT NAK
        using POPRGDNE = Field<_OTG_HS_DCTL, 11, 1>; // Power-on programming done
    };

    // OTG_HS device status register
    struct _OTG_HS_DSTS : Register<OTG_HS_DEVICE_BASE + 0x8, ReadOnly, _OTG_HS_DSTS> {
        using SUSPSTS = Field<_OTG_HS_DSTS, 0, 1>; // Suspend status
        using ENUMSPD = Field<_OTG_HS_DSTS, 1, 2>; // Enumerated speed
        using EERR = Field<_OTG_HS_DSTS, 3, 1>; // Erratic error
        using FNSOF = Field<_OTG_HS_DSTS, 8, 14>; // Frame number of the received SOF
    };

    // OTG_HS device IN endpoint common interrupt mask register
    struct _OTG_HS_DIEPMSK : Register<OTG_HS_DEVICE_BASE + 0x10, ReadWrite, _OTG_HS_DIEPMSK> {
        using XFRCM = Field<_OTG_HS_DIEPMSK, 0, 1>; // Transfer completed interrupt mask
        using EPDM = Field<_OTG_HS_DIEPMSK, 1, 1>; // Endpoint disabled interrupt mask
        using TOM = Field<_OTG_HS_DIEPMSK, 3, 1>; // Timeout condition mask (nonisochronous endpoints)
        using ITTXFEMSK = Field<_OTG_HS_DIEPMSK, 4, 1>; // IN token received when TxFIFO empty mask
        using INEPNMM = Field<_OTG_HS_DIEPMSK, 5, 1>; // IN token received with EP mismatch mask
        using INEPNEM = Field<_OTG_HS_DIEPMSK, 6, 1>; // IN endpoint NAK effective mask
        using TXFURM = Field<_OTG_HS_DIEPMSK, 8, 1>; // FIFO underrun mask
        using BIM = Field<_OTG_HS_DIEPMSK, 9, 1>; // BNA interrupt mask
    };

    // OTG_HS device OUT endpoint common interrupt mask register
    struct _OTG_HS_DOEPMSK : Register<OTG_HS_DEVICE_BASE + 0x14, ReadWrite, _OTG_HS_DOEPMSK> {
        using XFRCM = Field<_OTG_HS_DOEPMSK, 0, 1>; // Transfer completed interrupt mask
        using EPDM = Field<_OTG_HS_DOEPMSK, 1, 1>; // Endpoint disabled interrupt mask
        using STUPM = Field<_OTG_HS_DOEPMSK, 3, 1>; // SETUP phase done mask
        using OTEPDM = Field<_OTG_HS_DOEPMSK, 4, 1>; // OUT token received when endpoint disabled mask
        using B2BSTUP = Field<_OTG_HS_DOEPMSK, 6, 1>; // Back-to-back SETUP packets received mask
        using OPEM = Field<_OTG_HS_DOEPMSK, 8, 1>; // OUT packet error mask
        using BOIM = Field<_OTG_HS_DOEPMSK, 9, 1>; // BNA interrupt mask
    };

    // OTG_HS device all endpoints interrupt register
    struct _OTG_HS_DAINT : Register<OTG_HS_DEVICE_BASE + 0x18, ReadOnly, _OTG_HS_DAINT> {
        using IEPINT = Field<_OTG_HS_DAINT, 0, 16>; // IN endpoint interrupt bits
        using OEPINT = Field<_OTG_HS_DAINT, 16, 16>; // OUT endpoint interrupt bits
    };

    // OTG_HS all endpoints interrupt mask register
    struct _OTG_HS_DAINTMSK : Register<OTG_HS_DEVICE_BASE + 0x1C, ReadWrite, _OTG_HS_DAINTMSK> {
        using IEPM = Field<_OTG_HS_DAINTMSK, 0, 16>; // IN EP interrupt mask bits
        using OEPM = Field<_OTG_HS_DAINTMSK, 16, 16>; // OUT EP interrupt mask bits
    };

    // OTG_HS device VBUS discharge time register
    struct _OTG_HS_DVBUSDIS : Register<OTG_HS_DEVICE_BASE + 0x28, ReadWrite, _OTG_HS_DVBUSDIS> {
        using VBUSDT = Field<_OTG_HS_DVBUSDIS, 0, 16>; // Device VBUS discharge time
    };

    // OTG_HS device VBUS pulsing time register
    struct _OTG_HS_DVBUSPULSE : Register<OTG_HS_DEVICE_BASE + 0x2C, ReadWrite, _OTG_HS_DVBUSPULSE> {
        using DVBUSP = Field<_OTG_HS_DVBUSPULSE, 0, 12>; // Device VBUS pulsing time
    };

    // OTG_HS Device threshold control register
    struct _OTG_HS_DTHRCTL : Register<OTG_HS_DEVICE_BASE + 0x30, ReadWrite, _OTG_HS_DTHRCTL> {
        using NONISOTHREN = Field<_OTG_HS_DTHRCTL, 0, 1>; // Nonisochronous IN endpoints threshold enable
        using ISOTHREN = Field<_OTG_HS_DTHRCTL, 1, 1>; // ISO IN endpoint threshold enable
        using TXTHRLEN = Field<_OTG_HS_DTHRCTL, 2, 9>; // Transmit threshold length
        using RXTHREN = Field<_OTG_HS_DTHRCTL, 16, 1>; // Receive threshold enable
        using RXTHRLEN = Field<_OTG_HS_DTHRCTL, 17, 9>; // Receive threshold length
        using ARPEN = Field<_OTG_HS_DTHRCTL, 27, 1>; // Arbiter parking enable
    };

    // OTG_HS device IN endpoint FIFO empty interrupt mask register
    struct _OTG_HS_DIEPEMPMSK : Register<OTG_HS_DEVICE_BASE + 0x34, ReadWrite, _OTG_HS_DIEPEMPMSK> {
        using INEPTXFEM = Field<_OTG_HS_DIEPEMPMSK, 0, 16>; // IN EP Tx FIFO empty interrupt mask bits
    };

    // OTG_HS device each endpoint interrupt register
    struct _OTG_HS_DEACHINT : Register<OTG_HS_DEVICE_BASE + 0x38, ReadWrite, _OTG_HS_DEACHINT> {
        using IEP1INT = Field<_OTG_HS_DEACHINT, 1, 1>; // IN endpoint 1interrupt bit
        using OEP1INT = Field<_OTG_HS_DEACHINT, 17, 1>; // OUT endpoint 1 interrupt bit
    };

    // OTG_HS device each endpoint interrupt register mask
    struct _OTG_HS_DEACHINTMSK : Register<OTG_HS_DEVICE_BASE + 0x3C, ReadWrite, _OTG_HS_DEACHINTMSK> {
        using IEP1INTM = Field<_OTG_HS_DEACHINTMSK, 1, 1>; // IN Endpoint 1 interrupt mask bit
        using OEP1INTM = Field<_OTG_HS_DEACHINTMSK, 17, 1>; // OUT Endpoint 1 interrupt mask bit
    };

    // OTG device endpoint-0 control register
    struct _OTG_HS_DIEPCTL0 : Register<OTG_HS_DEVICE_BASE + 0x100, ReadWrite, _OTG_HS_DIEPCTL0> {
        using MPSIZ = Field<_OTG_HS_DIEPCTL0, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DIEPCTL0, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DIEPCTL0, 16, 1>; // Even/odd frame
        using NAKSTS = Field<_OTG_HS_DIEPCTL0, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DIEPCTL0, 18, 2>; // Endpoint type
        using Stall = Field<_OTG_HS_DIEPCTL0, 21, 1>; // STALL handshake
        using TXFNUM = Field<_OTG_HS_DIEPCTL0, 22, 4>; // TxFIFO number
        using CNAK = Field<_OTG_HS_DIEPCTL0, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DIEPCTL0, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DIEPCTL0, 28, 1>; // Set DATA0 PID
        using SODDFRM = Field<_OTG_HS_DIEPCTL0, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DIEPCTL0, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DIEPCTL0, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-1 control register
    struct _OTG_HS_DIEPCTL1 : Register<OTG_HS_DEVICE_BASE + 0x120, ReadWrite, _OTG_HS_DIEPCTL1> {
        using MPSIZ = Field<_OTG_HS_DIEPCTL1, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DIEPCTL1, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DIEPCTL1, 16, 1>; // Even/odd frame
        using NAKSTS = Field<_OTG_HS_DIEPCTL1, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DIEPCTL1, 18, 2>; // Endpoint type
        using Stall = Field<_OTG_HS_DIEPCTL1, 21, 1>; // STALL handshake
        using TXFNUM = Field<_OTG_HS_DIEPCTL1, 22, 4>; // TxFIFO number
        using CNAK = Field<_OTG_HS_DIEPCTL1, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DIEPCTL1, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DIEPCTL1, 28, 1>; // Set DATA0 PID
        using SODDFRM = Field<_OTG_HS_DIEPCTL1, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DIEPCTL1, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DIEPCTL1, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-2 control register
    struct _OTG_HS_DIEPCTL2 : Register<OTG_HS_DEVICE_BASE + 0x140, ReadWrite, _OTG_HS_DIEPCTL2> {
        using MPSIZ = Field<_OTG_HS_DIEPCTL2, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DIEPCTL2, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DIEPCTL2, 16, 1>; // Even/odd frame
        using NAKSTS = Field<_OTG_HS_DIEPCTL2, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DIEPCTL2, 18, 2>; // Endpoint type
        using Stall = Field<_OTG_HS_DIEPCTL2, 21, 1>; // STALL handshake
        using TXFNUM = Field<_OTG_HS_DIEPCTL2, 22, 4>; // TxFIFO number
        using CNAK = Field<_OTG_HS_DIEPCTL2, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DIEPCTL2, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DIEPCTL2, 28, 1>; // Set DATA0 PID
        using SODDFRM = Field<_OTG_HS_DIEPCTL2, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DIEPCTL2, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DIEPCTL2, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-3 control register
    struct _OTG_HS_DIEPCTL3 : Register<OTG_HS_DEVICE_BASE + 0x160, ReadWrite, _OTG_HS_DIEPCTL3> {
        using MPSIZ = Field<_OTG_HS_DIEPCTL3, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DIEPCTL3, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DIEPCTL3, 16, 1>; // Even/odd frame
        using NAKSTS = Field<_OTG_HS_DIEPCTL3, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DIEPCTL3, 18, 2>; // Endpoint type
        using Stall = Field<_OTG_HS_DIEPCTL3, 21, 1>; // STALL handshake
        using TXFNUM = Field<_OTG_HS_DIEPCTL3, 22, 4>; // TxFIFO number
        using CNAK = Field<_OTG_HS_DIEPCTL3, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DIEPCTL3, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DIEPCTL3, 28, 1>; // Set DATA0 PID
        using SODDFRM = Field<_OTG_HS_DIEPCTL3, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DIEPCTL3, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DIEPCTL3, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-4 control register
    struct _OTG_HS_DIEPCTL4 : Register<OTG_HS_DEVICE_BASE + 0x180, ReadWrite, _OTG_HS_DIEPCTL4> {
        using MPSIZ = Field<_OTG_HS_DIEPCTL4, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DIEPCTL4, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DIEPCTL4, 16, 1>; // Even/odd frame
        using NAKSTS = Field<_OTG_HS_DIEPCTL4, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DIEPCTL4, 18, 2>; // Endpoint type
        using Stall = Field<_OTG_HS_DIEPCTL4, 21, 1>; // STALL handshake
        using TXFNUM = Field<_OTG_HS_DIEPCTL4, 22, 4>; // TxFIFO number
        using CNAK = Field<_OTG_HS_DIEPCTL4, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DIEPCTL4, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DIEPCTL4, 28, 1>; // Set DATA0 PID
        using SODDFRM = Field<_OTG_HS_DIEPCTL4, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DIEPCTL4, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DIEPCTL4, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-5 control register
    struct _OTG_HS_DIEPCTL5 : Register<OTG_HS_DEVICE_BASE + 0x1A0, ReadWrite, _OTG_HS_DIEPCTL5> {
        using MPSIZ = Field<_OTG_HS_DIEPCTL5, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DIEPCTL5, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DIEPCTL5, 16, 1>; // Even/odd frame
        using NAKSTS = Field<_OTG_HS_DIEPCTL5, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DIEPCTL5, 18, 2>; // Endpoint type
        using Stall = Field<_OTG_HS_DIEPCTL5, 21, 1>; // STALL handshake
        using TXFNUM = Field<_OTG_HS_DIEPCTL5, 22, 4>; // TxFIFO number
        using CNAK = Field<_OTG_HS_DIEPCTL5, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DIEPCTL5, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DIEPCTL5, 28, 1>; // Set DATA0 PID
        using SODDFRM = Field<_OTG_HS_DIEPCTL5, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DIEPCTL5, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DIEPCTL5, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-6 control register
    struct _OTG_HS_DIEPCTL6 : Register<OTG_HS_DEVICE_BASE + 0x1C0, ReadWrite, _OTG_HS_DIEPCTL6> {
        using MPSIZ = Field<_OTG_HS_DIEPCTL6, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DIEPCTL6, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DIEPCTL6, 16, 1>; // Even/odd frame
        using NAKSTS = Field<_OTG_HS_DIEPCTL6, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DIEPCTL6, 18, 2>; // Endpoint type
        using Stall = Field<_OTG_HS_DIEPCTL6, 21, 1>; // STALL handshake
        using TXFNUM = Field<_OTG_HS_DIEPCTL6, 22, 4>; // TxFIFO number
        using CNAK = Field<_OTG_HS_DIEPCTL6, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DIEPCTL6, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DIEPCTL6, 28, 1>; // Set DATA0 PID
        using SODDFRM = Field<_OTG_HS_DIEPCTL6, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DIEPCTL6, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DIEPCTL6, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-7 control register
    struct _OTG_HS_DIEPCTL7 : Register<OTG_HS_DEVICE_BASE + 0x1E0, ReadWrite, _OTG_HS_DIEPCTL7> {
        using MPSIZ = Field<_OTG_HS_DIEPCTL7, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DIEPCTL7, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DIEPCTL7, 16, 1>; // Even/odd frame
        using NAKSTS = Field<_OTG_HS_DIEPCTL7, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DIEPCTL7, 18, 2>; // Endpoint type
        using Stall = Field<_OTG_HS_DIEPCTL7, 21, 1>; // STALL handshake
        using TXFNUM = Field<_OTG_HS_DIEPCTL7, 22, 4>; // TxFIFO number
        using CNAK = Field<_OTG_HS_DIEPCTL7, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DIEPCTL7, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DIEPCTL7, 28, 1>; // Set DATA0 PID
        using SODDFRM = Field<_OTG_HS_DIEPCTL7, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DIEPCTL7, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DIEPCTL7, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-0 interrupt register
    struct _OTG_HS_DIEPINT0 : Register<OTG_HS_DEVICE_BASE + 0x108, ReadWrite, _OTG_HS_DIEPINT0> {
        using XFRC = Field<_OTG_HS_DIEPINT0, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DIEPINT0, 1, 1>; // Endpoint disabled interrupt
        using TOC = Field<_OTG_HS_DIEPINT0, 3, 1>; // Timeout condition
        using ITTXFE = Field<_OTG_HS_DIEPINT0, 4, 1>; // IN token received when TxFIFO is empty
        using INEPNE = Field<_OTG_HS_DIEPINT0, 6, 1>; // IN endpoint NAK effective
        using TXFE = Field<_OTG_HS_DIEPINT0, 7, 1>; // Transmit FIFO empty
        using TXFIFOUDRN = Field<_OTG_HS_DIEPINT0, 8, 1>; // Transmit Fifo Underrun
        using BNA = Field<_OTG_HS_DIEPINT0, 9, 1>; // Buffer not available interrupt
        using PKTDRPSTS = Field<_OTG_HS_DIEPINT0, 11, 1>; // Packet dropped status
        using BERR = Field<_OTG_HS_DIEPINT0, 12, 1>; // Babble error interrupt
        using NAK = Field<_OTG_HS_DIEPINT0, 13, 1>; // NAK interrupt
    };

    // OTG device endpoint-1 interrupt register
    struct _OTG_HS_DIEPINT1 : Register<OTG_HS_DEVICE_BASE + 0x128, ReadWrite, _OTG_HS_DIEPINT1> {
        using XFRC = Field<_OTG_HS_DIEPINT1, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DIEPINT1, 1, 1>; // Endpoint disabled interrupt
        using TOC = Field<_OTG_HS_DIEPINT1, 3, 1>; // Timeout condition
        using ITTXFE = Field<_OTG_HS_DIEPINT1, 4, 1>; // IN token received when TxFIFO is empty
        using INEPNE = Field<_OTG_HS_DIEPINT1, 6, 1>; // IN endpoint NAK effective
        using TXFE = Field<_OTG_HS_DIEPINT1, 7, 1>; // Transmit FIFO empty
        using TXFIFOUDRN = Field<_OTG_HS_DIEPINT1, 8, 1>; // Transmit Fifo Underrun
        using BNA = Field<_OTG_HS_DIEPINT1, 9, 1>; // Buffer not available interrupt
        using PKTDRPSTS = Field<_OTG_HS_DIEPINT1, 11, 1>; // Packet dropped status
        using BERR = Field<_OTG_HS_DIEPINT1, 12, 1>; // Babble error interrupt
        using NAK = Field<_OTG_HS_DIEPINT1, 13, 1>; // NAK interrupt
    };

    // OTG device endpoint-2 interrupt register
    struct _OTG_HS_DIEPINT2 : Register<OTG_HS_DEVICE_BASE + 0x148, ReadWrite, _OTG_HS_DIEPINT2> {
        using XFRC = Field<_OTG_HS_DIEPINT2, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DIEPINT2, 1, 1>; // Endpoint disabled interrupt
        using TOC = Field<_OTG_HS_DIEPINT2, 3, 1>; // Timeout condition
        using ITTXFE = Field<_OTG_HS_DIEPINT2, 4, 1>; // IN token received when TxFIFO is empty
        using INEPNE = Field<_OTG_HS_DIEPINT2, 6, 1>; // IN endpoint NAK effective
        using TXFE = Field<_OTG_HS_DIEPINT2, 7, 1>; // Transmit FIFO empty
        using TXFIFOUDRN = Field<_OTG_HS_DIEPINT2, 8, 1>; // Transmit Fifo Underrun
        using BNA = Field<_OTG_HS_DIEPINT2, 9, 1>; // Buffer not available interrupt
        using PKTDRPSTS = Field<_OTG_HS_DIEPINT2, 11, 1>; // Packet dropped status
        using BERR = Field<_OTG_HS_DIEPINT2, 12, 1>; // Babble error interrupt
        using NAK = Field<_OTG_HS_DIEPINT2, 13, 1>; // NAK interrupt
    };

    // OTG device endpoint-3 interrupt register
    struct _OTG_HS_DIEPINT3 : Register<OTG_HS_DEVICE_BASE + 0x168, ReadWrite, _OTG_HS_DIEPINT3> {
        using XFRC = Field<_OTG_HS_DIEPINT3, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DIEPINT3, 1, 1>; // Endpoint disabled interrupt
        using TOC = Field<_OTG_HS_DIEPINT3, 3, 1>; // Timeout condition
        using ITTXFE = Field<_OTG_HS_DIEPINT3, 4, 1>; // IN token received when TxFIFO is empty
        using INEPNE = Field<_OTG_HS_DIEPINT3, 6, 1>; // IN endpoint NAK effective
        using TXFE = Field<_OTG_HS_DIEPINT3, 7, 1>; // Transmit FIFO empty
        using TXFIFOUDRN = Field<_OTG_HS_DIEPINT3, 8, 1>; // Transmit Fifo Underrun
        using BNA = Field<_OTG_HS_DIEPINT3, 9, 1>; // Buffer not available interrupt
        using PKTDRPSTS = Field<_OTG_HS_DIEPINT3, 11, 1>; // Packet dropped status
        using BERR = Field<_OTG_HS_DIEPINT3, 12, 1>; // Babble error interrupt
        using NAK = Field<_OTG_HS_DIEPINT3, 13, 1>; // NAK interrupt
    };

    // OTG device endpoint-4 interrupt register
    struct _OTG_HS_DIEPINT4 : Register<OTG_HS_DEVICE_BASE + 0x188, ReadWrite, _OTG_HS_DIEPINT4> {
        using XFRC = Field<_OTG_HS_DIEPINT4, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DIEPINT4, 1, 1>; // Endpoint disabled interrupt
        using TOC = Field<_OTG_HS_DIEPINT4, 3, 1>; // Timeout condition
        using ITTXFE = Field<_OTG_HS_DIEPINT4, 4, 1>; // IN token received when TxFIFO is empty
        using INEPNE = Field<_OTG_HS_DIEPINT4, 6, 1>; // IN endpoint NAK effective
        using TXFE = Field<_OTG_HS_DIEPINT4, 7, 1>; // Transmit FIFO empty
        using TXFIFOUDRN = Field<_OTG_HS_DIEPINT4, 8, 1>; // Transmit Fifo Underrun
        using BNA = Field<_OTG_HS_DIEPINT4, 9, 1>; // Buffer not available interrupt
        using PKTDRPSTS = Field<_OTG_HS_DIEPINT4, 11, 1>; // Packet dropped status
        using BERR = Field<_OTG_HS_DIEPINT4, 12, 1>; // Babble error interrupt
        using NAK = Field<_OTG_HS_DIEPINT4, 13, 1>; // NAK interrupt
    };

    // OTG device endpoint-5 interrupt register
    struct _OTG_HS_DIEPINT5 : Register<OTG_HS_DEVICE_BASE + 0x1A8, ReadWrite, _OTG_HS_DIEPINT5> {
        using XFRC = Field<_OTG_HS_DIEPINT5, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DIEPINT5, 1, 1>; // Endpoint disabled interrupt
        using TOC = Field<_OTG_HS_DIEPINT5, 3, 1>; // Timeout condition
        using ITTXFE = Field<_OTG_HS_DIEPINT5, 4, 1>; // IN token received when TxFIFO is empty
        using INEPNE = Field<_OTG_HS_DIEPINT5, 6, 1>; // IN endpoint NAK effective
        using TXFE = Field<_OTG_HS_DIEPINT5, 7, 1>; // Transmit FIFO empty
        using TXFIFOUDRN = Field<_OTG_HS_DIEPINT5, 8, 1>; // Transmit Fifo Underrun
        using BNA = Field<_OTG_HS_DIEPINT5, 9, 1>; // Buffer not available interrupt
        using PKTDRPSTS = Field<_OTG_HS_DIEPINT5, 11, 1>; // Packet dropped status
        using BERR = Field<_OTG_HS_DIEPINT5, 12, 1>; // Babble error interrupt
        using NAK = Field<_OTG_HS_DIEPINT5, 13, 1>; // NAK interrupt
    };

    // OTG device endpoint-6 interrupt register
    struct _OTG_HS_DIEPINT6 : Register<OTG_HS_DEVICE_BASE + 0x1C8, ReadWrite, _OTG_HS_DIEPINT6> {
        using XFRC = Field<_OTG_HS_DIEPINT6, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DIEPINT6, 1, 1>; // Endpoint disabled interrupt
        using TOC = Field<_OTG_HS_DIEPINT6, 3, 1>; // Timeout condition
        using ITTXFE = Field<_OTG_HS_DIEPINT6, 4, 1>; // IN token received when TxFIFO is empty
        using INEPNE = Field<_OTG_HS_DIEPINT6, 6, 1>; // IN endpoint NAK effective
        using TXFE = Field<_OTG_HS_DIEPINT6, 7, 1>; // Transmit FIFO empty
        using TXFIFOUDRN = Field<_OTG_HS_DIEPINT6, 8, 1>; // Transmit Fifo Underrun
        using BNA = Field<_OTG_HS_DIEPINT6, 9, 1>; // Buffer not available interrupt
        using PKTDRPSTS = Field<_OTG_HS_DIEPINT6, 11, 1>; // Packet dropped status
        using BERR = Field<_OTG_HS_DIEPINT6, 12, 1>; // Babble error interrupt
        using NAK = Field<_OTG_HS_DIEPINT6, 13, 1>; // NAK interrupt
    };

    // OTG device endpoint-7 interrupt register
    struct _OTG_HS_DIEPINT7 : Register<OTG_HS_DEVICE_BASE + 0x1E8, ReadWrite, _OTG_HS_DIEPINT7> {
        using XFRC = Field<_OTG_HS_DIEPINT7, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DIEPINT7, 1, 1>; // Endpoint disabled interrupt
        using TOC = Field<_OTG_HS_DIEPINT7, 3, 1>; // Timeout condition
        using ITTXFE = Field<_OTG_HS_DIEPINT7, 4, 1>; // IN token received when TxFIFO is empty
        using INEPNE = Field<_OTG_HS_DIEPINT7, 6, 1>; // IN endpoint NAK effective
        using TXFE = Field<_OTG_HS_DIEPINT7, 7, 1>; // Transmit FIFO empty
        using TXFIFOUDRN = Field<_OTG_HS_DIEPINT7, 8, 1>; // Transmit Fifo Underrun
        using BNA = Field<_OTG_HS_DIEPINT7, 9, 1>; // Buffer not available interrupt
        using PKTDRPSTS = Field<_OTG_HS_DIEPINT7, 11, 1>; // Packet dropped status
        using BERR = Field<_OTG_HS_DIEPINT7, 12, 1>; // Babble error interrupt
        using NAK = Field<_OTG_HS_DIEPINT7, 13, 1>; // NAK interrupt
    };

    // OTG_HS device IN endpoint 0 transfer size register
    struct _OTG_HS_DIEPTSIZ0 : Register<OTG_HS_DEVICE_BASE + 0x110, ReadWrite, _OTG_HS_DIEPTSIZ0> {
        using XFRSIZ = Field<_OTG_HS_DIEPTSIZ0, 0, 7>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DIEPTSIZ0, 19, 2>; // Packet count
    };

    // OTG_HS device endpoint-1 DMA address register
    struct _OTG_HS_DIEPDMA1 : Register<OTG_HS_DEVICE_BASE + 0x114, ReadWrite, _OTG_HS_DIEPDMA1> {
        using DMAADDR = Field<_OTG_HS_DIEPDMA1, 0, 32>; // DMA address
    };

    // OTG_HS device endpoint-2 DMA address register
    struct _OTG_HS_DIEPDMA2 : Register<OTG_HS_DEVICE_BASE + 0x134, ReadWrite, _OTG_HS_DIEPDMA2> {
        using DMAADDR = Field<_OTG_HS_DIEPDMA2, 0, 32>; // DMA address
    };

    // OTG_HS device endpoint-3 DMA address register
    struct _OTG_HS_DIEPDMA3 : Register<OTG_HS_DEVICE_BASE + 0x154, ReadWrite, _OTG_HS_DIEPDMA3> {
        using DMAADDR = Field<_OTG_HS_DIEPDMA3, 0, 32>; // DMA address
    };

    // OTG_HS device endpoint-4 DMA address register
    struct _OTG_HS_DIEPDMA4 : Register<OTG_HS_DEVICE_BASE + 0x174, ReadWrite, _OTG_HS_DIEPDMA4> {
        using DMAADDR = Field<_OTG_HS_DIEPDMA4, 0, 32>; // DMA address
    };

    // OTG_HS device endpoint-5 DMA address register
    struct _OTG_HS_DIEPDMA5 : Register<OTG_HS_DEVICE_BASE + 0x194, ReadWrite, _OTG_HS_DIEPDMA5> {
        using DMAADDR = Field<_OTG_HS_DIEPDMA5, 0, 32>; // DMA address
    };

    // OTG_HS device IN endpoint transmit FIFO status register
    struct _OTG_HS_DTXFSTS0 : Register<OTG_HS_DEVICE_BASE + 0x118, ReadOnly, _OTG_HS_DTXFSTS0> {
        using INEPTFSAV = Field<_OTG_HS_DTXFSTS0, 0, 16>; // IN endpoint TxFIFO space avail
    };

    // OTG_HS device IN endpoint transmit FIFO status register
    struct _OTG_HS_DTXFSTS1 : Register<OTG_HS_DEVICE_BASE + 0x138, ReadOnly, _OTG_HS_DTXFSTS1> {
        using INEPTFSAV = Field<_OTG_HS_DTXFSTS1, 0, 16>; // IN endpoint TxFIFO space avail
    };

    // OTG_HS device IN endpoint transmit FIFO status register
    struct _OTG_HS_DTXFSTS2 : Register<OTG_HS_DEVICE_BASE + 0x158, ReadOnly, _OTG_HS_DTXFSTS2> {
        using INEPTFSAV = Field<_OTG_HS_DTXFSTS2, 0, 16>; // IN endpoint TxFIFO space avail
    };

    // OTG_HS device IN endpoint transmit FIFO status register
    struct _OTG_HS_DTXFSTS3 : Register<OTG_HS_DEVICE_BASE + 0x178, ReadOnly, _OTG_HS_DTXFSTS3> {
        using INEPTFSAV = Field<_OTG_HS_DTXFSTS3, 0, 16>; // IN endpoint TxFIFO space avail
    };

    // OTG_HS device IN endpoint transmit FIFO status register
    struct _OTG_HS_DTXFSTS4 : Register<OTG_HS_DEVICE_BASE + 0x198, ReadOnly, _OTG_HS_DTXFSTS4> {
        using INEPTFSAV = Field<_OTG_HS_DTXFSTS4, 0, 16>; // IN endpoint TxFIFO space avail
    };

    // OTG_HS device IN endpoint transmit FIFO status register
    struct _OTG_HS_DTXFSTS5 : Register<OTG_HS_DEVICE_BASE + 0x1B8, ReadOnly, _OTG_HS_DTXFSTS5> {
        using INEPTFSAV = Field<_OTG_HS_DTXFSTS5, 0, 16>; // IN endpoint TxFIFO space avail
    };

    // OTG_HS device endpoint transfer size register
    struct _OTG_HS_DIEPTSIZ1 : Register<OTG_HS_DEVICE_BASE + 0x130, ReadWrite, _OTG_HS_DIEPTSIZ1> {
        using XFRSIZ = Field<_OTG_HS_DIEPTSIZ1, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DIEPTSIZ1, 19, 10>; // Packet count
        using MCNT = Field<_OTG_HS_DIEPTSIZ1, 29, 2>; // Multi count
    };

    // OTG_HS device endpoint transfer size register
    struct _OTG_HS_DIEPTSIZ2 : Register<OTG_HS_DEVICE_BASE + 0x150, ReadWrite, _OTG_HS_DIEPTSIZ2> {
        using XFRSIZ = Field<_OTG_HS_DIEPTSIZ2, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DIEPTSIZ2, 19, 10>; // Packet count
        using MCNT = Field<_OTG_HS_DIEPTSIZ2, 29, 2>; // Multi count
    };

    // OTG_HS device endpoint transfer size register
    struct _OTG_HS_DIEPTSIZ3 : Register<OTG_HS_DEVICE_BASE + 0x170, ReadWrite, _OTG_HS_DIEPTSIZ3> {
        using XFRSIZ = Field<_OTG_HS_DIEPTSIZ3, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DIEPTSIZ3, 19, 10>; // Packet count
        using MCNT = Field<_OTG_HS_DIEPTSIZ3, 29, 2>; // Multi count
    };

    // OTG_HS device endpoint transfer size register
    struct _OTG_HS_DIEPTSIZ4 : Register<OTG_HS_DEVICE_BASE + 0x190, ReadWrite, _OTG_HS_DIEPTSIZ4> {
        using XFRSIZ = Field<_OTG_HS_DIEPTSIZ4, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DIEPTSIZ4, 19, 10>; // Packet count
        using MCNT = Field<_OTG_HS_DIEPTSIZ4, 29, 2>; // Multi count
    };

    // OTG_HS device endpoint transfer size register
    struct _OTG_HS_DIEPTSIZ5 : Register<OTG_HS_DEVICE_BASE + 0x1B0, ReadWrite, _OTG_HS_DIEPTSIZ5> {
        using XFRSIZ = Field<_OTG_HS_DIEPTSIZ5, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DIEPTSIZ5, 19, 10>; // Packet count
        using MCNT = Field<_OTG_HS_DIEPTSIZ5, 29, 2>; // Multi count
    };

    // OTG_HS device control OUT endpoint 0 control register
    struct _OTG_HS_DOEPCTL0 : Register<OTG_HS_DEVICE_BASE + 0x300, ReadWrite, _OTG_HS_DOEPCTL0> {
        using MPSIZ = Field<_OTG_HS_DOEPCTL0, 0, 2>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DOEPCTL0, 15, 1>; // USB active endpoint
        using NAKSTS = Field<_OTG_HS_DOEPCTL0, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DOEPCTL0, 18, 2>; // Endpoint type
        using SNPM = Field<_OTG_HS_DOEPCTL0, 20, 1>; // Snoop mode
        using Stall = Field<_OTG_HS_DOEPCTL0, 21, 1>; // STALL handshake
        using CNAK = Field<_OTG_HS_DOEPCTL0, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DOEPCTL0, 27, 1>; // Set NAK
        using EPDIS = Field<_OTG_HS_DOEPCTL0, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DOEPCTL0, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-1 control register
    struct _OTG_HS_DOEPCTL1 : Register<OTG_HS_DEVICE_BASE + 0x320, ReadWrite, _OTG_HS_DOEPCTL1> {
        using MPSIZ = Field<_OTG_HS_DOEPCTL1, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DOEPCTL1, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DOEPCTL1, 16, 1>; // Even odd frame/Endpoint data PID
        using NAKSTS = Field<_OTG_HS_DOEPCTL1, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DOEPCTL1, 18, 2>; // Endpoint type
        using SNPM = Field<_OTG_HS_DOEPCTL1, 20, 1>; // Snoop mode
        using Stall = Field<_OTG_HS_DOEPCTL1, 21, 1>; // STALL handshake
        using CNAK = Field<_OTG_HS_DOEPCTL1, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DOEPCTL1, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DOEPCTL1, 28, 1>; // Set DATA0 PID/Set even frame
        using SODDFRM = Field<_OTG_HS_DOEPCTL1, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DOEPCTL1, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DOEPCTL1, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-2 control register
    struct _OTG_HS_DOEPCTL2 : Register<OTG_HS_DEVICE_BASE + 0x340, ReadWrite, _OTG_HS_DOEPCTL2> {
        using MPSIZ = Field<_OTG_HS_DOEPCTL2, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DOEPCTL2, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DOEPCTL2, 16, 1>; // Even odd frame/Endpoint data PID
        using NAKSTS = Field<_OTG_HS_DOEPCTL2, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DOEPCTL2, 18, 2>; // Endpoint type
        using SNPM = Field<_OTG_HS_DOEPCTL2, 20, 1>; // Snoop mode
        using Stall = Field<_OTG_HS_DOEPCTL2, 21, 1>; // STALL handshake
        using CNAK = Field<_OTG_HS_DOEPCTL2, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DOEPCTL2, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DOEPCTL2, 28, 1>; // Set DATA0 PID/Set even frame
        using SODDFRM = Field<_OTG_HS_DOEPCTL2, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DOEPCTL2, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DOEPCTL2, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-3 control register
    struct _OTG_HS_DOEPCTL3 : Register<OTG_HS_DEVICE_BASE + 0x360, ReadWrite, _OTG_HS_DOEPCTL3> {
        using MPSIZ = Field<_OTG_HS_DOEPCTL3, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DOEPCTL3, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DOEPCTL3, 16, 1>; // Even odd frame/Endpoint data PID
        using NAKSTS = Field<_OTG_HS_DOEPCTL3, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DOEPCTL3, 18, 2>; // Endpoint type
        using SNPM = Field<_OTG_HS_DOEPCTL3, 20, 1>; // Snoop mode
        using Stall = Field<_OTG_HS_DOEPCTL3, 21, 1>; // STALL handshake
        using CNAK = Field<_OTG_HS_DOEPCTL3, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DOEPCTL3, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DOEPCTL3, 28, 1>; // Set DATA0 PID/Set even frame
        using SODDFRM = Field<_OTG_HS_DOEPCTL3, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DOEPCTL3, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DOEPCTL3, 31, 1>; // Endpoint enable
    };

    // OTG_HS device endpoint-0 interrupt register
    struct _OTG_HS_DOEPINT0 : Register<OTG_HS_DEVICE_BASE + 0x308, ReadWrite, _OTG_HS_DOEPINT0> {
        using XFRC = Field<_OTG_HS_DOEPINT0, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DOEPINT0, 1, 1>; // Endpoint disabled interrupt
        using STUP = Field<_OTG_HS_DOEPINT0, 3, 1>; // SETUP phase done
        using OTEPDIS = Field<_OTG_HS_DOEPINT0, 4, 1>; // OUT token received when endpoint disabled
        using B2BSTUP = Field<_OTG_HS_DOEPINT0, 6, 1>; // Back-to-back SETUP packets received
        using NYET = Field<_OTG_HS_DOEPINT0, 14, 1>; // NYET interrupt
    };

    // OTG_HS device endpoint-1 interrupt register
    struct _OTG_HS_DOEPINT1 : Register<OTG_HS_DEVICE_BASE + 0x328, ReadWrite, _OTG_HS_DOEPINT1> {
        using XFRC = Field<_OTG_HS_DOEPINT1, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DOEPINT1, 1, 1>; // Endpoint disabled interrupt
        using STUP = Field<_OTG_HS_DOEPINT1, 3, 1>; // SETUP phase done
        using OTEPDIS = Field<_OTG_HS_DOEPINT1, 4, 1>; // OUT token received when endpoint disabled
        using B2BSTUP = Field<_OTG_HS_DOEPINT1, 6, 1>; // Back-to-back SETUP packets received
        using NYET = Field<_OTG_HS_DOEPINT1, 14, 1>; // NYET interrupt
    };

    // OTG_HS device endpoint-2 interrupt register
    struct _OTG_HS_DOEPINT2 : Register<OTG_HS_DEVICE_BASE + 0x348, ReadWrite, _OTG_HS_DOEPINT2> {
        using XFRC = Field<_OTG_HS_DOEPINT2, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DOEPINT2, 1, 1>; // Endpoint disabled interrupt
        using STUP = Field<_OTG_HS_DOEPINT2, 3, 1>; // SETUP phase done
        using OTEPDIS = Field<_OTG_HS_DOEPINT2, 4, 1>; // OUT token received when endpoint disabled
        using B2BSTUP = Field<_OTG_HS_DOEPINT2, 6, 1>; // Back-to-back SETUP packets received
        using NYET = Field<_OTG_HS_DOEPINT2, 14, 1>; // NYET interrupt
    };

    // OTG_HS device endpoint-3 interrupt register
    struct _OTG_HS_DOEPINT3 : Register<OTG_HS_DEVICE_BASE + 0x368, ReadWrite, _OTG_HS_DOEPINT3> {
        using XFRC = Field<_OTG_HS_DOEPINT3, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DOEPINT3, 1, 1>; // Endpoint disabled interrupt
        using STUP = Field<_OTG_HS_DOEPINT3, 3, 1>; // SETUP phase done
        using OTEPDIS = Field<_OTG_HS_DOEPINT3, 4, 1>; // OUT token received when endpoint disabled
        using B2BSTUP = Field<_OTG_HS_DOEPINT3, 6, 1>; // Back-to-back SETUP packets received
        using NYET = Field<_OTG_HS_DOEPINT3, 14, 1>; // NYET interrupt
    };

    // OTG_HS device endpoint-4 interrupt register
    struct _OTG_HS_DOEPINT4 : Register<OTG_HS_DEVICE_BASE + 0x388, ReadWrite, _OTG_HS_DOEPINT4> {
        using XFRC = Field<_OTG_HS_DOEPINT4, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DOEPINT4, 1, 1>; // Endpoint disabled interrupt
        using STUP = Field<_OTG_HS_DOEPINT4, 3, 1>; // SETUP phase done
        using OTEPDIS = Field<_OTG_HS_DOEPINT4, 4, 1>; // OUT token received when endpoint disabled
        using B2BSTUP = Field<_OTG_HS_DOEPINT4, 6, 1>; // Back-to-back SETUP packets received
        using NYET = Field<_OTG_HS_DOEPINT4, 14, 1>; // NYET interrupt
    };

    // OTG_HS device endpoint-5 interrupt register
    struct _OTG_HS_DOEPINT5 : Register<OTG_HS_DEVICE_BASE + 0x3A8, ReadWrite, _OTG_HS_DOEPINT5> {
        using XFRC = Field<_OTG_HS_DOEPINT5, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DOEPINT5, 1, 1>; // Endpoint disabled interrupt
        using STUP = Field<_OTG_HS_DOEPINT5, 3, 1>; // SETUP phase done
        using OTEPDIS = Field<_OTG_HS_DOEPINT5, 4, 1>; // OUT token received when endpoint disabled
        using B2BSTUP = Field<_OTG_HS_DOEPINT5, 6, 1>; // Back-to-back SETUP packets received
        using NYET = Field<_OTG_HS_DOEPINT5, 14, 1>; // NYET interrupt
    };

    // OTG_HS device endpoint-6 interrupt register
    struct _OTG_HS_DOEPINT6 : Register<OTG_HS_DEVICE_BASE + 0x3C8, ReadWrite, _OTG_HS_DOEPINT6> {
        using XFRC = Field<_OTG_HS_DOEPINT6, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DOEPINT6, 1, 1>; // Endpoint disabled interrupt
        using STUP = Field<_OTG_HS_DOEPINT6, 3, 1>; // SETUP phase done
        using OTEPDIS = Field<_OTG_HS_DOEPINT6, 4, 1>; // OUT token received when endpoint disabled
        using B2BSTUP = Field<_OTG_HS_DOEPINT6, 6, 1>; // Back-to-back SETUP packets received
        using NYET = Field<_OTG_HS_DOEPINT6, 14, 1>; // NYET interrupt
    };

    // OTG_HS device endpoint-7 interrupt register
    struct _OTG_HS_DOEPINT7 : Register<OTG_HS_DEVICE_BASE + 0x3E8, ReadWrite, _OTG_HS_DOEPINT7> {
        using XFRC = Field<_OTG_HS_DOEPINT7, 0, 1>; // Transfer completed interrupt
        using EPDISD = Field<_OTG_HS_DOEPINT7, 1, 1>; // Endpoint disabled interrupt
        using STUP = Field<_OTG_HS_DOEPINT7, 3, 1>; // SETUP phase done
        using OTEPDIS = Field<_OTG_HS_DOEPINT7, 4, 1>; // OUT token received when endpoint disabled
        using B2BSTUP = Field<_OTG_HS_DOEPINT7, 6, 1>; // Back-to-back SETUP packets received
        using NYET = Field<_OTG_HS_DOEPINT7, 14, 1>; // NYET interrupt
    };

    // OTG_HS device endpoint-0 transfer size register
    struct _OTG_HS_DOEPTSIZ0 : Register<OTG_HS_DEVICE_BASE + 0x310, ReadWrite, _OTG_HS_DOEPTSIZ0> {
        using XFRSIZ = Field<_OTG_HS_DOEPTSIZ0, 0, 7>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DOEPTSIZ0, 19, 1>; // Packet count
        using STUPCNT = Field<_OTG_HS_DOEPTSIZ0, 29, 2>; // SETUP packet count
    };

    // OTG_HS device endpoint-1 transfer size register
    struct _OTG_HS_DOEPTSIZ1 : Register<OTG_HS_DEVICE_BASE + 0x330, ReadWrite, _OTG_HS_DOEPTSIZ1> {
        using XFRSIZ = Field<_OTG_HS_DOEPTSIZ1, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DOEPTSIZ1, 19, 10>; // Packet count
        using RXDPID_STUPCNT = Field<_OTG_HS_DOEPTSIZ1, 29, 2>; // Received data PID/SETUP packet count
    };

    // OTG_HS device endpoint-2 transfer size register
    struct _OTG_HS_DOEPTSIZ2 : Register<OTG_HS_DEVICE_BASE + 0x350, ReadWrite, _OTG_HS_DOEPTSIZ2> {
        using XFRSIZ = Field<_OTG_HS_DOEPTSIZ2, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DOEPTSIZ2, 19, 10>; // Packet count
        using RXDPID_STUPCNT = Field<_OTG_HS_DOEPTSIZ2, 29, 2>; // Received data PID/SETUP packet count
    };

    // OTG_HS device endpoint-3 transfer size register
    struct _OTG_HS_DOEPTSIZ3 : Register<OTG_HS_DEVICE_BASE + 0x370, ReadWrite, _OTG_HS_DOEPTSIZ3> {
        using XFRSIZ = Field<_OTG_HS_DOEPTSIZ3, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DOEPTSIZ3, 19, 10>; // Packet count
        using RXDPID_STUPCNT = Field<_OTG_HS_DOEPTSIZ3, 29, 2>; // Received data PID/SETUP packet count
    };

    // OTG_HS device endpoint-4 transfer size register
    struct _OTG_HS_DOEPTSIZ4 : Register<OTG_HS_DEVICE_BASE + 0x390, ReadWrite, _OTG_HS_DOEPTSIZ4> {
        using XFRSIZ = Field<_OTG_HS_DOEPTSIZ4, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DOEPTSIZ4, 19, 10>; // Packet count
        using RXDPID_STUPCNT = Field<_OTG_HS_DOEPTSIZ4, 29, 2>; // Received data PID/SETUP packet count
    };

    // OTG_HS device endpoint transfer size register
    struct _OTG_HS_DIEPTSIZ6 : Register<OTG_HS_DEVICE_BASE + 0x1A0, ReadWrite, _OTG_HS_DIEPTSIZ6> {
        using XFRSIZ = Field<_OTG_HS_DIEPTSIZ6, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DIEPTSIZ6, 19, 10>; // Packet count
        using MCNT = Field<_OTG_HS_DIEPTSIZ6, 29, 2>; // Multi count
    };

    // OTG_HS device IN endpoint transmit FIFO status register
    struct _OTG_HS_DTXFSTS6 : Register<OTG_HS_DEVICE_BASE + 0x1A4, ReadWrite, _OTG_HS_DTXFSTS6> {
        using INEPTFSAV = Field<_OTG_HS_DTXFSTS6, 0, 16>; // IN endpoint TxFIFO space avail
    };

    // OTG_HS device endpoint transfer size register
    struct _OTG_HS_DIEPTSIZ7 : Register<OTG_HS_DEVICE_BASE + 0x1A8, ReadWrite, _OTG_HS_DIEPTSIZ7> {
        using XFRSIZ = Field<_OTG_HS_DIEPTSIZ7, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DIEPTSIZ7, 19, 10>; // Packet count
        using MCNT = Field<_OTG_HS_DIEPTSIZ7, 29, 2>; // Multi count
    };

    // OTG_HS device IN endpoint transmit FIFO status register
    struct _OTG_HS_DTXFSTS7 : Register<OTG_HS_DEVICE_BASE + 0x1AC, ReadWrite, _OTG_HS_DTXFSTS7> {
        using INEPTFSAV = Field<_OTG_HS_DTXFSTS7, 0, 16>; // IN endpoint TxFIFO space avail
    };

    // OTG device endpoint-4 control register
    struct _OTG_HS_DOEPCTL4 : Register<OTG_HS_DEVICE_BASE + 0x380, ReadWrite, _OTG_HS_DOEPCTL4> {
        using MPSIZ = Field<_OTG_HS_DOEPCTL4, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DOEPCTL4, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DOEPCTL4, 16, 1>; // Even odd frame/Endpoint data PID
        using NAKSTS = Field<_OTG_HS_DOEPCTL4, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DOEPCTL4, 18, 2>; // Endpoint type
        using SNPM = Field<_OTG_HS_DOEPCTL4, 20, 1>; // Snoop mode
        using Stall = Field<_OTG_HS_DOEPCTL4, 21, 1>; // STALL handshake
        using CNAK = Field<_OTG_HS_DOEPCTL4, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DOEPCTL4, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DOEPCTL4, 28, 1>; // Set DATA0 PID/Set even frame
        using SODDFRM = Field<_OTG_HS_DOEPCTL4, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DOEPCTL4, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DOEPCTL4, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-5 control register
    struct _OTG_HS_DOEPCTL5 : Register<OTG_HS_DEVICE_BASE + 0x3A0, ReadWrite, _OTG_HS_DOEPCTL5> {
        using MPSIZ = Field<_OTG_HS_DOEPCTL5, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DOEPCTL5, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DOEPCTL5, 16, 1>; // Even odd frame/Endpoint data PID
        using NAKSTS = Field<_OTG_HS_DOEPCTL5, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DOEPCTL5, 18, 2>; // Endpoint type
        using SNPM = Field<_OTG_HS_DOEPCTL5, 20, 1>; // Snoop mode
        using Stall = Field<_OTG_HS_DOEPCTL5, 21, 1>; // STALL handshake
        using CNAK = Field<_OTG_HS_DOEPCTL5, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DOEPCTL5, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DOEPCTL5, 28, 1>; // Set DATA0 PID/Set even frame
        using SODDFRM = Field<_OTG_HS_DOEPCTL5, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DOEPCTL5, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DOEPCTL5, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-6 control register
    struct _OTG_HS_DOEPCTL6 : Register<OTG_HS_DEVICE_BASE + 0x3C0, ReadWrite, _OTG_HS_DOEPCTL6> {
        using MPSIZ = Field<_OTG_HS_DOEPCTL6, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DOEPCTL6, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DOEPCTL6, 16, 1>; // Even odd frame/Endpoint data PID
        using NAKSTS = Field<_OTG_HS_DOEPCTL6, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DOEPCTL6, 18, 2>; // Endpoint type
        using SNPM = Field<_OTG_HS_DOEPCTL6, 20, 1>; // Snoop mode
        using Stall = Field<_OTG_HS_DOEPCTL6, 21, 1>; // STALL handshake
        using CNAK = Field<_OTG_HS_DOEPCTL6, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DOEPCTL6, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DOEPCTL6, 28, 1>; // Set DATA0 PID/Set even frame
        using SODDFRM = Field<_OTG_HS_DOEPCTL6, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DOEPCTL6, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DOEPCTL6, 31, 1>; // Endpoint enable
    };

    // OTG device endpoint-7 control register
    struct _OTG_HS_DOEPCTL7 : Register<OTG_HS_DEVICE_BASE + 0x3E0, ReadWrite, _OTG_HS_DOEPCTL7> {
        using MPSIZ = Field<_OTG_HS_DOEPCTL7, 0, 11>; // Maximum packet size
        using USBAEP = Field<_OTG_HS_DOEPCTL7, 15, 1>; // USB active endpoint
        using EONUM_DPID = Field<_OTG_HS_DOEPCTL7, 16, 1>; // Even odd frame/Endpoint data PID
        using NAKSTS = Field<_OTG_HS_DOEPCTL7, 17, 1>; // NAK status
        using EPTYP = Field<_OTG_HS_DOEPCTL7, 18, 2>; // Endpoint type
        using SNPM = Field<_OTG_HS_DOEPCTL7, 20, 1>; // Snoop mode
        using Stall = Field<_OTG_HS_DOEPCTL7, 21, 1>; // STALL handshake
        using CNAK = Field<_OTG_HS_DOEPCTL7, 26, 1>; // Clear NAK
        using SNAK = Field<_OTG_HS_DOEPCTL7, 27, 1>; // Set NAK
        using SD0PID_SEVNFRM = Field<_OTG_HS_DOEPCTL7, 28, 1>; // Set DATA0 PID/Set even frame
        using SODDFRM = Field<_OTG_HS_DOEPCTL7, 29, 1>; // Set odd frame
        using EPDIS = Field<_OTG_HS_DOEPCTL7, 30, 1>; // Endpoint disable
        using EPENA = Field<_OTG_HS_DOEPCTL7, 31, 1>; // Endpoint enable
    };

    // OTG_HS device endpoint-5 transfer size register
    struct _OTG_HS_DOEPTSIZ5 : Register<OTG_HS_DEVICE_BASE + 0x3B0, ReadWrite, _OTG_HS_DOEPTSIZ5> {
        using XFRSIZ = Field<_OTG_HS_DOEPTSIZ5, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DOEPTSIZ5, 19, 10>; // Packet count
        using RXDPID_STUPCNT = Field<_OTG_HS_DOEPTSIZ5, 29, 2>; // Received data PID/SETUP packet count
    };

    // OTG_HS device endpoint-6 transfer size register
    struct _OTG_HS_DOEPTSIZ6 : Register<OTG_HS_DEVICE_BASE + 0x3D0, ReadWrite, _OTG_HS_DOEPTSIZ6> {
        using XFRSIZ = Field<_OTG_HS_DOEPTSIZ6, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DOEPTSIZ6, 19, 10>; // Packet count
        using RXDPID_STUPCNT = Field<_OTG_HS_DOEPTSIZ6, 29, 2>; // Received data PID/SETUP packet count
    };

    // OTG_HS device endpoint-7 transfer size register
    struct _OTG_HS_DOEPTSIZ7 : Register<OTG_HS_DEVICE_BASE + 0x3F0, ReadWrite, _OTG_HS_DOEPTSIZ7> {
        using XFRSIZ = Field<_OTG_HS_DOEPTSIZ7, 0, 19>; // Transfer size
        using PKTCNT = Field<_OTG_HS_DOEPTSIZ7, 19, 10>; // Packet count
        using RXDPID_STUPCNT = Field<_OTG_HS_DOEPTSIZ7, 29, 2>; // Received data PID/SETUP packet count
    };

} // namespace OTG_HS_DEVICE

// --------------------------------------------
// OTG_HS_PWRCLK: USB on the go high speed
// Base address: 0x40040E00
// --------------------------------------------

namespace OTG_HS_PWRCLK {
    static constexpr uint32_t OTG_HS_PWRCLK_BASE = 0x40040E00;

    // Power and clock gating control register
    struct _OTG_HS_PCGCR : Register<OTG_HS_PWRCLK_BASE + 0x0, ReadWrite, _OTG_HS_PCGCR> {
        using STPPCLK = Field<_OTG_HS_PCGCR, 0, 1>; // Stop PHY clock
        using GATEHCLK = Field<_OTG_HS_PCGCR, 1, 1>; // Gate HCLK
        using PHYSUSP = Field<_OTG_HS_PCGCR, 4, 1>; // PHY suspended
    };

} // namespace OTG_HS_PWRCLK

// --------------------------------------------
// DSI: DSI Host
// Base address: 0x40016C00
// --------------------------------------------

namespace DSI {
    static constexpr uint32_t DSI_BASE = 0x40016C00;

    // DSI Host Version Register
    struct _DSI_VR : Register<DSI_BASE + 0x0, ReadOnly, _DSI_VR> {
        using VERSION = Field<_DSI_VR, 0, 32>; // Version of the DSI Host
    };

    // DSI Host Control Register
    struct _DSI_CR : Register<DSI_BASE + 0x4, ReadWrite, _DSI_CR> {
        using EN = Field<_DSI_CR, 0, 1>; // Enable
    };

    // DSI HOST Clock Control Register
    struct _DSI_CCR : Register<DSI_BASE + 0x8, ReadWrite, _DSI_CCR> {
        using TXECKDIV = Field<_DSI_CCR, 0, 8>; // TX Escape Clock Division
        using TOCKDIV = Field<_DSI_CCR, 8, 8>; // Timeout Clock Division
    };

    // DSI Host LTDC VCID Register
    struct _DSI_LVCIDR : Register<DSI_BASE + 0xC, ReadWrite, _DSI_LVCIDR> {
        using VCID = Field<_DSI_LVCIDR, 0, 2>; // Virtual Channel ID
    };

    // DSI Host LTDC Color Coding Register
    struct _DSI_LCOLCR : Register<DSI_BASE + 0x10, ReadWrite, _DSI_LCOLCR> {
        using COLC = Field<_DSI_LCOLCR, 0, 4>; // Color Coding
        using LPE = Field<_DSI_LCOLCR, 8, 1>; // Loosely Packet Enable
    };

    // DSI Host LTDC Polarity Configuration Register
    struct _DSI_LPCR : Register<DSI_BASE + 0x14, ReadWrite, _DSI_LPCR> {
        using DEP = Field<_DSI_LPCR, 0, 1>; // Data Enable Polarity
        using VSP = Field<_DSI_LPCR, 1, 1>; // VSYNC Polarity
        using HSP = Field<_DSI_LPCR, 2, 1>; // HSYNC Polarity
    };

    // DSI Host Low-Power mode Configuration Register
    struct _DSI_LPMCR : Register<DSI_BASE + 0x18, ReadWrite, _DSI_LPMCR> {
        using VLPSIZE = Field<_DSI_LPMCR, 0, 8>; // VACT Largest Packet Size
        using LPSIZE = Field<_DSI_LPMCR, 16, 8>; // Largest Packet Size
    };

    // DSI Host Protocol Configuration Register
    struct _DSI_PCR : Register<DSI_BASE + 0x2C, ReadWrite, _DSI_PCR> {
        using ETTXE = Field<_DSI_PCR, 0, 1>; // EoTp Transmission Enable
        using ETRXE = Field<_DSI_PCR, 1, 1>; // EoTp Reception Enable
        using BTAE = Field<_DSI_PCR, 2, 1>; // Bus Turn Around Enable
        using ECCRXE = Field<_DSI_PCR, 3, 1>; // ECC Reception Enable
        using CRCRXE = Field<_DSI_PCR, 4, 1>; // CRC Reception Enable
    };

    // DSI Host Generic VCID Register
    struct _DSI_GVCIDR : Register<DSI_BASE + 0x30, ReadWrite, _DSI_GVCIDR> {
        using VCID = Field<_DSI_GVCIDR, 0, 2>; // Virtual Channel ID
    };

    // DSI Host mode Configuration Register
    struct _DSI_MCR : Register<DSI_BASE + 0x34, ReadWrite, _DSI_MCR> {
        using CMDM = Field<_DSI_MCR, 0, 1>; // Command mode
    };

    // DSI Host Video mode Configuration Register
    struct _DSI_VMCR : Register<DSI_BASE + 0x38, ReadWrite, _DSI_VMCR> {
        using VMT = Field<_DSI_VMCR, 0, 2>; // Video mode Type
        using LPVSAE = Field<_DSI_VMCR, 8, 1>; // Low-Power Vertical Sync Active Enable
        using LPVBPE = Field<_DSI_VMCR, 9, 1>; // Low-power Vertical Back-Porch Enable
        using LPVFPE = Field<_DSI_VMCR, 10, 1>; // Low-power Vertical Front-porch Enable
        using LPVAE = Field<_DSI_VMCR, 11, 1>; // Low-Power Vertical Active Enable
        using LPHBPE = Field<_DSI_VMCR, 12, 1>; // Low-Power Horizontal Back-Porch Enable
        using LPHFPE = Field<_DSI_VMCR, 13, 1>; // Low-Power Horizontal Front-Porch Enable
        using FBTAAE = Field<_DSI_VMCR, 14, 1>; // Frame Bus-Turn-Around Acknowledge Enable
        using LPCE = Field<_DSI_VMCR, 15, 1>; // Low-Power Command Enable
        using PGE = Field<_DSI_VMCR, 16, 1>; // Pattern Generator Enable
        using PGM = Field<_DSI_VMCR, 20, 1>; // Pattern Generator mode
        using PGO = Field<_DSI_VMCR, 24, 1>; // Pattern Generator Orientation
    };

    // DSI Host Video Packet Configuration Register
    struct _DSI_VPCR : Register<DSI_BASE + 0x3C, ReadWrite, _DSI_VPCR> {
        using VPSIZE = Field<_DSI_VPCR, 0, 14>; // Video Packet Size
    };

    // DSI Host Video Chunks Configuration Register
    struct _DSI_VCCR : Register<DSI_BASE + 0x40, ReadWrite, _DSI_VCCR> {
        using NUMC = Field<_DSI_VCCR, 0, 13>; // Number of Chunks
    };

    // DSI Host Video Null Packet Configuration Register
    struct _DSI_VNPCR : Register<DSI_BASE + 0x44, ReadWrite, _DSI_VNPCR> {
        using NPSIZE = Field<_DSI_VNPCR, 0, 13>; // Null Packet Size
    };

    // DSI Host Video HSA Configuration Register
    struct _DSI_VHSACR : Register<DSI_BASE + 0x48, ReadWrite, _DSI_VHSACR> {
        using HSA = Field<_DSI_VHSACR, 0, 12>; // Horizontal Synchronism Active duration
    };

    // DSI Host Video HBP Configuration Register
    struct _DSI_VHBPCR : Register<DSI_BASE + 0x4C, ReadWrite, _DSI_VHBPCR> {
        using HBP = Field<_DSI_VHBPCR, 0, 12>; // Horizontal Back-Porch duration
    };

    // DSI Host Video Line Configuration Register
    struct _DSI_VLCR : Register<DSI_BASE + 0x50, ReadWrite, _DSI_VLCR> {
        using HLINE = Field<_DSI_VLCR, 0, 15>; // Horizontal Line duration
    };

    // DSI Host Video VSA Configuration Register
    struct _DSI_VVSACR : Register<DSI_BASE + 0x54, ReadWrite, _DSI_VVSACR> {
        using VSA = Field<_DSI_VVSACR, 0, 10>; // Vertical Synchronism Active duration
    };

    // DSI Host Video VBP Configuration Register
    struct _DSI_VVBPCR : Register<DSI_BASE + 0x58, ReadWrite, _DSI_VVBPCR> {
        using VBP = Field<_DSI_VVBPCR, 0, 10>; // Vertical Back-Porch duration
    };

    // DSI Host Video VFP Configuration Register
    struct _DSI_VVFPCR : Register<DSI_BASE + 0x5C, ReadWrite, _DSI_VVFPCR> {
        using VFP = Field<_DSI_VVFPCR, 0, 10>; // Vertical Front-Porch duration
    };

    // DSI Host Video VA Configuration Register
    struct _DSI_VVACR : Register<DSI_BASE + 0x60, ReadWrite, _DSI_VVACR> {
        using VA = Field<_DSI_VVACR, 0, 14>; // Vertical Active duration
    };

    // DSI Host LTDC Command Configuration Register
    struct _DSI_LCCR : Register<DSI_BASE + 0x64, ReadWrite, _DSI_LCCR> {
        using CMDSIZE = Field<_DSI_LCCR, 0, 16>; // Command Size
    };

    // DSI Host Command mode Configuration Register
    struct _DSI_CMCR : Register<DSI_BASE + 0x68, ReadWrite, _DSI_CMCR> {
        using TEARE = Field<_DSI_CMCR, 0, 1>; // Tearing Effect Acknowledge Request Enable
        using ARE = Field<_DSI_CMCR, 1, 1>; // Acknowledge Request Enable
        using GSW0TX = Field<_DSI_CMCR, 8, 1>; // Generic Short Write Zero parameters Transmission
        using GSW1TX = Field<_DSI_CMCR, 9, 1>; // Generic Short Write One parameters Transmission
        using GSW2TX = Field<_DSI_CMCR, 10, 1>; // Generic Short Write Two parameters Transmission
        using GSR0TX = Field<_DSI_CMCR, 11, 1>; // Generic Short Read Zero parameters Transmission
        using GSR1TX = Field<_DSI_CMCR, 12, 1>; // Generic Short Read One parameters Transmission
        using GSR2TX = Field<_DSI_CMCR, 13, 1>; // Generic Short Read Two parameters Transmission
        using GLWTX = Field<_DSI_CMCR, 14, 1>; // Generic Long Write Transmission
        using DSW0TX = Field<_DSI_CMCR, 16, 1>; // DCS Short Write Zero parameter Transmission
        using DSW1TX = Field<_DSI_CMCR, 17, 1>; // DCS Short Read One parameter Transmission
        using DSR0TX = Field<_DSI_CMCR, 18, 1>; // DCS Short Read Zero parameter Transmission
        using DLWTX = Field<_DSI_CMCR, 19, 1>; // DCS Long Write Transmission
        using MRDPS = Field<_DSI_CMCR, 24, 1>; // Maximum Read Packet Size
    };

    // DSI Host Generic Header Configuration Register
    struct _DSI_GHCR : Register<DSI_BASE + 0x6C, ReadWrite, _DSI_GHCR> {
        using DT = Field<_DSI_GHCR, 0, 6>; // Type
        using VCID = Field<_DSI_GHCR, 6, 2>; // Channel
        using WCLSB = Field<_DSI_GHCR, 8, 8>; // WordCount LSB
        using WCMSB = Field<_DSI_GHCR, 16, 8>; // WordCount MSB
    };

    // DSI Host Generic Payload Data Register
    struct _DSI_GPDR : Register<DSI_BASE + 0x70, ReadWrite, _DSI_GPDR> {
        using DATA1 = Field<_DSI_GPDR, 0, 8>; // Payload Byte 1
        using DATA2 = Field<_DSI_GPDR, 8, 8>; // Payload Byte 2
        using DATA3 = Field<_DSI_GPDR, 16, 8>; // Payload Byte 3
        using DATA4 = Field<_DSI_GPDR, 24, 8>; // Payload Byte 4
    };

    // DSI Host Generic Packet Status Register
    struct _DSI_GPSR : Register<DSI_BASE + 0x74, ReadOnly, _DSI_GPSR> {
        using CMDFE = Field<_DSI_GPSR, 0, 1>; // Command FIFO Empty
        using CMDFF = Field<_DSI_GPSR, 1, 1>; // Command FIFO Full
        using PWRFE = Field<_DSI_GPSR, 2, 1>; // Payload Write FIFO Empty
        using PWRFF = Field<_DSI_GPSR, 3, 1>; // Payload Write FIFO Full
        using PRDFE = Field<_DSI_GPSR, 4, 1>; // Payload Read FIFO Empty
        using PRDFF = Field<_DSI_GPSR, 5, 1>; // Payload Read FIFO Full
        using RCB = Field<_DSI_GPSR, 6, 1>; // Read Command Busy
    };

    // DSI Host Timeout Counter Configuration Register 0
    struct _DSI_TCCR0 : Register<DSI_BASE + 0x78, ReadWrite, _DSI_TCCR0> {
        using LPRX_TOCNT = Field<_DSI_TCCR0, 0, 16>; // Low-power Reception Timeout Counter
        using HSTX_TOCNT = Field<_DSI_TCCR0, 16, 16>; // High-Speed Transmission Timeout Counter
    };

    // DSI Host Timeout Counter Configuration Register 1
    struct _DSI_TCCR1 : Register<DSI_BASE + 0x7C, ReadWrite, _DSI_TCCR1> {
        using HSRD_TOCNT = Field<_DSI_TCCR1, 0, 16>; // High-Speed Read Timeout Counter
    };

    // DSI Host Timeout Counter Configuration Register 2
    struct _DSI_TCCR2 : Register<DSI_BASE + 0x80, ReadWrite, _DSI_TCCR2> {
        using LPRD_TOCNT = Field<_DSI_TCCR2, 0, 16>; // Low-Power Read Timeout Counter
    };

    // DSI Host Timeout Counter Configuration Register 3
    struct _DSI_TCCR3 : Register<DSI_BASE + 0x84, ReadWrite, _DSI_TCCR3> {
        using HSWR_TOCNT = Field<_DSI_TCCR3, 0, 16>; // High-Speed Write Timeout Counter
        using PM = Field<_DSI_TCCR3, 24, 1>; // Presp mode
    };

    // DSI Host Timeout Counter Configuration Register 4
    struct _DSI_TCCR4 : Register<DSI_BASE + 0x88, ReadWrite, _DSI_TCCR4> {
        using LSWR_TOCNT = Field<_DSI_TCCR4, 0, 16>; // Low-Power Write Timeout Counter
    };

    // DSI Host Timeout Counter Configuration Register 5
    struct _DSI_TCCR5 : Register<DSI_BASE + 0x8C, ReadWrite, _DSI_TCCR5> {
        using BTA_TOCNT = Field<_DSI_TCCR5, 0, 16>; // Bus-Turn-Around Timeout Counter
    };

    // DSI Host Clock Lane Configuration Register
    struct _DSI_CLCR : Register<DSI_BASE + 0x94, ReadWrite, _DSI_CLCR> {
        using DPCC = Field<_DSI_CLCR, 0, 1>; // D-PHY Clock Control
        using ACR = Field<_DSI_CLCR, 1, 1>; // Automatic Clock lane Control
    };

    // DSI Host Clock Lane Timer Configuration Register
    struct _DSI_CLTCR : Register<DSI_BASE + 0x98, ReadWrite, _DSI_CLTCR> {
        using LP2HS_TIME = Field<_DSI_CLTCR, 0, 10>; // Low-Power to High-Speed Time
        using HS2LP_TIME = Field<_DSI_CLTCR, 16, 10>; // High-Speed to Low-Power Time
    };

    // DSI Host Data Lane Timer Configuration Register
    struct _DSI_DLTCR : Register<DSI_BASE + 0x9C, ReadWrite, _DSI_DLTCR> {
        using MRD_TIME = Field<_DSI_DLTCR, 0, 15>; // Maximum Read Time
        using LP2HS_TIME = Field<_DSI_DLTCR, 16, 8>; // Low-Power To High-Speed Time
        using HS2LP_TIME = Field<_DSI_DLTCR, 24, 8>; // High-Speed To Low-Power Time
    };

    // DSI Host PHY Control Register
    struct _DSI_PCTLR : Register<DSI_BASE + 0xA0, ReadWrite, _DSI_PCTLR> {
        using DEN = Field<_DSI_PCTLR, 1, 1>; // Digital Enable
        using CKE = Field<_DSI_PCTLR, 2, 1>; // Clock Enable
    };

    // DSI Host PHY Configuration Register
    struct _DSI_PCONFR : Register<DSI_BASE + 0xA4, ReadWrite, _DSI_PCONFR> {
        using NL = Field<_DSI_PCONFR, 0, 2>; // Number of Lanes
        using SW_TIME = Field<_DSI_PCONFR, 8, 8>; // Stop Wait Time
    };

    // DSI Host PHY ULPS Control Register
    struct _DSI_PUCR : Register<DSI_BASE + 0xA8, ReadWrite, _DSI_PUCR> {
        using URCL = Field<_DSI_PUCR, 0, 1>; // ULPS Request on Clock Lane
        using UECL = Field<_DSI_PUCR, 1, 1>; // ULPS Exit on Clock Lane
        using URDL = Field<_DSI_PUCR, 2, 1>; // ULPS Request on Data Lane
        using UEDL = Field<_DSI_PUCR, 3, 1>; // ULPS Exit on Data Lane
    };

    // DSI Host PHY TX Triggers Configuration Register
    struct _DSI_PTTCR : Register<DSI_BASE + 0xAC, ReadWrite, _DSI_PTTCR> {
        using TX_TRIG = Field<_DSI_PTTCR, 0, 4>; // Transmission Trigger
    };

    // DSI Host PHY Status Register
    struct _DSI_PSR : Register<DSI_BASE + 0xB0, ReadOnly, _DSI_PSR> {
        using PD = Field<_DSI_PSR, 1, 1>; // PHY Direction
        using PSSC = Field<_DSI_PSR, 2, 1>; // PHY Stop State Clock lane
        using UANC = Field<_DSI_PSR, 3, 1>; // ULPS Active Not Clock lane
        using PSS0 = Field<_DSI_PSR, 4, 1>; // PHY Stop State lane 0
        using UAN0 = Field<_DSI_PSR, 5, 1>; // ULPS Active Not lane 1
        using RUE0 = Field<_DSI_PSR, 6, 1>; // RX ULPS Escape lane 0
        using PSS1 = Field<_DSI_PSR, 7, 1>; // PHY Stop State lane 1
        using UAN1 = Field<_DSI_PSR, 8, 1>; // ULPS Active Not lane 1
    };

    // DSI Host Interrupt & Status Register 0
    struct _DSI_ISR0 : Register<DSI_BASE + 0xBC, ReadOnly, _DSI_ISR0> {
        using AE0 = Field<_DSI_ISR0, 0, 1>; // Acknowledge Error 0
        using AE1 = Field<_DSI_ISR0, 1, 1>; // Acknowledge Error 1
        using AE2 = Field<_DSI_ISR0, 2, 1>; // Acknowledge Error 2
        using AE3 = Field<_DSI_ISR0, 3, 1>; // Acknowledge Error 3
        using AE4 = Field<_DSI_ISR0, 4, 1>; // Acknowledge Error 4
        using AE5 = Field<_DSI_ISR0, 5, 1>; // Acknowledge Error 5
        using AE6 = Field<_DSI_ISR0, 6, 1>; // Acknowledge Error 6
        using AE7 = Field<_DSI_ISR0, 7, 1>; // Acknowledge Error 7
        using AE8 = Field<_DSI_ISR0, 8, 1>; // Acknowledge Error 8
        using AE9 = Field<_DSI_ISR0, 9, 1>; // Acknowledge Error 9
        using AE10 = Field<_DSI_ISR0, 10, 1>; // Acknowledge Error 10
        using AE11 = Field<_DSI_ISR0, 11, 1>; // Acknowledge Error 11
        using AE12 = Field<_DSI_ISR0, 12, 1>; // Acknowledge Error 12
        using AE13 = Field<_DSI_ISR0, 13, 1>; // Acknowledge Error 13
        using AE14 = Field<_DSI_ISR0, 14, 1>; // Acknowledge Error 14
        using AE15 = Field<_DSI_ISR0, 15, 1>; // Acknowledge Error 15
        using PE0 = Field<_DSI_ISR0, 16, 1>; // PHY Error 0
        using PE1 = Field<_DSI_ISR0, 17, 1>; // PHY Error 1
        using PE2 = Field<_DSI_ISR0, 18, 1>; // PHY Error 2
        using PE3 = Field<_DSI_ISR0, 19, 1>; // PHY Error 3
        using PE4 = Field<_DSI_ISR0, 20, 1>; // PHY Error 4
    };

    // DSI Host Interrupt & Status Register 1
    struct _DSI_ISR1 : Register<DSI_BASE + 0xC0, ReadOnly, _DSI_ISR1> {
        using TOHSTX = Field<_DSI_ISR1, 0, 1>; // Timeout High-Speed Transmission
        using TOLPRX = Field<_DSI_ISR1, 1, 1>; // Timeout Low-Power Reception
        using ECCSE = Field<_DSI_ISR1, 2, 1>; // ECC Single-bit Error
        using ECCME = Field<_DSI_ISR1, 3, 1>; // ECC Multi-bit Error
        using CRCE = Field<_DSI_ISR1, 4, 1>; // CRC Error
        using PSE = Field<_DSI_ISR1, 5, 1>; // Packet Size Error
        using EOTPE = Field<_DSI_ISR1, 6, 1>; // EoTp Error
        using LPWRE = Field<_DSI_ISR1, 7, 1>; // LTDC Payload Write Error
        using GCWRE = Field<_DSI_ISR1, 8, 1>; // Generic Command Write Error
        using GPWRE = Field<_DSI_ISR1, 9, 1>; // Generic Payload Write Error
        using GPTXE = Field<_DSI_ISR1, 10, 1>; // Generic Payload Transmit Error
        using GPRDE = Field<_DSI_ISR1, 11, 1>; // Generic Payload Read Error
        using GPRXE = Field<_DSI_ISR1, 12, 1>; // Generic Payload Receive Error
    };

    // DSI Host Interrupt Enable Register 0
    struct _DSI_IER0 : Register<DSI_BASE + 0xC4, ReadWrite, _DSI_IER0> {
        using AE0IE = Field<_DSI_IER0, 0, 1>; // Acknowledge Error 0 Interrupt Enable
        using AE1IE = Field<_DSI_IER0, 1, 1>; // Acknowledge Error 1 Interrupt Enable
        using AE2IE = Field<_DSI_IER0, 2, 1>; // Acknowledge Error 2 Interrupt Enable
        using AE3IE = Field<_DSI_IER0, 3, 1>; // Acknowledge Error 3 Interrupt Enable
        using AE4IE = Field<_DSI_IER0, 4, 1>; // Acknowledge Error 4 Interrupt Enable
        using AE5IE = Field<_DSI_IER0, 5, 1>; // Acknowledge Error 5 Interrupt Enable
        using AE6IE = Field<_DSI_IER0, 6, 1>; // Acknowledge Error 6 Interrupt Enable
        using AE7IE = Field<_DSI_IER0, 7, 1>; // Acknowledge Error 7 Interrupt Enable
        using AE8IE = Field<_DSI_IER0, 8, 1>; // Acknowledge Error 8 Interrupt Enable
        using AE9IE = Field<_DSI_IER0, 9, 1>; // Acknowledge Error 9 Interrupt Enable
        using AE10IE = Field<_DSI_IER0, 10, 1>; // Acknowledge Error 10 Interrupt Enable
        using AE11IE = Field<_DSI_IER0, 11, 1>; // Acknowledge Error 11 Interrupt Enable
        using AE12IE = Field<_DSI_IER0, 12, 1>; // Acknowledge Error 12 Interrupt Enable
        using AE13IE = Field<_DSI_IER0, 13, 1>; // Acknowledge Error 13 Interrupt Enable
        using AE14IE = Field<_DSI_IER0, 14, 1>; // Acknowledge Error 14 Interrupt Enable
        using AE15IE = Field<_DSI_IER0, 15, 1>; // Acknowledge Error 15 Interrupt Enable
        using PE0IE = Field<_DSI_IER0, 16, 1>; // PHY Error 0 Interrupt Enable
        using PE1IE = Field<_DSI_IER0, 17, 1>; // PHY Error 1 Interrupt Enable
        using PE2IE = Field<_DSI_IER0, 18, 1>; // PHY Error 2 Interrupt Enable
        using PE3IE = Field<_DSI_IER0, 19, 1>; // PHY Error 3 Interrupt Enable
        using PE4IE = Field<_DSI_IER0, 20, 1>; // PHY Error 4 Interrupt Enable
    };

    // DSI Host Interrupt Enable Register 1
    struct _DSI_IER1 : Register<DSI_BASE + 0xC8, ReadWrite, _DSI_IER1> {
        using TOHSTXIE = Field<_DSI_IER1, 0, 1>; // Timeout High-Speed Transmission Interrupt Enable
        using TOLPRXIE = Field<_DSI_IER1, 1, 1>; // Timeout Low-Power Reception Interrupt Enable
        using ECCSEIE = Field<_DSI_IER1, 2, 1>; // ECC Single-bit Error Interrupt Enable
        using ECCMEIE = Field<_DSI_IER1, 3, 1>; // ECC Multi-bit Error Interrupt Enable
        using CRCEIE = Field<_DSI_IER1, 4, 1>; // CRC Error Interrupt Enable
        using PSEIE = Field<_DSI_IER1, 5, 1>; // Packet Size Error Interrupt Enable
        using EOTPEIE = Field<_DSI_IER1, 6, 1>; // EoTp Error Interrupt Enable
        using LPWREIE = Field<_DSI_IER1, 7, 1>; // LTDC Payload Write Error Interrupt Enable
        using GCWREIE = Field<_DSI_IER1, 8, 1>; // Generic Command Write Error Interrupt Enable
        using GPWREIE = Field<_DSI_IER1, 9, 1>; // Generic Payload Write Error Interrupt Enable
        using GPTXEIE = Field<_DSI_IER1, 10, 1>; // Generic Payload Transmit Error Interrupt Enable
        using GPRDEIE = Field<_DSI_IER1, 11, 1>; // Generic Payload Read Error Interrupt Enable
        using GPRXEIE = Field<_DSI_IER1, 12, 1>; // Generic Payload Receive Error Interrupt Enable
    };

    // DSI Host Force Interrupt Register 0
    struct _DSI_FIR0 : Register<DSI_BASE + 0xD8, WriteOnly, _DSI_FIR0> {
        using FAE0 = Field<_DSI_FIR0, 0, 1>; // Force Acknowledge Error 0
        using FAE1 = Field<_DSI_FIR0, 1, 1>; // Force Acknowledge Error 1
        using FAE2 = Field<_DSI_FIR0, 2, 1>; // Force Acknowledge Error 2
        using FAE3 = Field<_DSI_FIR0, 3, 1>; // Force Acknowledge Error 3
        using FAE4 = Field<_DSI_FIR0, 4, 1>; // Force Acknowledge Error 4
        using FAE5 = Field<_DSI_FIR0, 5, 1>; // Force Acknowledge Error 5
        using FAE6 = Field<_DSI_FIR0, 6, 1>; // Force Acknowledge Error 6
        using FAE7 = Field<_DSI_FIR0, 7, 1>; // Force Acknowledge Error 7
        using FAE8 = Field<_DSI_FIR0, 8, 1>; // Force Acknowledge Error 8
        using FAE9 = Field<_DSI_FIR0, 9, 1>; // Force Acknowledge Error 9
        using FAE10 = Field<_DSI_FIR0, 10, 1>; // Force Acknowledge Error 10
        using FAE11 = Field<_DSI_FIR0, 11, 1>; // Force Acknowledge Error 11
        using FAE12 = Field<_DSI_FIR0, 12, 1>; // Force Acknowledge Error 12
        using FAE13 = Field<_DSI_FIR0, 13, 1>; // Force Acknowledge Error 13
        using FAE14 = Field<_DSI_FIR0, 14, 1>; // Force Acknowledge Error 14
        using FAE15 = Field<_DSI_FIR0, 15, 1>; // Force Acknowledge Error 15
        using FPE0 = Field<_DSI_FIR0, 16, 1>; // Force PHY Error 0
        using FPE1 = Field<_DSI_FIR0, 17, 1>; // Force PHY Error 1
        using FPE2 = Field<_DSI_FIR0, 18, 1>; // Force PHY Error 2
        using FPE3 = Field<_DSI_FIR0, 19, 1>; // Force PHY Error 3
        using FPE4 = Field<_DSI_FIR0, 20, 1>; // Force PHY Error 4
    };

    // DSI Host Force Interrupt Register 1
    struct _DSI_FIR1 : Register<DSI_BASE + 0xDC, WriteOnly, _DSI_FIR1> {
        using FTOHSTX = Field<_DSI_FIR1, 0, 1>; // Force Timeout High-Speed Transmission
        using FTOLPRX = Field<_DSI_FIR1, 1, 1>; // Force Timeout Low-Power Reception
        using FECCSE = Field<_DSI_FIR1, 2, 1>; // Force ECC Single-bit Error
        using FECCME = Field<_DSI_FIR1, 3, 1>; // Force ECC Multi-bit Error
        using FCRCE = Field<_DSI_FIR1, 4, 1>; // Force CRC Error
        using FPSE = Field<_DSI_FIR1, 5, 1>; // Force Packet Size Error
        using FEOTPE = Field<_DSI_FIR1, 6, 1>; // Force EoTp Error
        using FLPWRE = Field<_DSI_FIR1, 7, 1>; // Force LTDC Payload Write Error
        using FGCWRE = Field<_DSI_FIR1, 8, 1>; // Force Generic Command Write Error
        using FGPWRE = Field<_DSI_FIR1, 9, 1>; // Force Generic Payload Write Error
        using FGPTXE = Field<_DSI_FIR1, 10, 1>; // Force Generic Payload Transmit Error
        using FGPRDE = Field<_DSI_FIR1, 11, 1>; // Force Generic Payload Read Error
        using FGPRXE = Field<_DSI_FIR1, 12, 1>; // Force Generic Payload Receive Error
    };

    // DSI Host Video Shadow Control Register
    struct _DSI_VSCR : Register<DSI_BASE + 0x100, ReadWrite, _DSI_VSCR> {
        using EN = Field<_DSI_VSCR, 0, 1>; // Enable
        using UR = Field<_DSI_VSCR, 8, 1>; // Update Register
    };

    // DSI Host LTDC Current VCID Register
    struct _DSI_LCVCIDR : Register<DSI_BASE + 0x10C, ReadOnly, _DSI_LCVCIDR> {
        using VCID = Field<_DSI_LCVCIDR, 0, 2>; // Virtual Channel ID
    };

    // DSI Host LTDC Current Color Coding Register
    struct _DSI_LCCCR : Register<DSI_BASE + 0x110, ReadOnly, _DSI_LCCCR> {
        using COLC = Field<_DSI_LCCCR, 0, 4>; // Color Coding
        using LPE = Field<_DSI_LCCCR, 8, 1>; // Loosely Packed Enable
    };

    // DSI Host Low-Power mode Current Configuration Register
    struct _DSI_LPMCCR : Register<DSI_BASE + 0x118, ReadOnly, _DSI_LPMCCR> {
        using VLPSIZE = Field<_DSI_LPMCCR, 0, 8>; // VACT Largest Packet Size
        using LPSIZE = Field<_DSI_LPMCCR, 16, 8>; // Largest Packet Size
    };

    // DSI Host Video mode Current Configuration Register
    struct _DSI_VMCCR : Register<DSI_BASE + 0x138, ReadOnly, _DSI_VMCCR> {
        using VMT = Field<_DSI_VMCCR, 0, 2>; // Video mode Type
        using LPVSAE = Field<_DSI_VMCCR, 2, 1>; // Low-Power Vertical Sync time Enable
        using LPVBPE = Field<_DSI_VMCCR, 3, 1>; // Low-power Vertical Back-Porch Enable
        using LPVFPE = Field<_DSI_VMCCR, 4, 1>; // Low-power Vertical Front-Porch Enable
        using LPVAE = Field<_DSI_VMCCR, 5, 1>; // Low-Power Vertical Active Enable
        using LPHBPE = Field<_DSI_VMCCR, 6, 1>; // Low-power Horizontal Back-Porch Enable
        using LPHFE = Field<_DSI_VMCCR, 7, 1>; // Low-Power Horizontal Front-Porch Enable
        using FBTAAE = Field<_DSI_VMCCR, 8, 1>; // Frame BTA Acknowledge Enable
        using LPCE = Field<_DSI_VMCCR, 9, 1>; // Low-Power Command Enable
    };

    // DSI Host Video Packet Current Configuration Register
    struct _DSI_VPCCR : Register<DSI_BASE + 0x13C, ReadOnly, _DSI_VPCCR> {
        using VPSIZE = Field<_DSI_VPCCR, 0, 14>; // Video Packet Size
    };

    // DSI Host Video Chunks Current Configuration Register
    struct _DSI_VCCCR : Register<DSI_BASE + 0x140, ReadOnly, _DSI_VCCCR> {
        using NUMC = Field<_DSI_VCCCR, 0, 13>; // Number of Chunks
    };

    // DSI Host Video Null Packet Current Configuration Register
    struct _DSI_VNPCCR : Register<DSI_BASE + 0x144, ReadOnly, _DSI_VNPCCR> {
        using NPSIZE = Field<_DSI_VNPCCR, 0, 13>; // Null Packet Size
    };

    // DSI Host Video HSA Current Configuration Register
    struct _DSI_VHSACCR : Register<DSI_BASE + 0x148, ReadOnly, _DSI_VHSACCR> {
        using HSA = Field<_DSI_VHSACCR, 0, 12>; // Horizontal Synchronism Active duration
    };

    // DSI Host Video HBP Current Configuration Register
    struct _DSI_VHBPCCR : Register<DSI_BASE + 0x14C, ReadOnly, _DSI_VHBPCCR> {
        using HBP = Field<_DSI_VHBPCCR, 0, 12>; // Horizontal Back-Porch duration
    };

    // DSI Host Video Line Current Configuration Register
    struct _DSI_VLCCR : Register<DSI_BASE + 0x150, ReadOnly, _DSI_VLCCR> {
        using HLINE = Field<_DSI_VLCCR, 0, 15>; // Horizontal Line duration
    };

    // DSI Host Video VSA Current Configuration Register
    struct _DSI_VVSACCR : Register<DSI_BASE + 0x154, ReadOnly, _DSI_VVSACCR> {
        using VSA = Field<_DSI_VVSACCR, 0, 10>; // Vertical Synchronism Active duration
    };

    // DSI Host Video VBP Current Configuration Register
    struct _DSI_VVBPCCR : Register<DSI_BASE + 0x158, ReadOnly, _DSI_VVBPCCR> {
        using VBP = Field<_DSI_VVBPCCR, 0, 10>; // Vertical Back-Porch duration
    };

    // DSI Host Video VFP Current Configuration Register
    struct _DSI_VVFPCCR : Register<DSI_BASE + 0x15C, ReadOnly, _DSI_VVFPCCR> {
        using VFP = Field<_DSI_VVFPCCR, 0, 10>; // Vertical Front-Porch duration
    };

    // DSI Host Video VA Current Configuration Register
    struct _DSI_VVACCR : Register<DSI_BASE + 0x160, ReadOnly, _DSI_VVACCR> {
        using VA = Field<_DSI_VVACCR, 0, 14>; // Vertical Active duration
    };

    // DSI Wrapper Configuration Register
    struct _DSI_WCFGR : Register<DSI_BASE + 0x400, ReadWrite, _DSI_WCFGR> {
        using VSPOL = Field<_DSI_WCFGR, 7, 1>; // VSync Polarity
        using AR = Field<_DSI_WCFGR, 6, 1>; // Automatic Refresh
        using TEPOL = Field<_DSI_WCFGR, 5, 1>; // TE Polarity
        using TESRC = Field<_DSI_WCFGR, 4, 1>; // TE Source
        using COLMUX = Field<_DSI_WCFGR, 1, 3>; // Color Multiplexing
        using DSIM = Field<_DSI_WCFGR, 0, 1>; // DSI Mode
    };

    // DSI Wrapper Control Register
    struct _DSI_WCR : Register<DSI_BASE + 0x404, ReadWrite, _DSI_WCR> {
        using DSIEN = Field<_DSI_WCR, 3, 1>; // DSI Enable
        using LTDCEN = Field<_DSI_WCR, 2, 1>; // LTDC Enable
        using SHTDN = Field<_DSI_WCR, 1, 1>; // Shutdown
        using COLM = Field<_DSI_WCR, 0, 1>; // Color Mode
    };

    // DSI Wrapper Interrupt Enable Register
    struct _DSI_WIER : Register<DSI_BASE + 0x408, ReadWrite, _DSI_WIER> {
        using RRIE = Field<_DSI_WIER, 13, 1>; // Regulator Ready Interrupt Enable
        using PLLUIE = Field<_DSI_WIER, 10, 1>; // PLL Unlock Interrupt Enable
        using PLLLIE = Field<_DSI_WIER, 9, 1>; // PLL Lock Interrupt Enable
        using ERIE = Field<_DSI_WIER, 1, 1>; // End of Refresh Interrupt Enable
        using TEIE = Field<_DSI_WIER, 0, 1>; // Tearing Effect Interrupt Enable
    };

    // DSI Wrapper Interrupt & Status Register
    struct _DSI_WISR : Register<DSI_BASE + 0x40C, ReadOnly, _DSI_WISR> {
        using RRIF = Field<_DSI_WISR, 13, 1>; // Regulator Ready Interrupt Flag
        using RRS = Field<_DSI_WISR, 12, 1>; // Regulator Ready Status
        using PLLUIF = Field<_DSI_WISR, 10, 1>; // PLL Unlock Interrupt Flag
        using PLLLIF = Field<_DSI_WISR, 9, 1>; // PLL Lock Interrupt Flag
        using PLLLS = Field<_DSI_WISR, 8, 1>; // PLL Lock Status
        using BUSY = Field<_DSI_WISR, 2, 1>; // Busy Flag
        using ERIF = Field<_DSI_WISR, 1, 1>; // End of Refresh Interrupt Flag
        using TEIF = Field<_DSI_WISR, 0, 1>; // Tearing Effect Interrupt Flag
    };

    // DSI Wrapper Interrupt Flag Clear Register
    struct _DSI_WIFCR : Register<DSI_BASE + 0x410, ReadWrite, _DSI_WIFCR> {
        using CRRIF = Field<_DSI_WIFCR, 13, 1>; // Clear Regulator Ready Interrupt Flag
        using CPLLUIF = Field<_DSI_WIFCR, 10, 1>; // Clear PLL Unlock Interrupt Flag
        using CPLLLIF = Field<_DSI_WIFCR, 9, 1>; // Clear PLL Lock Interrupt Flag
        using CERIF = Field<_DSI_WIFCR, 1, 1>; // Clear End of Refresh Interrupt Flag
        using CTEIF = Field<_DSI_WIFCR, 0, 1>; // Clear Tearing Effect Interrupt Flag
    };

    // DSI Wrapper PHY Configuration Register 1
    struct _DSI_WPCR1 : Register<DSI_BASE + 0x418, ReadWrite, _DSI_WPCR1> {
        using TCLKPOSTEN = Field<_DSI_WPCR1, 27, 1>; // custom time for tCLK-POST Enable
        using TLPXCEN = Field<_DSI_WPCR1, 26, 1>; // custom time for tLPX for Clock lane Enable
        using THSEXITEN = Field<_DSI_WPCR1, 25, 1>; // custom time for tHS-EXIT Enable
        using TLPXDEN = Field<_DSI_WPCR1, 24, 1>; // custom time for tLPX for Data lanes Enable
        using THSZEROEN = Field<_DSI_WPCR1, 23, 1>; // custom time for tHS-ZERO Enable
        using THSTRAILEN = Field<_DSI_WPCR1, 22, 1>; // custom time for tHS-TRAIL Enable
        using THSPREPEN = Field<_DSI_WPCR1, 21, 1>; // custom time for tHS-PREPARE Enable
        using TCLKZEROEN = Field<_DSI_WPCR1, 20, 1>; // custom time for tCLK-ZERO Enable
        using TCLKPREPEN = Field<_DSI_WPCR1, 19, 1>; // custom time for tCLK-PREPARE Enable
        using PDEN = Field<_DSI_WPCR1, 18, 1>; // Pull-Down Enable
        using TDDL = Field<_DSI_WPCR1, 16, 1>; // Turn Disable Data Lanes
        using CDOFFDL = Field<_DSI_WPCR1, 14, 1>; // Contention Detection OFF on Data Lanes
        using FTXSMDL = Field<_DSI_WPCR1, 13, 1>; // Force in TX Stop Mode the Data Lanes
        using FTXSMCL = Field<_DSI_WPCR1, 12, 1>; // Force in TX Stop Mode the Clock Lane
        using HSIDL1 = Field<_DSI_WPCR1, 11, 1>; // Invert the High-Speed data signal on Data Lane 1
        using HSIDL0 = Field<_DSI_WPCR1, 10, 1>; // Invert the Hight-Speed data signal on Data Lane 0
        using HSICL = Field<_DSI_WPCR1, 9, 1>; // Invert Hight-Speed data signal on Clock Lane
        using SWDL1 = Field<_DSI_WPCR1, 8, 1>; // Swap Data Lane 1 pins
        using SWDL0 = Field<_DSI_WPCR1, 7, 1>; // Swap Data Lane 0 pins
        using SWCL = Field<_DSI_WPCR1, 6, 1>; // Swap Clock Lane pins
        using UIX4 = Field<_DSI_WPCR1, 0, 6>; // Unit Interval multiplied by 4
    };

    // DSI Wrapper PHY Configuration Register 2
    struct _DSI_WPCR2 : Register<DSI_BASE + 0x41C, ReadWrite, _DSI_WPCR2> {
        using LPRXFT = Field<_DSI_WPCR2, 25, 2>; // Low-Power RX low-pass Filtering Tuning
        using FLPRXLPM = Field<_DSI_WPCR2, 22, 1>; // Forces LP Receiver in Low-Power Mode
        using HSTXSRCDL = Field<_DSI_WPCR2, 18, 2>; // High-Speed Transmission Slew Rate Control on Data Lanes
        using HSTXSRCCL = Field<_DSI_WPCR2, 16, 2>; // High-Speed Transmission Slew Rate Control on Clock Lane
        using SDCC = Field<_DSI_WPCR2, 12, 1>; // SDD Control
        using LPSRDL = Field<_DSI_WPCR2, 8, 2>; // Low-Power transmission Slew Rate Compensation on Data Lanes
        using LPSRCL = Field<_DSI_WPCR2, 6, 2>; // Low-Power transmission Slew Rate Compensation on Clock Lane
        using HSTXDLL = Field<_DSI_WPCR2, 2, 2>; // High-Speed Transmission Delay on Data Lanes
        using HSTXDCL = Field<_DSI_WPCR2, 0, 2>; // High-Speed Transmission Delay on Clock Lane
    };

    // DSI Wrapper PHY Configuration Register 3
    struct _DSI_WPCR3 : Register<DSI_BASE + 0x420, ReadWrite, _DSI_WPCR3> {
        using THSTRAIL = Field<_DSI_WPCR3, 24, 8>; // tHSTRAIL
        using THSPREP = Field<_DSI_WPCR3, 16, 8>; // tHS-PREPARE
        using TCLKZEO = Field<_DSI_WPCR3, 8, 8>; // tCLK-ZERO
        using TCLKPREP = Field<_DSI_WPCR3, 0, 8>; // tCLK-PREPARE
    };

    // DSI_WPCR4
    struct _DSI_WPCR4 : Register<DSI_BASE + 0x424, ReadWrite, _DSI_WPCR4> {
        using TLPXC = Field<_DSI_WPCR4, 24, 8>; // tLPXC for Clock lane
        using THSEXIT = Field<_DSI_WPCR4, 16, 8>; // tHSEXIT
        using TLPXD = Field<_DSI_WPCR4, 8, 8>; // tLPX for Data lanes
        using THSZERO = Field<_DSI_WPCR4, 0, 8>; // tHS-ZERO
    };

    // DSI Wrapper PHY Configuration Register 5
    struct _DSI_WPCR5 : Register<DSI_BASE + 0x428, ReadWrite, _DSI_WPCR5> {
        using THSZERO = Field<_DSI_WPCR5, 0, 8>; // tCLK-POST
    };

    // DSI Wrapper Regulator and PLL Control Register
    struct _DSI_WRPCR : Register<DSI_BASE + 0x430, ReadWrite, _DSI_WRPCR> {
        using REGEN = Field<_DSI_WRPCR, 24, 1>; // Regulator Enable
        using ODF = Field<_DSI_WRPCR, 16, 2>; // PLL Output Division Factor
        using IDF = Field<_DSI_WRPCR, 11, 4>; // PLL Input Division Factor
        using NDIV = Field<_DSI_WRPCR, 2, 7>; // PLL Loop Division Factor
        using PLLEN = Field<_DSI_WRPCR, 0, 1>; // PLL Enable
    };

} // namespace DSI

// --------------------------------------------
// DBGMCU: MCU debug component
// Base address: 0xE0042000
// --------------------------------------------

namespace DBGMCU {
    static constexpr uint32_t DBGMCU_BASE = 0xE0042000;

    // DBGMCU_IDCODE
    struct _IDCODE : Register<DBGMCU_BASE + 0x0, ReadOnly, _IDCODE> {
        using DEV_ID = Field<_IDCODE, 0, 12>; // Device identifier
        using REV_ID = Field<_IDCODE, 16, 16>; // Revision identifie
    };

} // namespace DBGMCU



 /* stm32f767
 

--------------------------------------------------------------------------------
--------------------- End of STM32F767 Register Descripton ---------------------
--------------------------------------------------------------------------------    
*/


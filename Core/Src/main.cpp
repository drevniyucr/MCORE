/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "mcore.hpp"
#include <cstdio>

void GPIO_Init(void);
void RCC_Init(void);
// void TIM2_Init(void);
// void TIM3_Init(void);
void Error_Handler(void);

void print(const char *str){
 while (*str){
	 if ((ITM::_TCR::ITMENA::read() != 0U) && (ITM::_TER::STIMENA0::read() != 0U))   // проверяем включен ли ITM и порт 0
    {
        while (ITM::_PORT0::u32::read() == 0U){
			__NOP();
		}
		ITM::_PORT0::u8::write(*str);
    }
	 str++;
 }
}

void DWT_Init(void)
{
	SCB::_DEMCR::TRCENA::set();
	DWT::_CYCCNT::VALUE::write(0U);
	DWT::_CTRL::CYCCNTENA::set(); // Enable the cycle counter
}

uint8_t udp_data[] = "LMAO LMAO LMAO LMAO LMAO LMAO LMAO";
uint8_t dst_ip[] = { 192, 168, 0, 10 };
uint8_t dst_mac[] = { 0xD8, 0x43, 0xAE, 0x7D, 0x7B, 0x40 };


UDP_SendFrameStruct UDPframe = { dst_mac, dst_ip, 64746, 5000, // @suppress("Invalid arguments")
		udp_data, sizeof(udp_data) };
char buf[64];

int main(void)
{  
	SCB::_DEMCR::setMask(1U<<24U);
	ITM::_LAR::overwrite(0xC5ACCE55);
	ITM::_TCR::overwrite(0x10009U);    // Enable ITM + Trace Bus
	ITM::_TER::overwrite(1U);          // Разрешить порт 0
	DWT::_CTRL::CYCCNTENA::set(); // Enable the cycle counter
	DWT::_CYCCNT::overwrite(0U);
	uint32_t DWTctrl = DWT::_CTRL::read();
	uint32_t DEMCR = SCB::_DEMCR::read();
	uint32_t start = DWT::_CYCCNT::read();
	SystemInit();
	NVIC_API::SetPriorityGrouping<NVIC_PriorityGroup::Group4>();
	RCC_Init();
    MPU_Config();
    SCB_EnableICache();
    // SCB_EnableDCache(); может быть не стоит
    enableEthInterface();
    GPIO_Init();
    ETH_Init();
    // TIM2_Init();
    // TIM3_Init();
    NET_TCP_Init();
    uint32_t tickstart = get_tick();
    NVIC_API::enable_irq_global();
    uint32_t end = DWT::_CYCCNT::read();
	sprintf(buf, "spend %lu cycles\n", end - start);
	print(buf);
	sprintf(buf, "DWT CTRL %lu \n", DWTctrl);
	print(buf);
	sprintf(buf, "start %lu \n", start);
	print(buf);
	sprintf(buf, "end %lu \n", end);
	print(buf);
	sprintf(buf, "DEMCR %lu \n", DEMCR);
	print(buf);
	while (true)
    {
        ETH_RxWorker();
        if ((get_tick() - tickstart) > 5000) {
        	tickstart = get_tick();
        	if (tcp_clients[9].state == tcp_state_t::TCP_ESTABLISHED){
        	NET_TCP_SendUser(&tcp_clients[9], udp_data,sizeof(udp_data));
        NET_SendUDP(UDPframe);
        	}
        }
    }
}

void RCC_Init(void) {
	constexpr const ClockConfig cfg = {
			.PLLM = 4,              // MCO(8Mhz)/8=2
			.PLLN = 216,            // 2*216 = 432
			.PLLP = PLL_P::Div2,    // 432/2=216MHz SYSCKL MAX
			.AHBDiv = AHBPrescaler::Div1,    // 216MHz HCKL MAX
			.APB1Div = APBPrescaler::Div4,    //216/4=54 MHz APB1 MAX
			.APB2Div = APBPrescaler::Div2,    //216/2=108 MHz APB2 MAX
			.FLASHLatency = FLASH_Latency::WS7,
			.useHSE = true,
			.useHSEBypass =true,
			.useSysTick = true
};

	enablePowerInterface();
	SetVoltageScale(VoltageScale::Scale1);
	RCCStatus osc = OSCInit(&cfg);
	RCCStatus OverDrive = OverDriveInit();
	RCCStatus clock = RCC_ClockInit(&cfg);

	if (
			osc != RCCStatus::OK ||
			OverDrive != RCCStatus::OK||
			clock != RCCStatus::OK)
	{
		Error_Handler();
	}

};

// extern "C" void TIM2_IRQHandler(void) {
// 	uint32_t now;
// 	if (TIM2->SR & TIM_SR_CC3IF) {
// 		now = TIM2->CCR3; // значение счётчика при фронте
// 		if (!waiting_fall[0]) {
// 			// Поймали фронт вверх
// 			t_rise[0] = now;
// 			waiting_fall[0] = 1;
// 			TIM2->CCER |= TIM_CCER_CC3P;   // переключаем на falling
// 		} else {
// 			// Поймали фронт вниз
// 			high_time[0] = now - t_rise[0];
// 			waiting_fall[0] = 0;
// 			TIM2->CCER &= ~TIM_CCER_CC3P;  // обратно на rising
// 		}
// 		TIM2->SR &= ~TIM_SR_CC3IF;
// 	}
// 	if (TIM2->SR & TIM_SR_CC4IF) {
// 		now = TIM2->CCR4; // значение счётчика при фронте
// 		if (!waiting_fall[1]) {
// 			// Поймали фронт вверх
// 			t_rise[1] = now;
// 			waiting_fall[1] = 1;
// 			TIM2->CCER |= TIM_CCER_CC4P;   // переключаем на falling
// 		} else {
// 			// Поймали фронт вниз
// 			high_time[1] = now - t_rise[1];
// 			waiting_fall[1] = 0;
// 			TIM2->CCER &= ~TIM_CCER_CC4P;  // обратно на rising
// 		}
// 		TIM2->SR &= ~TIM_SR_CC4IF;
// 	}
// }

// extern "C" void TIM3_IRQHandler(void) {
// 	uint16_t now;
// 	if (TIM3->SR & TIM_SR_CC1IF) {
// 		now = (uint16_t) TIM3->CCR1; // значение счётчика при фронте
// 		if (!waiting_fall[2]) {
// 			// Поймали фронт вверх
// 			t_rise[2] = now;
// 			waiting_fall[2] = 1;
// 			TIM3->CCER |= TIM_CCER_CC1P;   // переключаем на falling
// 		} else {
// 			// Поймали фронт вниз
// 			high_time[2] = (uint16_t) (now - t_rise[2]);
// 			waiting_fall[2] = 0;
// 			TIM3->CCER &= ~TIM_CCER_CC1P;  // обратно на rising
// 		}
// 		TIM3->SR &= ~TIM_SR_CC1IF;
// 	}
// 	if (TIM3->SR & TIM_SR_CC2IF) {
// 		now = (uint16_t) TIM3->CCR2; // значение счётчика при фронте
// 		if (!waiting_fall[3]) {
// 			// Поймали фронт вверх
// 			t_rise[3] = now;
// 			waiting_fall[3] = 1;
// 			TIM3->CCER |= TIM_CCER_CC2P;   // переключаем на falling
// 		} else {
// 			// Поймали фронт вниз
// 			high_time[3] = (uint16_t) (now - t_rise[3]);
// 			waiting_fall[3] = 0;
// 			TIM3->CCER &= ~TIM_CCER_CC2P;  // обратно на rising
// 		}
// 		TIM3->SR &= ~TIM_SR_CC2IF;
// 	}
// 	if (TIM3->SR & TIM_SR_CC3IF) {
// 		now = (uint16_t) TIM3->CCR3; // значение счётчика при фронте
// 		if (!waiting_fall[4]) {
// 			// Поймали фронт вверх
// 			t_rise[4] = now;
// 			waiting_fall[4] = 1;
// 			TIM3->CCER |= TIM_CCER_CC3P;   // переключаем на falling
// 		} else {
// 			// Поймали фронт вниз
// 			high_time[4] = (uint16_t) (now - t_rise[4]);
// 			waiting_fall[4] = 0;
// 			TIM3->CCER &= ~TIM_CCER_CC3P;  // обратно на rising
// 		}
// 		TIM3->SR &= ~TIM_SR_CC3IF;
// 	}
// 	if (TIM3->SR & TIM_SR_CC4IF) {
// 		now = (uint16_t) TIM3->CCR4; // значение счётчика при фронте
// 		if (!waiting_fall[5]) {
// 			// Поймали фронт вверх
// 			t_rise[5] = now;
// 			waiting_fall[5] = 1;
// 			TIM3->CCER |= TIM_CCER_CC4P;   // переключаем на falling
// 		} else {
// 			// Поймали фронт вниз
// 			high_time[5] = (uint16_t) (now - t_rise[5]);
// 			waiting_fall[5] = 0;
// 			TIM3->CCER &= ~TIM_CCER_CC4P;  // обратно на rising
// 		}
// 		TIM3->SR &= ~TIM_SR_CC4IF;
// 	}
// }

// void TIM2_Init(void) {

// 	RCC_TIM2EN();
// 	/* Set the Autoreload value */
// 	TIM2->ARR = 0xFFFFFFFF;
// 	/* Set the Prescaler value */
// 	TIM2->PSC = 108 - 1;
// 	TIM2->EGR = TIM_EGR_UG;
// 	/* Clear the update flag */
// 	TIM2->SR &= ~TIM_SR_UIF;
// 	uint32_t tmpccmr2;
// 	uint32_t tmpccer;
// 	/*-----------------CHANNEL_3-----------------*/

// 	TIM2->CCER &= ~TIM_CCER_CC3E;
// 	tmpccer = TIM2->CCER;
// 	tmpccmr2 = TIM2->CCMR2;
// 	/* Select the Polarity and set the CC3E Bit */
// 	tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
// 	tmpccer |= TIM_CCER_CC3P; //unipolar both edge
// 	/* Select the Input */
// 	tmpccmr2 &= ~TIM_CCMR2_CC3S;
// 	tmpccmr2 |= TIM_CCMR2_CC3S_0; //CC1 channel is configured as input, IC1 is mapped on TI1
// 	/* Write to TIMx CCMR2 and CCER registers */
// 	TIM2->CCMR2 = tmpccmr2;
// 	TIM2->CCER = tmpccer;
// 	// interupt ch3 enable
// 	TIM2->DIER = TIM_DIER_CC3IE;
// 	/* Reset the CCxE Bit */
// 	TIM2->CCER &= ~TIM_CCER_CC3E;
// 	/* Set or reset the CCxE Bit */
// 	TIM2->CCER |= TIM_CCER_CC3E; // ch1 enable

// 	/*-----------------CHANNEL_4-----------------*/
// 	TIM2->CCER &= ~TIM_CCER_CC4E;
// 	tmpccer = TIM2->CCER;
// 	tmpccmr2 = TIM2->CCMR2;
// 	/* Select the Polarity and set the CC3E Bit */
// 	tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
// 	tmpccer |= TIM_CCER_CC4P; //unipolar both edge
// 	/* Select the Input */
// 	tmpccmr2 &= ~TIM_CCMR2_CC4S;
// 	tmpccmr2 |= TIM_CCMR2_CC4S_0; //CC4 channel is configured as input, IC4 is mapped on TI4
// 	/* Write to TIMx CCMR2 and CCER registers */
// 	TIM2->CCMR2 = tmpccmr2;
// 	TIM2->CCER = tmpccer;
// 	// interupt ch3 enable
// 	TIM2->DIER = TIM_DIER_CC4IE;
// 	/* Reset the CCxE Bit */
// 	TIM2->CCER &= ~TIM_CCER_CC4E;
// 	/* Set or reset the CCxE Bit */
// 	TIM2->CCER |= TIM_CCER_CC4E; // ch4 enable
// 	/*-------------------------------------------*/

// 	TIM2->CR1 |= TIM_CR1_CEN; // tim2 enable

// 	__NVIC_SetPriority(TIM2_IRQn, 0);
// 	__NVIC_EnableIRQ(TIM2_IRQn);
// }

// void TIM3_Init(void) {

// 	RCC_TIM3EN();
// 	/* Set the Autoreload value */
// 	TIM3->ARR = 0xFFFFFFFF;
// 	/* Set the Prescaler value */
// 	TIM3->PSC = 108 - 1;
// 	TIM3->EGR = TIM_EGR_UG;
// 	/* Clear the update flag */
// 	TIM3->SR &= ~TIM_SR_UIF;
// 	uint32_t tmpccer;
// 	uint32_t tmpccmr1;
// 	uint32_t tmpccmr2;
// 	/*-----------------CHANNEL_1-----------------*/
// 	TIM3->CCER &= ~TIM_CCER_CC1E;
// 	tmpccer = TIM3->CCER;
// 	tmpccmr1 = TIM3->CCMR1;
// 	/* Select the Polarity and set the CC3E Bit */
// 	tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
// 	tmpccer |= TIM_CCER_CC1P; //unipolar both edge
// 	/* Select the Input */
// 	tmpccmr1 &= ~TIM_CCMR1_CC1S;
// 	tmpccmr1 |= TIM_CCMR1_CC1S_0; //CC1 channel is configured as input, IC1 is mapped on TI1
// 	/* Write to TIMx CCMR2 and CCER registers */
// 	TIM3->CCMR1 = tmpccmr1;
// 	TIM3->CCER = tmpccer;
// 	// interupt ch3 enable
// 	TIM3->DIER = TIM_DIER_CC1IE;
// 	/* Reset the CCxE Bit */
// 	TIM3->CCER &= ~TIM_CCER_CC1E;
// 	/* Set or reset the CCxE Bit */
// 	TIM3->CCER |= TIM_CCER_CC1E; // ch1 enable
// 	/*-----------------CHANNEL_2-----------------*/

// 	TIM3->CCER &= ~TIM_CCER_CC2E;
// 	tmpccer = TIM3->CCER;
// 	tmpccmr1 = TIM3->CCMR1;
// 	/* Select the Polarity and set the CC3E Bit */
// 	tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
// 	tmpccer |= TIM_CCER_CC2P; //unipolar both edge
// 	/* Select the Input */
// 	tmpccmr1 &= ~TIM_CCMR1_CC2S;
// 	tmpccmr1 |= TIM_CCMR1_CC2S_0; //CC1 channel is configured as input, IC1 is mapped on TI1
// 	/* Write to TIMx CCMR2 and CCER registers */
// 	TIM3->CCMR1 = tmpccmr1;
// 	TIM3->CCER = tmpccer;
// 	// interupt ch3 enable
// 	TIM3->DIER = TIM_DIER_CC2IE;
// 	/* Reset the CCxE Bit */
// 	TIM3->CCER &= ~TIM_CCER_CC2E;
// 	/* Set or reset the CCxE Bit */
// 	TIM3->CCER |= TIM_CCER_CC2E; // ch1 enable

// 	/*-----------------CHANNEL_3-----------------*/

// 	TIM3->CCER &= ~TIM_CCER_CC3E;
// 	tmpccer = TIM3->CCER;
// 	tmpccmr2 = TIM3->CCMR2;
// 	/* Select the Polarity and set the CC3E Bit */
// 	tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
// 	tmpccer |= TIM_CCER_CC3P; //unipolar both edge
// 	/* Select the Input */
// 	tmpccmr2 &= ~TIM_CCMR2_CC3S;
// 	tmpccmr2 |= TIM_CCMR2_CC3S_0; //CC1 channel is configured as input, IC1 is mapped on TI1
// 	/* Write to TIMx CCMR2 and CCER registers */
// 	TIM3->CCMR2 = tmpccmr2;
// 	TIM3->CCER = tmpccer;
// 	// interupt ch3 enable
// 	TIM3->DIER = TIM_DIER_CC3IE;
// 	/* Reset the CCxE Bit */
// 	TIM3->CCER &= ~TIM_CCER_CC3E;
// 	/* Set or reset the CCxE Bit */
// 	TIM3->CCER |= TIM_CCER_CC3E; // ch1 enable

// 	/*-----------------CHANNEL_4-----------------*/
// 	TIM3->CCER &= ~TIM_CCER_CC4E;
// 	tmpccer = TIM3->CCER;
// 	tmpccmr2 = TIM3->CCMR2;
// 	/* Select the Polarity and set the CC3E Bit */
// 	tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
// 	tmpccer |= TIM_CCER_CC4P; //unipolar both edge
// 	/* Select the Input */
// 	tmpccmr2 &= ~TIM_CCMR2_CC4S;
// 	tmpccmr2 |= TIM_CCMR2_CC4S_0; //CC4 channel is configured as input, IC4 is mapped on TI4
// 	/* Write to TIMx CCMR2 and CCER registers */
// 	TIM3->CCMR2 = tmpccmr2;
// 	TIM3->CCER = tmpccer;
// 	// interupt ch3 enable
// 	TIM3->DIER = TIM_DIER_CC4IE;
// 	/* Reset the CCxE Bit */
// 	TIM3->CCER &= ~TIM_CCER_CC4E;
// 	/* Set or reset the CCxE Bit */
// 	TIM3->CCER |= TIM_CCER_CC4E; // ch4 enable
// 	/*-------------------------------------------*/

// 	TIM3->CR1 |= TIM_CR1_CEN; // tim2 enable
// 	__NVIC_SetPriority(TIM3_IRQn, 0);
// 	__NVIC_EnableIRQ(TIM3_IRQn);
// }

void GPIO_Init(void) {

	RCC_GPIO_ALLEN();

	GPIO_Config GPIO_ConfigStruct = {};
	uint32_t pin_mask;

	/**ETH GPIO Configuration
	 PC1     ------> ETH_MDC
	 PA1     ------> ETH_REF_CLK
	 PA2     ------> ETH_MDIO
	 PA7     ------> ETH_CRS_DV
	 PC4     ------> ETH_RXD0
	 PC5     ------> ETH_RXD1
	 PB13     ------> ETH_TXD1
	 PG11     ------> ETH_TX_EN
	 PG13     ------> ETH_TXD0
	 */

	GPIO_ConfigStruct.mode = Mode::Alt;
	GPIO_ConfigStruct.otype = OType::PP;
	GPIO_ConfigStruct.pull = Pull::None;
	GPIO_ConfigStruct.speed = Speed::VeryHigh;
	GPIO_ConfigStruct.af = AF::AF11;
	pin_mask = (1U << 1) | (1U << 2) | (1U << 7); //(PA1,2,7)
	GPIO_ConfigGroupPin<GPIOA>(GPIO_ConfigStruct, pin_mask);

	GPIO_ConfigPin<GPIOB>(GPIO_ConfigStruct, 13); //PB13

	pin_mask = (1U << 1) | (1U << 4) | (1U << 5); //PC1,4,5
	GPIO_ConfigGroupPin<GPIOC>(GPIO_ConfigStruct, pin_mask);

	pin_mask = (1U << 11) | (1U << 13); //PG11,13
	GPIO_ConfigGroupPin<GPIOG>(GPIO_ConfigStruct, pin_mask);

	/**TIM GPIO Configuration
	 PB10     ------> TIM2_CH3
	 PA3     ------> TIM2_CH4
	 PA6     ------> TIM3_CH1
	 PC7     ------> TIM3_CH2
	 PB0     ------> TIM3_CH3
	 PB1     ------> TIM3_CH4
	 */

	GPIO_ConfigStruct.pull = Pull::PullUp;
	GPIO_ConfigStruct.af = AF::AF1; // TIM2
	GPIO_ConfigPin<GPIOB>(GPIO_ConfigStruct, 10); // PB10

	GPIO_ConfigPin<GPIOA>(GPIO_ConfigStruct, 3); // PA3

	GPIO_ConfigStruct.af = AF::AF2; // TIM3
	GPIO_ConfigPin<GPIOA>(GPIO_ConfigStruct, 6); //PA6

	GPIO_ConfigPin<GPIOC>(GPIO_ConfigStruct, 7); //PC7

	pin_mask = (1U << 0) | (1U << 1); //PB0,1
	GPIO_ConfigGroupPin<GPIOB>(GPIO_ConfigStruct, pin_mask);

}

void Error_Handler(void) {
	while (1) {

	}
}
